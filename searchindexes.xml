<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
  
  <entry>
    <title>欢迎加入 VxWorks 俱乐部！</title>
    <url>/post/welcome-to-vxworks-club/</url>
    <categories><category>Announce</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>WindRiver</tag>
    </tags>
    <content type="html"><![CDATA[欢迎来到 北南南北 文档站点！ 相关文章来源于 VxWorks 俱乐部  ，也可能发布于 AI 嵌入式开发  ，专注于技术分享和交流。
免责声明 所有资源均来自网络，版权归原作者，如有侵权，请联系删除！
欢迎投稿  欢迎广大网友投稿 欢迎加入网友微信群  ]]></content>
  </entry>
  
  <entry>
    <title>VxWorks开发环境Workbench与Tornado介绍</title>
    <url>/post/bsp/introduction-of-workbench-and-tornado-for-vxworks.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Workbench</tag>
      <tag>Tornado</tag>
    </tags>
    <content type="html"><![CDATA[Workbench无疑是当前VxWorks软件开发领域中功能非常强大的一个集成开发环境
嵌入式系统开发所面临的问题 嵌入式软件开发有别于桌面软件系统开发的一个显著的特点是它一般需要一个交叉编译和调试环境，即编辑和编译软件在主机上进行（如在PC机的Windows操作系统下），编译好的软件需要下载到目标机上运行（如在一个PPC的目标机上的VxWorks操作系统下），主机和目标机建立起通讯连接，并传输调试命令和数据。由于主机和目标机往往运行着不同的操作系统，而且处理器的体系结构也彼此不同，这就提高了嵌入式开发的复杂性。
总的来说，嵌入式开发所面临的问题主要表现在以下几个方面：
涉及多种CPU及多种OS 嵌入式的CPU或处理器可谓多种多样，这包括了PENTIUM、MIPS、PPC、ARM，XSCALE等，而且应用都很广，在其上运行的操作系统也有不少，如VxWorks, Linux, Nuclears,WinCE等等，即使在一个公司之内，也会同时使用好几种处理器，甚至几种嵌入式操作系统。如果需要同时调试多种类型的板子，每个扳子上又运行着多个任务或进程，那复杂性是可想而知的。
开发工具种类繁多 不仅各种操作系统有各自的开发工具，在同一系统下开发的不同阶段也有不同的开发工具。如在用户的目标板开发初期，需要硬件仿真器来调试硬件系统和基本的驱动程序，在调试应用程序阶段可以使用交互式的开发环境进行软件调试，在测试阶段需要一些专门的测试工具软件进行功能和性能的测试，在生产阶段需要固化程序及出厂检测等等。一般每一种工具都要从不同的供应商处购买，都要单独去学习和掌握，这无疑增加了整个公司的支出和管理的难度。
对目标系统的观察和控制 由于嵌入式硬件系统千差万别，软件模块和系统资源也多种多样，要使系统能正常工作，软件开发者必须要对目标系统具有完全的观察和控制能力，例如硬件的各种寄存器、内存空间，操作系统的信号量、消息队列、任务、堆栈等。
此外，嵌入式系统变化更新比较快，对开发时间要求比较紧，尤其是消费类产品更是如此，如果有一套功能强大的嵌入式软件集成开发工具可以满足嵌入式软件开发各个阶段的需求，同时又使用方便，界面友好，那是最理想不过了。美国风河系统公司（以下简称为“风河公司”）新近推出的“Workbench”嵌入式软件开发平台正是这样一个“全能选手”。
Workbench嵌入式开发平台的特点和优势 风河公司一直致力于嵌入式软件领域的研究，其历史悠久的Tornado开发环境和VxWorks嵌入式操作系统产品在嵌入式领域中应用非常广泛，尤以其业界领先的强实时性和稳定性而著称于世。风河公司的新一代Workbench开发平台继承了其原有的Tornado集成开发平台的一贯优势，并且功能更加强大，由于新采用了先进的Eclipse软件框架结构，从而使整个系统更加开放和易于扩展。它的主要优势表现在：
以开放的Eclipse平台为框架，调试环境可充分进行客户化定制 Eclipse软件框架结构是一个完整和开放的基础平台，它能够将图形工具以及任何必须的功能通过标准的接口集成到同一个开发环境中。目前IBM，HP及Borland等商业开发工具提供商均支持Eclipse开发平台，网上也存在着大量的为Eclipse平台开发插件的社区。由于Workbench符合Eclipse框架，所以这些商用的和免费的符合Eclipse平台接口的插件均可以集成到Workbench开发环境中，这极大扩展了Workbench的功能。例如，如果用户想使用自己熟悉的配置管理工具或者编辑器，就可以找到这样一个插件并集成进来，这样用户就会感到开发过程非常适合自己的需要。
不仅如此，风河公司还对Eclipse做了多方面的增强，从而显著提高了系统的性能。例如Workbench实现了异步接口功能，需要长时间运行的任务可以在后台运行，与此同时还能继续接收开发人员的调试请求，这样不至于使开发人员做长时间的等待；另外，Workbench还优化了对目标机数据的请求机制，即系统只检索在集成开发环境的当前视图中所需要的少量数据，看不见的数据则不向目标机索取，这样就大大提高了交叉调试时系统的响应速度并减少了系统负荷。
单一的全功能平台，涉及到产品的整个开发周期 一个嵌入式产品的软件开发，其“实质性”的过程包括了从开始的硬件启动，BSP（板级支持包）及驱动的开发，到应用程序的开发，再到后来的测试、验证，直至最后的生产阶段。一般来说，每个阶段都可以找到不同的工具来使用（实际情况也大都如此）。而风河公司的Workbench开发平台改变了这一现状，它以一个单一的Workbench平台，提供了上述开发阶段所需要的几乎所有功能。具体来说，这包括了硬件系统仿真功能（有配套的硬件仿真器），工程管理和构建系统，编辑器，版本管理，命令解释器，调试工具，系统分析工具，系统观察工具，FLASH编程工具等等，再加上风河公司自己开发的和第三方厂家提供的各种软件功能模块和开发工具的插件，所有这一切，都集成在Workbench这个统一的平台之下，这必将大大改善嵌入式软件的开发环境。对一个企业来讲，更可以提高效率，减少投资，简化管理。嵌入式软件开发的各个阶段以及Workbench在各个阶段提供的功能如图2所示。
广泛的适用性，特别适合复杂的目标系统 Workbench平台的广泛适用性主要体现在七“多”上，即多任务、多目标、多模式、多OS、多CPU、多连接形式、多主机环境。
  多任务：在Workbench调试环境下，可以同时连接目标系统上的多个不同的任务（或者进程），每个任务都可以单独设置断点，进行单步调试。开发者再也不用象以前那样，为了调试多个任务，先断开一个任务的连接，再连接到另外一个任务上去。这就给具有多任务的目标系统开发提供了便利，尤其是需要查看多个任务之间的配合关系时体现的优势更加明显；
  多CPU：我们知道，风河公司的Tornado开发环境可以说已经支持了全系列的主流CPU（或处理器），而Workbench也将继承这个传统，目前推出的Workbench 2.2版本已经可以支持PENTIUM、PPC、MIPS系列的所有主流CPU。对ARM、XSCALE、SH等系列的支持正在移植和测试中，不久即将发布正式版本（Workbench 2.3）。
  多OS：目前的Workbench 2.2不仅支持VxWorks嵌入式操作系统（6.0以上版本），而且支持Linux操作系统，这确实给广大的Linux嵌入式开发人员带来了福音。大家知道，由于Linux操作系统的“免费”性质，使得其上的软件开发系统一直比较分散和孤立，用起来不是特别方便，有了Workbench以后，嵌入式Linux的开发就同VxWorks的开发一样方便和快捷了。并且以后，如果有必要的话，还可以增加对其它类型嵌入式操作系统的支持，因为Workbench本身是开放和可扩展的。
  多目标：Workbench对复杂目标系统的强有力的支持还表现在它可以支持同时连接多块目标板进行调试开发，更为可贵的是这些目标板上处理器可以各不相同，并且在目标板上运行的操作系统也可任意（既可以运行VxWorks，也可以运行Linux），而调试工作都可以在同一个Workbench界面中同时进行，这无疑给一些复杂系统的调试带来了极大的便利。
  多连接：所谓多连接，是指Workbench所在的主机和目标机之间可以有多种连接方式进行通讯，如果目标系统中存在以太网接口，那就应该首选以太网连接，因为这种方式速度比较快；如果目标系统中不存在以太网接口，那也可以选用串行口进行通讯连接，除了速度较慢以外，功能上与以太网连接没有什么区别。另外，在目标板初始调试阶段，还可通过风河的硬件仿真器（WindRiver ICE / WindRiver Probe）进行连接，观察硬件状态，以迅速定位硬件问题。
  多模式：在Workbench中调试程序，即可以采用任务模式，也可以采用系统模式。所谓任务模式，是指各个任务之间独立运行，暂停其中一个任务的运行不影响其他任务的运行（主要用于调试各个任务）；而系统模式则是指只要暂停了系统的任何一处，整个系统都停止下来（主要用于调试中断程序）。
  多主机：这是指Workbench可以在Windows、Linux、Solaris这三大流行的主机操作系统下运行，这不仅可以适合不同开发者的使用习惯，而且在一定程度上有利于某些目标系统的开发，如使用Linux主机环境调试运行Linux系统的目标板（但这并不是必须的）。
  丰富易用的调试手段，大大加快调试进度   动态链接：用过Tornado开发环境的人都对其独特的分模块单独下载、动态链接到目标系统的功能深有体会，而Workbench也完全继承了这个特性。有了这个功能，就使开发者不必将所有应用模块都编写完成再进行调试，也不用每次将应用模块和操作系统编译到一起然后下载调试，而是编好一个小模块，如果想进行验证，只需将这个小模块（哪怕只是一个函数）编译然后下载到目标板中就行了，这大大加快了调试验证的速度，尤其是在目标板和主机之间是低速连接的情况下更能体现出其优势所在。
  目标可视：对目标系统的可视化是每一个嵌入式软件开发人员都希望得到的功能，为达到这一目的，Workbench除了提供一般的查看内存，积存器、变量、调用树等的传统视图工具外，还提供了几种增强的系统查看工具：目标浏览器、系统观察器和SCOPETOOLS工具集。目标浏览器可以用来查看目标系统每一个系统资源的使用情况和当前状态，包括系统各个模块、任务、信号量、消息队列、内存、堆栈等。系统观察器可对系统事件提供详细的分析和图形化的可视效果，同时还可展示在目标机上执行的应用程序的相关任务、中断以及系统对象之间复杂的交互作用。它能够清楚地显示上下文变化以及信号量、消息队列、信号、任务、用户事件和记时器一类的系统事件，就象一个软件的“示波器”。应用这些系统查看工具，开发人员可以很容易地去诊断和解决嵌入式系统中存在的调度问题（如死锁，饥饿和竞争），性能问题（如优先级设置，资源的竞争与互斥），定时问题等。而RTI SCOPETOOLS则是专门为设备类软件开发提供的一组强大的可视化工具集，用户可以动态观察整个系统平台，包括应用代码、第三方的库，甚至操作系统本身。Workbench 2.2中集成进来了用于观察函数执行效率的ProfileScope工具，用于观察内存使用效率和检测内存泄露的MemScope工具，和用于检测变量或指定内存位置处数值的动态变化情况的StethoScope工具。另外，还有可选的用于实时跟踪代码执行情况的TraceScope工具和用于检测代码执行覆盖率的CoverageScope工具。
  仿真环境：在目标系统的硬件开发完成之前，往往软件系统的开发也要同步进行，Workbench提供的模拟仿真环境（只适用于针对VxWorks操作系统的应用软件开发）就提供了这种同步开发的途径。VxWorks软件仿真器运行于主机操作系统环境中，是一种从VxWorks6.0操作系统移植过来的本地应用程序，它能够精确地实施VxWorks 6.0的高级复杂特性，包括实时进程、内存保护等，它还具有完整的文件系统和网络功能，并能调用主机系统API。这些特性使得在VxWorks软件仿真器中开发复杂的系统成为可能。例如，在VxWorks软件仿真器中可以组建多个网络，这些网络不但互相之间可以通讯，还可以通过主机系统的网口与外界相连，实现一个完全真实的网络环境；再例如，可以利用主机系统的显示屏幕来开发具有图形用户界面的应用程序，这是通过调用主机系统与图形相关的API来实现的。一般来说，用户可以为主机系统的任何资源编写API，而在VxWorks软件仿真环境中进行调用，这极大地扩展了VxWorks软件仿真器的功能，也更便于应用软件的同步开发。
  除了以上所提到的需要特别强调的功能外，Workbench的强大调试功能还表现在支持各种类型的断点设置、方便灵活的操作系统内核配置工具，具有主机Shell和目标机Shell，具有4种命令解释器，以及丰富的视图界面等等，详细情况请参考Workbench的说明及手册，这里就不多做介绍。总之，使用Workbench给开发人员的感受就是方便灵活，功能强大，几乎无所不能。
  Workbench与Tornado的功能对比 Workbench平台相对于Tornado平台来说，各项功能均有所增强，也有不少新加入的功能，主要的功能对比如下表所列：
Workbench是对Tornado的一次脱胎换骨的升级，但目前并不能说Workbench就可以完全取代Tornado。这是因为Workbench只对VxWorks6.0以上的版本（具有“进程”的概念）进行支持，如果用户想使用VxWorks6.0以下的版本（扁平地址空间，应用程序均在内核中运行），那只能用Tornado进行开发。  Workbench的当前应用状况    项目 Tornado Workbench     工程管理 基本的工程管理功能，对分级的工程支持有限，并需要手工修改makefile等，比较麻烦 支持任意工程的分级控制，采用简单的“拖拉”方式就可完成工程项目的分级构造，非常方便   工程项目 支持可下载的工程项目和客户化的VxWorks工程项目 增加了对系统引导工程项目、实时进程工程项目、文件系统工程项目、用户定制工程项目等的支持   编辑器 功能比较简单，只能完成一般的编辑功能 具有语法分析功能，可以进行语法着色显示、符号定义查找、符号补全、函数参数提示等功能，具有强大的符号查找和浏览能力   断点设置 支持任务级断点和全局断点 增加支持对处理器硬件断点等的支持，并且对各种断点还提供多种控制手段   仿真环境 基本的VxWorks仿真环境，可以操作主机系统中的文件和网络访问 增强了仿真环境中的复杂组网功能，提供了调用主机系统API的能力，并可模拟中断信号的产生   目标连接 支持网络、串口等连接方式 增加了对硬件仿真器的连接   下载的代码量 下载的目标代码一般在10MByte之内，超过10MByte会出现下载速度慢，系统不稳定的问题 设计能力为可下载750MByte的目标代码，充分满足开发和调试需要   目标操作系统 只支持VxWorks操作系统 增加了对Linux操作系统的支持，并且还可以扩展到其它目标操作系统   目标系统数目 单一的目标系统，同一个开发环境中同时只能建立一个连接，调试一种类型的单板 可以同时进行多目标板、多CPU体系结构的调试   多任务调试 不支持，每次只能挂接一个任务，或者进行系统级调试 支持，同时可挂接目标系统的多个任务或进程进行调试   第三方工具 结构比较封闭，集成第三方工具比较困难 采用Eclipse的开放架构，第三方工具容易集成，且资源丰富    如上所述，Workbench无疑是当前嵌入式软件开发领域中功能非常强大的一个集成开发环境，它最适合应用于复杂系统的开发或多个开发团队的合作开发，比如一个复杂的系统需要用到多种CPU或多种目标操作系统，或者应用软件本身非常复杂，具有多个任务，并且相互之间关联紧密，或者多个项目组之间需要进行协同开发和软件模块共享，或者企业涉及到了从硬件开发，到软件开发，再到生产测试的全过程。在这些情况下，考虑使用Workbench平台则非常合适，因为这样不仅能快速有效地进行系统开发，并且能够有效地进行项目的组织和管理，最终从整体上降低企业的成本。
]]></content>
  </entry>
  
  <entry>
    <title>风河支持沃达丰开创O-RAN未来</title>
    <url>/post/news/wind-river-help-vodafone-for-O-RAN.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>WindRiver</tag>
      <tag>Vodafone</tag>
      <tag>5G</tag>
      <tag>O-RAN</tag>
    </tags>
    <content type="html"><![CDATA[作为全球领先的智能边缘软件提供商，风河公司正在大力推进关键任务系统的数字化转型，同时把新型智能机器经济提升到更高的水平。
在当今世界，电信业支持着无数企业去适应快速变化的未来，因此它也是风河公司最为关注的市场之一。
风河公司总裁兼首席执行官Kevin Dallas指出：“我们在不断地优化战略，服务于未来运营管理。”
他表示，10年前，网络和电信业都是采用定制的设备和专用硬件来实现不同的网络功能。但现在整个行业都在转向基于软件的模式。
Dallas解释说：“有了5G和虚拟无线接入网络(RAN)，就为自动驾驶汽车、无人机和基于软件的工厂自动化等应用奠定了基础。展望更长远的未来，服务提供商将提供从核心到边缘的完全虚拟化环境，而且建立在面向云的架构上，采用自动化的管理方式。”
在电信业，风河公司专注的重要业务之一就是推动Open RAN (O-RAN)的发展。这是构建移动网络的一种新方法。传统的RAN解决方案要求电信运营商与单一供应商合作，这种方法不利于规模较小的供应商，因为它们缺乏建立和管理RAN解决方案的巨大财力，而风河的解决方案打破了这种局限。
风河公司正在全面拥抱O-RAN，加深与电信企业的合作。沃达丰等电信巨头均已选用风河的产品与技术，用于5G的生产部署，这是基于风河对O-RAN的贡献，包括对关键性开源技术的贡献。
Dallas介绍说：“我们很高兴被沃达丰选中，支持其建造欧洲首个商业O-RAN，这将是世界上最大的O-RAN之一。”沃达丰公司则认为，此举将有助更多大规模Open-RAN开通，并引领整个欧洲的新一轮数字化转型。
O-RAN是众多行业企业为其客户提供大量新服务的关键性助推剂。这也是边缘网络和机器经济的推动力，并为自动驾驶、现代化能源电网、自动自主机器人等应用奠定了基础。但是，新技术在带来机遇的同时也带来挑战，其中大多数挑战与系统集成有关。沃达丰最近发布了一份关于O-RAN系统集成挑战的白皮书，呼吁生态系统提供商更早地启动集成。
Dallas补充说：“生态系统中的多个供应商需要深入合作，而不是从传统供应商那里购买单台设备。风河一直在与戴尔、三星、NEC和沃达丰保持合作推出解决方案，力求简化这种集成的流程。”
以风河与戴尔的合作为例，这两家公司通过降低5G部署的复杂度和成本，提升了电信云部署的水平。随着O-RAN技术的发展，风河开始发掘其对电信业以外其他行业企业的价值。
行业数据显示，到2026年将有70%的计算量将转移到边缘，因此边缘计算需求将以令人无法置信的速度增长。运营系统正在进入超级互联时代，从而与过去完全不可同日而语。这意味着服务提供商可以围绕网络互连性来创造价值，特别是在车对车、车对基础设施、无人机配送系统和远程医疗等应用领域。
最后，Dallas表示：“分布式网络是十分复杂的，因此Open RAN解决方案必须有能力降低复杂度。风河公司的重点是提供易于部署、提高自动化水平和运营效率”。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks Workbench开发环境快速介绍</title>
    <url>/post/app/a-quick-intro-to-vxworks-workbench-development-environment.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Workbench</tag>
    </tags>
    <content type="html"><![CDATA[本文介绍了VxWorks Workbench开发环境相关的快速教程
启动Wind River Workbench 可以按照如下步骤来启动Wind River Workbench IDE(Integrated Develoment Environment)，从菜单选择，Applications men -&gt; Development -&gt; Wind River Workbenche， 或者从命令行运行/opt/WindRiver/workbench-4/startWorkbench.sh，下面的窗口将会询问并让我们选择工作空间workspace。
这儿的Workspace是你的项目存放的地方，建议将workspace放置到你的Home目录下(/home.nfs/)。
创建新项目 为了创建一个新的项目，可以依次选择File -&gt; New -&gt; Project，并选择 VxWorks -&gt; VxWorks Downloadable Kernel Module Project。(后面你也会和Real-Time Process Projects打交道)，一个对话窗口将会打开，你可以指定一个项目名称，可选地，你可以改变项目的保存目录，继续点击Next按钮。
在下一个窗口，选择我们项目基于的类型，因为我们将在模拟器中运行程序，选择image project和vip_vxsim_linux_llvm (prebuild)，然后点击Finish。
现在你可以在Project Explore选项卡下看到刚新建的项目，这个项目包含了一个简单的C语言模板dkm.c。
示例代码 用下面的代码代换dkm.c中的代码。
#include &lt;taskLib.h&gt;#include &lt;stdio.h&gt;#include &lt;kernelLib.h&gt; int task_run[] = {100, 450, 200}; int task_stop[] = {18, 25, 30}; void task(int n) { long int x; printf(&#34;Task %i has been started\n&#34;, n); while (1) { printf(&#34;task %d: running\n&#34;, n); x = 1000000 * task_run[n]; while (x &gt; 0) x--; printf(&#34;task %d: delayed\n&#34;, n); taskDelay(task_stop[n]); } } void CreateTasks(void) { TASK_ID id1, id2, id3; /* kernelTimeSlice(1); */ cpuset_t affinity; CPUSET_ZERO(affinity); CPUSET_SET(affinity, 0); taskCpuAffinitySet(taskIdSelf(), affinity); id1 = taskSpawn(&#34;Task0&#34;, 210, 0, 4096, (FUNCPTR) task, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); id2 = taskSpawn(&#34;Task1&#34;, 210, 0, 4096, (FUNCPTR) task, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0); id3 = taskSpawn(&#34;Task2&#34;, 210, 0, 4096, (FUNCPTR) task, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0); } 编译应用程序 就像很多现代IDE一样，通过一个单一的点击动作就可实现编译和运行一个应用程序，但是，理解这个场景背后究竟发生什么也是非常有帮助的。我们将会看看运行一个VxWorks应用程序所需要的每一个步骤，然后我们将会展示如何通过一个点击动作来实现。
编译一个项目，右键点击测试项目名称并选择Build（或者按Ctrl + B，或者按Ctrl + P）。
第一次编译的时候会询问头文件搜索的目录，这儿，你可以点击Continue继续。
编译的控制台将会自动打开并显示编译过程的输出内容。
如果你看到编译结束(Build Finished)的黑体字，表示编译是成功的，否则，你需要修正报告的错误(和警告)。
启动模拟器 因为我们将要在模拟器中运行程序，我们必须要先设置，从Workbench的工具栏，从下拉列表中选择New Connection
在这个新连接的对话框中，输入一个Connection Name并选择:
 Target Type: VxWorks Simulator Connection Mode: Application Mode  选择Finished，然后模拟器就会启动，两个选项卡将会打开：
 Simulator选项卡将会显示Connection details Terminal选项卡将会显示模拟系统的控制台  尝试在控制台里的VxWorks控制台提示行输入命令i:
这个命令将会系统里面正在运行的所有任务。
相似的信息也可以从系统监控(System Monitor)选项卡中获取。
运行应用程序 现在通过右键点击项目并选择Run/Debug Kernel Task来运行程序
在Run Kernel Task对话框中，指定Entry Point，就是将要运行的函数的名称，输入CreateTasks或者通过Browse...按钮来选择。
从可用的entry points中选择CreateTasks。
在按了OK按钮后，应用程序将会在模拟器中运行并且输出内容将会在Terminal选项卡中显示出来。
如果你想再次运行程序程序，按组合建Ctrl + Shift + F11就足够了，或者从Target actions菜单中选择Run Kernel Task
终止程序 有多种方法来终止应用程序:
 点击红色的图标来停止整个模拟器 从System Monitor选项卡，通过右键菜单点击单个应用任务来终止它  调试 你可以在运行某个应用程序的时候，通过选择Attach Debugger选项来调试一个应用程序。
Workbench会在entry point或者任何其他手动添加的断点处停止应用程序，现在你可以像别的IDE一样step并调试代码。
帮助和文档 有两种类型的文档是可用的：
 参考手册 指南，教程  指南文档在/opt/WindRiver/vxworks/22.06/docs目录下，对大家来说最重要的文档将是Kernel_Application_Development/VxWorks_Application_Programmer_s_Guide_22.06.pdf
参考手册可以在IDE自身的环境中获得，Help-&gt;Show Context Help，帮助窗口将会在编辑器里面鼠标的位置显示文档的链接。
系统Viewer 系统Viewer是你可以记录系统活动的轨迹然后通过图形的方式进行显示的工具。
系统Viewer可以被配置来记录不同数量的信息，我们将通过选择Additional Instrumentation来选择中等数量，如下所述。
下面你就可以开始从运行的系统中记录运行轨迹。
记录停止后，带有记录数据的新窗口将会出现。
你也可以从view隐藏任何任务。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks环境搭建与学习</title>
    <url>/post/bsp/how-to-setup-vxworks-development-environment.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Workbench</tag>
    </tags>
    <content type="html"><![CDATA[本文讲述了如何搭建VxWorks开发环境，对于学习VxWorks的网友来说是一篇比较好的入门文档。
嵌入式操作系统VxWorks简介  VxWorks  操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），是嵌入式开发环境的关键组成部分。良好的持续能力、高性能的内核以及友好的用户开发环境，在嵌入式实时操作系统领域占据一席之地。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的F-16、FA-18战斗机、B-2隐形轰炸机和爱国者导弹上，甚至连1997年在火星表面登陆的火星探测器上也使用到了VxWorks。
Workbench 由WindRiver提供的开发工具，集成了编辑器、编译器、调试器于一体的高度集成的窗口环境，同样也可以从Shell窗口下发命令和浏览。基于eclipse。
集成环境提供了高效明晰的图形化的实时应用开发平台，它包括一套完整的面向嵌入式系统的开发和调测工具。此环境采用主机－目标机交叉开发模型，应用程序在主机的Windows环境下编译链接生成可执行文件，下载到目标机，通过主机上的目标服务器（Target Server）与目标机上的目标代理（Target Agent）的通信完成对应用程序的调试、分析。它主要由以下几部分组成：
VxWorks高性能的实时操作系统；
 应用编译工具； 交互开发工具；  BSP 板载支持包（Board support package,BSP），用于支持开发板相关的功能，包括BIOS驱动、CPU、网卡驱动、硬盘驱动、ROM驱动、Flash驱动、显卡驱动等等。VxWorks BSP  包含了开发人员要在特定的目标机上运行VxWorks所需要的一切支持：支持特定目标机的软件（如驱动程序等）和从主机通过网络引导VxWorks的Boot ROM。Wind River提供支持不同厂商的200多种商业体系结构和目标板的BSP。另外Wind River还提供一个BSP移植包，帮助用户移植VxWorks到客户化硬件板上（超过50%的VxWorks用户使用客户化目标机）。
BSP开发包帮助开发人员把VxWorks移植到客户化硬件平台上。BSP开发包的选项包括：测试工具，硬件设备的驱动程序库，BSP模板。用户可以根据需要选择不同的选项。Wind River还提供BSP测试验证等咨询服务。
VxVMI: VxVMI是VxWorks的虚拟内存接口。在调试阶段和软件运行时都能提供强大的内存管理功能。它包括代码段和数据段保护功能，并包含对不同CPU结构的标准编程接口。
VxMP: VxMP是VxWorks多处理器支持扩展包，它允许将任务分布在多个CPU上执行以提高效率。它透明的、高性能的设计使得在不同CPU上运行的任务可以通过现有的通信机制，如信号灯、消息队列等进行同步和数据交换。
BSP是介于底层硬件和上层软件之间的底层软件开发包，它主要功能为屏蔽硬件，提供操作系统的驱动及硬件驱动，具体功能包括：
 单板硬件初始化，主要是CPU的初始化，为整个软件系统提供底层硬件支持； 为操作系统提供设备驱动程序和系统中断服务程序； 定制操作系统的功能，为软件系统提供一个实时多任务的运行环境； 初始化操作系统，为操作系统的正常运行做好准备；  BSP文件在vxworks/target/config/all和vxworks/target/config/bspname文件夹里。其中，all文件夹里的文件是所有BSP的通用文件，bspname文件夹的文件是用户自己定制的BSP文件。
经过编译、链接，并在makefile和depend. bspname等文件的控制下，原程序最后将生成镜像。VxWorks的镜像可分为两类：可下载镜像和可引导镜像。
 可下载镜像(Loadable Image)：实际包括两部分，一是vxWorks，二是boot ROM，两部分是独立创建的。其中boot ROM包括被压缩的boot ROM镜像(bootrom)、非压缩的boot ROM镜像(bootrom_uncmp)和驻留ROM的boot ROM镜像(bootrom_res)三种类型； 可引导镜像(Bootable Image)：是将引导程序和vxWorks融为一体的镜像，它常常是最终产品，包括不驻留ROM的镜像和驻留ROM的镜像两种类型。  VxWorks虚拟机安装 安装版本：
VxWorks 6.8.3 + Workbench 3.2.3 + VMware 16 + MS-DOS 6.22 软盘版
按照FTP连接的主机和目标机，将整个VxWorks6.8的安装分为两个部分，一是在主机（win10系统，可以使用虚拟机或者实体机，推荐使用虚拟机）上安装workbench3.2，进行bootrom与VxWroks映像文件的生成，二是在虚拟机上安装VxWorks系统。
WorkBench3.2安装  以下操作在win10虚拟机上进行
 准备工作：
先关闭UAC。
在Windows中搜索UAC
搜索网络连接设置，选择其中的有线网卡（不能用也没关系，主要是有线网卡就可以）。右键点击属性菜单。
然后点击配置按钮，弹出配置界面，点击高级子界面
打开资源包中的WRSLicenseWH701-VX-2Hypervisor.lic文件，找到这里：
复制里面的hostid=字段的内容，16位MAC地址字符串。如果不是16位MAC地址而是字符串ANY，表示此证书并未绑定网卡MAC地址，不限制网卡。
填入如下位置：
开始安装：
 安装UItraISO（其他加载工具也可以）。运行uiso9_cn.exe，一路默认安装UItraISO，注意选择附加任务时三项都要勾选，尤其是“安装虚拟ISO驱动器”（默认三项都勾选）  加载DVD-R175636.1-1-00到虚拟光驱，接着打开所加载的虚拟光驱，运行setup程序；   安装过程没有特别描述的都以默认选项进行；
  这一步将Check都取消勾选
  这一步选择Permanent activation（永久激活），将所给的.lic文件（证书）导入  其余都用默认选项，选择Next即可，最后等待安装完成  编译BSP  找到WorkBench的安装目录，目录名为WindRiver，找到vxworks-6.8目录，进入找到target目录，进入找到config目录，进入找到pcPentium4目录  将“修改及增加文件”文件夹内提供的文件复制粘贴到Pentium4目录内，已有文件全部覆盖  需要修改以下文件，这里直接将修改好的复制过来。  打开config.h文件，定位到定义 DEFAULT_BOOT_LINE 宏的地方。修改预处理条件CPU == PENTIUM4 分支下的定义如下：  这里的h（host）地址表示你的主机IP地址，可以先修改为主机IP地址，或者随便填一个IP地址，之后修改主机地址为该地址，e（target）地址表示VxWorks系统目标机的IP地址，只需要和主机IP地址在同一个网段内即可，u=target pw=target是FTP下载的用户名和密码,都可以根据自己实际情况修改，最好使用target，简单易记。  打开Workbench3.2，Workspace就选择WindRiver目录下的workspace目录  File-&gt;New-&gt;Wind River Workbench Project，选择Wind River VxWorks 6.8，然后Next  Build type选择Boot Loader / BSP Project，然后Next  Project name任取，最好与BSP相关，Location选择默认的in workspace，然后Next  Board support package选择步骤2中经过修改的Pentium4目录，Tool chain选择gnu，勾上Copy files to project，然后Finish  右键选中项目，选择Build Project或者Rebuild Project进行构建  构建完成后，右键选中项目，选择Open Wind River VxWorks 6.8 Development Shell，打开命令行，cd进入Pentium4目录后，输入make bootrom.bin命令，将生成bootrom.bin文件  找到workspace目录，找到该项目目录，在项目目录下找到Pentium4目录，进入并找到生成的bootrom.bin，复制出来，并修改后缀名为.sys，后续该文件作为引导程序  找到vxload.com和vxsys.com两个文件（手动搜索，或者一般在XX\WindRiver\vxworks-6.8\host\x86-win32\bin目录下），与上一步得到的bootrom.sys放在一起，以待后续使用  生成VxWorks镜像 根据具体需要在命令行环境下利用Makefile创建各种镜像，也可以在Tornado的集成环境下Build菜单中选择Build Boot ROM来创建各种类型的Boot ROM；
除此以外，如果系统硬件包括串口，还要根据具体情况修改sysSerial.c文件；如果包含网络部分要修改configNet.h；如果包含NVRAM要修改bootnv.h文件。总之，BSP的开发要根据具体目标板的硬件进行。
1、打开Workbench3.2，Workspace就默认为WindRiver目录下的workspace目录
2、File-&gt;New-&gt;Other，在Wizards内输入VxWorks image查找并选择VxWorks Image Project，然后Next
3、Project name任取，最好与Image相关，Location选择默认项in workspace，然后Next
4、Based on选择an existing project，Project中将显示此时workspace中的项目，选择第2章节中创建好的BSP项目，然后Finish
5、如果需要额外开启各种服务，则需要在VxWorks Image的编译工程的Kernel Configuration中添加组件
选择所需要的服务，这里添加了telnet ftp rpc,然后点击finish
然后即可在Network Applications(default)模块下，看到对应的组件
还可以进行一些配置，例如TELNET组件：
6、组件添加完成后，右键选中项目，选择Build Project或者Rebuild Project构建
7、在workspace目录下，找到该项目目录，进行default目录，进入并找到生成的vxWorks以及vxWorks.sym，复制出来，后续这两个文件将作为VxWorks系统文件通过FTP引导系统
但是我这里并没有生成vxWorks.sym文件，不知道为什么&hellip;不过后面并没有影响
VxWorks虚拟机安装 1、首先使用DOS622镜像文件创建虚拟机，镜像文件格式为IMG，大小为1.44MB，软盘的大小。
2、使用VMware，新建虚拟机-&gt;典型-&gt;稍后安装操作系统-&gt;其他（MS-DOS）-&gt;自定义名称（默认为MS-DOS）和位置-&gt;使用默认最大磁盘大小2GB，将虚拟磁盘存储为单个文件-&gt;完成
3、打开上一步创建的虚拟机设置，在硬件部分“添加”“软盘驱动器”
4、软盘添加“完成”后，选择软盘，勾选“启动时连接”，以及“使用软盘映像文件”，并点击“浏览”选择提供的DOS662.img文件
5、选择CD/DVD，取消勾选“启动时连接”，修改内存大小为256MB（适当大小即可）
6、完成设置后，开启该虚拟机，进入开始界面，选择第三个选项Other IDE CD-ROM
7、选择3后进入真正的DOS界面，开始进行硬盘分区，输入fdisk
8、选择1，建立DOS分区
9、选择1，建立一个主分区
10、选择Y，此时询问这个分区是否使用全部的空间，由于我们只需要一个分区就可以，因此选择Y
11、输入任意键，虚拟机将重启
12、重新选择3 Other IDE CD-ROM，进行主分区的格式化，输入format c: /s ，这里输入Y确认
13、这里询问是否填写卷标，由于并不需要所以直接回车即可
14、此时已经有主分区C盘了，关闭虚拟机，在虚拟机设置中选择硬盘，选择“映射”，取消勾选“以只读模式打开文件”后确定，弹出警告点“是”即可，由此将打开该虚拟机的硬盘空间
之后，本地多出来个Z盘：
15、将&quot;编译BSP&quot;章节中的三个文件放入盘中后，在硬盘处“断开连接”，重新开启虚拟机，依然选择3
16、输入c：进入c盘（即主分区）
17、输入vxsys c: 命令，输入y确认
18、由此bootrom.sys成功设置为引导程序，关闭虚拟机，在虚拟机设置中选择软盘，取消勾选“启动时连接”，再次开启虚拟机，VxWroks系统虚拟机安装完成，其中IP地址为192.168.111.200，也就是所提供的config.h文件内设置的地址
19、移步到win10虚拟机，在C:\WindRiver\vxworks-6.8\host\x86-win32\bin下找到wftpd32.exe，使用该程序进行FTP的连接
20、在任意位置创建一个文件夹，用来给目标机提供FTP文件目录，方便起见，我们直接在桌面下创建一个名为ftp的文件夹，将之前得到的vxWorks，vxWorks.sym两个文件放入其中
 这里我只生成了vxWorks
 21、打开wftpd32.exe，Security-&gt;Users/Rights-&gt;New User-&gt;创建一个名为target，密码为target的用户（这个用户名密码是在config.h文件修改时设定好的）
22、用户创建好后选择该用户，在Home Directory内填入20步中创建的文件夹，然后选择“Done”
23、重启VxWorks虚拟机，此时虚拟机将通过FTP连接载入VxWroks系统，完成
这里我们在”生成VxWorks镜像“章节，并没有生成vxWorks.sym文件，但是依然可以搭建成功。
24、由于前面我们配置了RPC、TELNET、FTP组件，所以扫描可以看到对应的开放端口
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks操作系统下的USB摄像头驱动总结</title>
    <url>/post/bsp/vxworks-device-driver-for-usb-camera.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>usb</tag>
      <tag>Camera</tag>
    </tags>
    <content type="html"><![CDATA[本文分享了VxWorks下USB摄像头驱动总结
VxWorks驱动开发步骤： 声明设备struct，必须包含DEV_HDR，例如：
typedef struct { DEV_HDR myDevHdr; BOOL bIsAvailable; int iUserCount; char *pBuf[]; } MY_DEV; 定义全局变量int myDrvNum; /* 设备号 */
MY_DEV myDev; 声明设备操作函数（创建、打开、读/写等）;
声明中断处理函数；
myDrvNum = iosDrvInstall(myDevCreate, myDevRemove, myDevOpen, myDevClose, myDevRead, myDevWrite, myDevIoctl); /* 创建驱动 */ intConnect(intvec, myIntHandler, 0); /* 连接中断 */ status = iosDevAdd(&amp;myDev, &#34;my device&#34;, myDrvNum); /* 创建设备描述符结构 */ /* 完成相关函数 */
VxWorsk下USB协议栈 (USBD Client Module)&lt;-&gt;(USB Host Driver)&lt;-&gt;(USB Host Controller Driver)&lt;-&gt;(USB Host Controller)，共四层。
最下层是硬件，有两种主机控制器，OHCI（微软）和UHCI（Intel），相应的驱动分别在usbHcdOhciLib.c和usbHcdUhciLib.c中定义。
USB Host Driver（USBD）是客户驱动和HCD之间的中介，接受客户发送来命令，发送给HCD，HCD在驱动硬件接受。
数据发送路线及格式：客户驱动(USB_IRP包)-&gt;USBD(URB包)-&gt;HCD(HRB包)。
USBD入口函数usbdCoreEntry(pURB_HEADER pUrb)，所有请求函数都先进入此函数，根据pUrb-&gt;function的值调用相应函数。
一个用户设置interface例子：
(用户)usbdInterfaceSet()-&gt;(USBD)生成URB_INTERFACE_GET_SET结构的变量Urb，结构中第一个变量是URB_HEADER， 调用urbExecBlock(&amp;Urb.header)-&gt;usbdCoreEntry(pUrb)-&gt;(USBD)由于pUrb-&gt;function=USBD_FNC_INTERFACE_SET，调用fncInterfaceSet(pUrb)-&gt; (USBD)调用controlRequest()-&gt; (USBD)生成USB_IRP，USB_SETUP包，调用usbdTransfer()-&gt; (USBD)生成URB_TRANSFER结构的变量Urb，调用urbExecBlock(&amp;Urb.header)-&gt;usbdCoreEntry(pUrb)-&gt; (USBD)由于pUrb-&gt;function=USBD_FNC_TRANSFER，调用fncTransfer()-&gt; (USBD)生成USB_IRP包，调用usbHcdIrpSubmit()-&gt; (HCD)生成HRB_IRP_SUBMIT结构hrb，结构中第一个变量是HRB_HEADER，执行(*pNexus-&gt;hcdExecFunc) ((pVOID) &amp;hrb); 这里HCD中也只有一个入口函数，在HCD注册时提供给系统，这里也就是hcdExecFunc所指向的函数。根据HCD类型选择注册usbHcdOhciExec()或者usbHcdUhciExec()，这两个函数都接 受HRB数据，根据pHrb-&gt;function类型进行不同的处理。
上面例子中(*pNexus-&gt;hcdExecFunc) ((pVOID) &amp;hrb);（在jx2410开发板采用ohciHCD）相当于执行usbHcdOhciExex((pVOID)&amp;hrb)-&gt; (HCD)由于hrb-&gt;function=HCD_FNC_IRP_SUBMIT，调用fncIrpSubmit()-&gt; (HCD)在fncIrpSubmit里真正完成数据传送，步骤包括：（根据数据块个数）USER_FLUSH();
if (pPipe-&gt;busAddress == pHost-&gt;rootAddress) rootIrpHandler() ; else busIrpHandler(); setIrpResult(); 应用程序的关键在于发送合适的USB_IRP包，完成控制USB设备，获取数据的功能。
VxWorks下USB驱动编写流程 生成bootable工程，添加以下组件：
hardware-&gt;buses-&gt;USB Hosts-&gt;OHCI hardware-&gt;buses-&gt;USB Hosts-&gt;USB Host Stack hardware-&gt;buses-&gt;USB Hosts-&gt;USB Host Init-&gt;OHCI Init hardware-&gt;buses-&gt;USB Hosts-&gt;USB Host Init-&gt;USB Host Stack Init 此时编译后的内核在启动时如果出现Attach OHCI&hellip;OK，表示USB协议栈加载成功。
usbdInitialize(); /* USBD初始化 */ usbdClientRegister(); /* 注册驱动程序 */ usbdDynamicAttachRegister(); /* 为驱动程序注册感兴趣的设备 */ 本例中USB摄像头类型号分别为：DeviceClass是0xff，DeviceSubClass是0x00，DeviceProtocol不限。
完成以下函数：
usbOv511Probe(); /* 当摄像头动态插入时调用；功能：加载驱动，完成设备初始化 / usbOv511Config(); / 摄像头初始化 */
USB设备  物理特征：4条电缆，电源线、地线、数据线、脉冲线。 速度：低速1.5Mbps，全速12Mbps，高速480Mbps。 规范版本：1998年USB1.1，2000年USB2.0。 连接：PCI总线&lt;-&gt;USB控制器(OHCI或UHCI)&lt;-&gt;USB设备。 单个USB控制器最大连接个数：127。 距离限制：USB单条线缆长度不能超过5m，通过hub可延长至30m。 重要概念：主机-USB设备采用master-slave方式分工，所有通信都是主机发起的；在某一时刻，只有一个设备与主机通信。  一个USB物理设备可以抽象为一个或多个逻辑设备。
USB逻辑设备层次：逻辑设备-&gt;配置（configuration）-&gt;接口（interface）-&gt;端点（endpoint），端点是一个地址标实，是驱动和设备数据交换的一个终点，类似于网络编程中的客户短套接字或者服务器端套接字。
一个从驱动到设备的数据传输管道包括以下几个要素：
 设备的端点（通过读取/设置配置、接口得到）； 设备号（设备动态插入后由USBD分配）； 传输方向（从设备到主机、或从主机到设备）； 带宽要求； 延迟要求。  主机与USB间有4种传输方式：控制（小批量数据、保证到达）、同步（大批量数据、定时传输、不能保证到达）、批量（大批量数据、保证到达）、中断（小批量数据、不定时产 生、保证到达）。控制用于读取/设置USB设备，所有USB设备的端口0默认（或者说强制）给控制管道使用；同步主要用时视频设备如摄像头定时产生的批量数据，允许在带宽不足的情况下丢弃部分 数据包；批量用于一次性的大批量数据传输；中断用于异步数据入键盘（或鼠标）按下事件发生等。
系统为不同传输类型分配不同的可使用带宽。因此，控制管道必须占有10%的可用带宽，而批量管道不能达到USB的理想速率，实际中USB设备与主机的传输速率比理想速率低很多。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks6.6下基于VxBus的以太网驱动开发</title>
    <url>/post/bsp/network-device-driver-design-based-on-vxbus.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>vxbus</tag>
      <tag>network</tag>
      <tag>device driver</tag>
    </tags>
    <content type="html"><![CDATA[最近更换mpc8313的phy芯片，由原来的lxt972Phy更换为DP83849I，在此记录下本人在驱动开发过程中的点滴记录，以备日后查询。
基于vxbus的网络驱动，vxBus驱动的注册遵循一致的方法，驱动接口为：
device_method_t dp83849PhyMethods[] = { DEVMETHOD(miiModeGet, dp83849PhyModeGet), DEVMETHOD(miiModeSet, dp83849PhyModeSet), DEVMETHOD(vxbDrvUnlink, dp83849PhyInstUnlink), { 0, 0 } }; struct drvBusFuncs dp83849PhyFuncs = { dp83849PhyDevInstInit, /* devInstanceInit */ dp83849PhyDevInstInit2, /* devInstanceInit2 */ dp83849PhyDevInstConnect /* devInstanceConnect */ }; struct vxbDevRegInfo dp83849PhyDevRegistration = { NULL, /* pNext */ VXB_DEVID_DEVICE, /* devID */ VXB_BUSID_MII, /* busID = MII Bus */ VXBUS_VERSION_3, /* busVer */ &#34;dp83849Phy&#34;, /* drvName */ &amp;dp83849PhyFuncs, /* pDrvBusFuncs */ dp83849PhyMethods, /* pMethods */ dp83849PhyProbe /* devProbe */ }; void dp83849PhyRegister(void) { vxbDevRegister (&amp;dp83849PhyDevRegistration); return; } 要编写驱动，主要去实现上面模块中的相关功能，首先编写dp83849PhyProbe，在函数中识别flash的ID，编写其他相关的函数，接下来在sysLib.c中注册系统驱动
#include &#34;Dp83849Phy.c&#34;void sysHwInit (void) { dp83849PhyRegister(); } 接下来，在系统硬件配置hwconf.c中更改phyAddr地址,具体地址参照phy芯片硬件设计
const struct hcfResource motEtsecHEnd0Resources[] = { { &#34;regBase&#34;, HCF_RES_INT, { (void *)(CCSBAR + 0x24000) } }, { &#34;intr0&#34;, HCF_RES_INT, { (void *)INUM_TSEC1_TX} }, { &#34;intr0Level&#34;, HCF_RES_INT, { (void *)INUM_TSEC1_TX } }, { &#34;intr1&#34;, HCF_RES_INT, { (void *)INUM_TSEC1_RX } }, { &#34;intr1Level&#34;, HCF_RES_INT, { (void *)INUM_TSEC1_RX } }, { &#34;intr2&#34;, HCF_RES_INT, { (void *)INUM_TSEC1_ERR } }, { &#34;intr2Level&#34;, HCF_RES_INT, { (void *)INUM_TSEC1_ERR } }, { &#34;phyAddr&#34;, HCF_RES_INT, { (void *)14 }}, { &#34;miiIfName&#34;, HCF_RES_STRING, { (void *)&#34;tsecMdio&#34; } }, { &#34;miiIfUnit&#34;, HCF_RES_INT, { (void *)0 } } }; 接下来，由于本次硬件设计采用RMII接口，所以在config.h中更改硬件配置字
/* RMII */ #define HRCW_HIGH_BYTE2 0x24 接下来更改系统MAC寄存器，在vxbEtsecEnd.c中修改下列函数，根据系统硬件配置字设置ETSEC_ECNTRL寄存器的ETSEC_ECNTRL_R100M
LOCAL STATUS etsecLinkUpdate ( VXB_DEVICE_ID pDev ) { switch (IFM_SUBTYPE(pDrvCtrl-&gt;etsecCurMedia)) { case IFM_1000_T: case IFM_1000_SX: CSR_SETBIT_4(pDev, ETSEC_MACCFG2, ETSEC_IFMODE_GMII_TBI); /* R100M is &#34;don&#39;t care&#34; for gigE, but clear it anyway */ CSR_CLRBIT_4(pDev, ETSEC_ECNTRL, ETSEC_ECNTRL_R100M); pDrvCtrl-&gt;etsecEndObj.mib2Tbl.ifSpeed = 1000000000; break; case IFM_100_TX: CSR_SETBIT_4(pDev, ETSEC_MACCFG2, ETSEC_IFMODE_MII); //CSR_SETBIT_4(pDev, ETSEC_MACCFG2, ETSEC_MACCFG2_PREAMBLE_LEN | ETSEC_IFMODE_MII | ETSEC_MACCFG2_PADCRC | ETSEC_MACCFG2_FULL_DUPLEX);  /* Set R100M bit if configured for reduced pin mode RMII */ if (CSR_READ_4(pDev, ETSEC_ECNTRL) &amp; ETSEC_ECNTRL_RMM) CSR_SETBIT_4(pDev, ETSEC_ECNTRL, ETSEC_ECNTRL_R100M); //printf(&#34;100M ccfg2 = %08x ecntrl = %08x\n&#34;, CSR_READ_4(pDev, ETSEC_MACCFG2), CSR_READ_4(pDev, ETSEC_ECNTRL));  pDrvCtrl-&gt;etsecEndObj.mib2Tbl.ifSpeed = 100000000; break; case IFM_10_T: CSR_SETBIT_4(pDev, ETSEC_MACCFG2, ETSEC_IFMODE_MII); //CSR_SETBIT_4(pDev, ETSEC_MACCFG2, ETSEC_MACCFG2_PREAMBLE_LEN | ETSEC_IFMODE_MII | ETSEC_MACCFG2_PADCRC | ETSEC_MACCFG2_FULL_DUPLEX);  /* The R100M bit is always 0 for 10Mbps operation. */ if(CSR_READ_4(pDev, ETSEC_ECNTRL) &amp; ETSEC_ECNTRL_RMM) CSR_CLRBIT_4(pDev, ETSEC_ECNTRL, ETSEC_ECNTRL_R100M); //printf(&#34;10M ccfg2 = %08x ecntrl = %08x\n&#34;, CSR_READ_4(pDev, ETSEC_MACCFG2), CSR_READ_4(pDev, ETSEC_ECNTRL));  pDrvCtrl-&gt;etsecEndObj.mib2Tbl.ifSpeed = 10000000; break; default: break; } } 值此基本上已经完成驱动程序的修改，由于网络不通，无法加载系统镜像，无法调试，本人的解决办法是，先把vxWorks.bin通过仿真器烧写到flash固定位置，boot上电运行时，再从flash加载到RAM_LOW_ADDR地址处开始运行，这样在网络不通的情况下，可以加载系统镜像进行调试，所以修改bootsehll.c程序,并在autoboot函数中调用：
/* 启动时从norflash中拷贝系统镜像到VXWORKS启动地址，然后转到此处执行zhb_2020.12.23 */ void copyVxToRam(void) { char *pVxRamAddr = RAM_LOW_ADRS; char* pVxFlashAddr = FLASH_BASE_ADRS + 0x400000; int i = 0; int* pEnterAddr; FUNCPTR absEntry; for (i = 0; i &lt; 0x300000; i++) pVxRamAddr[i] = pVxFlashAddr[i]; pEnterAddr = (int*)pVxRamAddr; printf(&#34;start Vxworks at %08x.....\n&#34;, pEnterAddr); absEntry = pEnterAddr; (absEntry)(); } 编译boot程序和系统镜像，用仿真器烧写到flash中运行，下面就可以进行调试了。对于phy芯片的调用，可以利用vxBusShow查看设备pDev,然后在shell中用MII_READ,MII_WRITE进行测试
-&gt; vxBusShow Registered Bus Types: MII_Bus @ 0x00208d60 Local_Bus @ 0x00206138 Registered Device Drivers: ppcIntCtlr at 0x00207904 on bus Local_Bus, funcs @ 0x002078f8 VxBus version 2 quiccIntCtlr at 0x00208a2c on bus Local_Bus, funcs @ 0x002089f8 quiccTimerDev at 0x002068ec on bus Local_Bus, funcs @ 0x002068d0 VxBus version 2 motetsec at 0x002026b0 on bus Local_Bus, funcs @ 0x00202584 ns16550 at 0x0020734c on bus Local_Bus, funcs @ 0x002072dc ns16550 at 0x00207304 on bus PCI_Bus, funcs @ 0x002072dc ppcDecTimerDev at 0x00208f00 on bus Local_Bus, funcs @ 0x00208ee4 tsecMdio at 0x00208ea4 on bus Local_Bus, funcs @ 0x00208e78 mv88E1x11Phy at 0x00208e38 on bus MII_Bus, funcs @ 0x00208e08 lxt972Phy at 0x00207250 on bus MII_Bus, funcs @ 0x00207244 bcm54xxPhy at 0x00208da8 on bus MII_Bus, funcs @ 0x00208d9c miiBus at 0x00208d18 on bus PCI_Bus, funcs @ 0x00208cbc miiBus at 0x00208cd8 on bus Local_Bus, funcs @ 0x00208cbc plbCtlr at 0x00206160 on bus Local_Bus, funcs @ 0x00206154 dp83849Phy at 0x00202544 on bus MII_Bus, funcs @ 0x00202538 Busses and Devices Present: Local_Bus @ 0x0023f848 with bridge @ 0x002061a0 Device Instances: quiccIntCtlr unit 0 on Local_Bus @ 0x00240808 with busInfo 0x00000000 ppcIntCtlr unit 0 on Local_Bus @ 0x00240908 with busInfo 0x00000000 tsecMdio unit 0 on Local_Bus @ 0x00240a08 with busInfo 0x00000000 motetsec unit 0 on Local_Bus @ 0x00240b08 with busInfo 0x00000000 motetsec unit 1 on Local_Bus @ 0x00240c08 with busInfo 0x00000000 ppcDecTimerDev unit 0 on Local_Bus @ 0x00240d08 with busInfo 0x00000000 quiccTimerDev unit 0 on Local_Bus @ 0x00240e08 with busInfo 0x00000000 quiccTimerDev unit 1 on Local_Bus @ 0x00240f08 with busInfo 0x00000000 ns16550 unit 0 on Local_Bus @ 0x00241008 with busInfo 0x00000000 ns16550 unit 1 on Local_Bus @ 0x00241208 with busInfo 0x00000000 miiBus unit 0 on Local_Bus @ 0x00241708 with busInfo 0x0023ff08 miiBus unit 1 on Local_Bus @ 0x00245b08 with busInfo 0x0023ff48 Orphan Devices: legacy unit 0 on Local_Bus @ 0x00241408 with busInfo 0x00000000 MII_Bus @ 0x0023ff08 with bridge @ 0x00241708 Device Instances: dp83849Phy unit 0 on MII_Bus @ 0x00245908 with busInfo 0x00000000 Orphan Devices: MII_Bus @ 0x0023ff48 with bridge @ 0x00245b08 Device Instances: dp83849Phy unit 1 on MII_Bus @ 0x00245d08 with busInfo 0x00000000 Orphan Devices: value = 1 = 0x1 对于以太网报文的测试，我们可以增加测试程序，从中断中捕获报文分析，测试以太网发送报文
LOCAL int etsecEndEncap ( ETSEC_DRV_CTRL * pDrvCtrl, M_BLK_ID pMblk ) { ETSEC_DESC * pDesc = NULL, * pFirst; ETSEC_TX_FCB * pFcb; M_BLK_ID pCurr, pStart; UINT32 firstIdx, lastIdx = 0; struct ether_header * eh; int used = 0, i; int j = 0; // printf(&#34;send net data ......\n&#34;);  //for (j = 0; j &lt; pMblk-&gt;mBlkHdr.mLen; j++)  // printf(&#34;%02x &#34;, pMblk-&gt;mBlkHdr.mData[j]);  // printf(&#34;\n&#34;); } 测试以太网接收报文
void usrPrintNet(ST_INT port, ST_VOID* pM) { char gsBuf[L2_DATA_MSG_SIZE]; int i = 0; M_BLK_ID pMblk = (M_BLK_ID)pM; memcpy(gsBuf, pMblk-&gt;mBlkHdr.mData, pMblk-&gt;mBlkHdr.mLen); if (g_debug_net == 1) { printf(&#34;revCnt = %d\n&#34;, gsvEthInfo[port].allPacketCount); for (i = 0; i &lt; pMblk-&gt;mBlkHdr.mLen; i++) printf(&#34;%02x &#34;, gsBuf[i]); printf(&#34;\n&#34;); } } LOCAL void etsecEndRxHandle ( void * pArg ) { usrPrintNet(pDrvCtrl-&gt;etsecDev-&gt;unitNumber,pMblk); } 注意：如果你的驱动程序在boot和系统镜像中存在两份，务必保持驱动程序的一致性，否则可能出现奇怪的现象，调试中发现以太网发送中断不能进，最后发现是boot和vxWorks中的驱动程序不一致导致的，折腾了两天。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks下多任务调试</title>
    <url>/post/app/vxworks-multiple-tasks-debug.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Multiple Task</tag>
    </tags>
    <content type="html"><![CDATA[在任务运行过程中,会出现一些异常的情况,导致任务不能正常运行或者对操作系统造成影响。
VxWorks任务编程中常见异常分析 在任务运行过程中,会出现一些异常的情况,导致任务不能正常运行或者对操作系统造成影响。一般来说,这些异常是由程序的逻辑错误造成的,防止这些异常情况的出现和出现后进行补救就有格外重要的意义。
代码重入与共享 在应用中,可能会出现多个任务调用同一段代码的情况,由于任务占用CPU是串行的,不会出现代码资源使用冲突。但是,不同优先级的任务同时调用同一段代码,则可能出现低优先级任务执行某一函数时被执行该函数的高优先级任务打断的情况,如果函数中要改写全局变量而没有使用互斥,就有可能导致错误的存取。例如在中断中调用内存分配或者释放函数,如果某个任务正在调用内存分配函数或者是内存释放函数,打断该任务时会造成异常,可能导致内存泄漏,甚至有可能会因在中断中异常而reboot。另外,如果多个任务共用的代码中有全局变量且使用目的不同,或者多个任务的代码中有全局变量同名的情况,则有可能造成变量使用中的错误。VxWorks提供了任务变量（taskVar）的方法来解决这个问题,任务可以将使用的全局变量作为任务变量独立使用,添加的任务变量保存在任务的上下文中,任务切换时保存当前内容。
符号表的使用 VxWorks中有模块（module）的概念。装载模块完成目标代码文件在内存中的链接,并可以将目标代码文件中的函数与全局变量加入符号表。符号表中的符号对C语言编写的函数以原来名字命名,对于C++语言的函数则是在后面加上形参的数据类型作为符号名。如f1( )的符号名为f1__Fv,最后的v表示void类型;f2(int)符号名为f2__Fi,f3(int,int)为f3__Fii,依此类推。代码的编译过程中并不对要使用的函数和变量进行检查。例如调用一个并不存在的函数编译并不报错,编译器认为此函数可能在操作系统内核中或者已经下载的目标文件中,但在目标文件下载时会找不到要调用的函数。如果符号表中的符号出现了重名,譬如两次下载的目标文件中有函数重名,则要作散列处理,之后对该函数的调用是最后加入符号表的函数,而之前已经装载的模块则不会受到影响。如果应用程序中使用了与操作系统内核同名的符号,则对操作系统某些API函数的调用将会失败。
特殊的任务保护 在VxWorks中,当一个任务被删除,其它任务不会得到通知,而且由于任务间的独立性,每一个任务可以无限制地删除其它任务。在应用中,我们可能会把需要保护任务误删除。VxWorks提供的两个函数taskSafe()和taskUnsafe()将通知意外删除任务而引起的问题。当任务调用taskSafe()时,从调用的那一刻起,该任务就被保护起来而不会被其它任务删除。如果任务1试图删除已经调用taskSafe()的任务2,则任务1将被阻塞,直到任务2调用taskUnsafe()。保护只能由任务自己实现,一个任务不能safe或unsafe另外一个任务。taskSafe()和taskUnsafe()支持嵌套模式。如果有嵌套发生,一个计数器将开始工作,每有一个taskSafe()被调用,则计数器加1;调用1个taskUnsafe(),则计数器减1。只有当计数器为0时,才能删除该任务。
有时为了执行效率等原因,任务的运行需要禁止基于优先级的抢占,这可以通过调用taskLock()实现。如果任务1调用taskLock()禁止了高优先级任务对它的抢占,当任务1被阻塞或被暂停,核心将调度下一个具有最高优先级的就绪任务运行。如果这时任务1又就绪且被调度运行,抢占又被禁止。但是,禁止基于优先级的抢占可以阻止任务切换,却并不会屏蔽中断。调用taskUnLock()可以解除优先级抢占的禁止,通过调用taskLock()和taskUnLock()可以实现对临界资源的互斥访问。
任务调度中CPU的占用 如前所述,不同优先级的任务是通过抢占获得CPU使用权的,如果不选时间片轮转,相同优先级的任务之间也是抢占CPU的。任务就绪队列中正在运行的任务如果不主动放弃CPU,则其它同优先级的任务不会得到运行,这样就有可能看到几个同优先级的任务状态同为READY,但实际上只有一个任务在运行的现象。比如在一个任务中用taskSpawn()函数创建一个同优先级或低优先级的任务,如果原任务一直占用CPU,新任务就不会开始运行。调用函数taskDelay()可以使任务放弃CPU一定的时间,从而实现任务间时间上的同步;也可以放弃CPU零时间,将任务移至同优先级就绪队列的末尾,这样就可以实现多个同优先级的任务并发运行。另外,由于中断能够打断任务的运行,中断处理函数中执行的代码就要尽可能少地占用CPU,并且中断中不能有获取信号量的操作。一旦处于等待之中,所有的任务均得不到运行,用户可能会有CPU不响应的错觉。
堆栈越界 如前所述,每一个任务都有自己的堆栈,任务创建时进行初始化。每个堆栈的大小是固定,但是任务运行过程中并不对堆栈的使用进行限制。由于VxWorks不对内存访问作限制,栈顶超越了原定的值后出现越界,这样操作系统中该任务堆栈以外的内存区域就可能被改写,会造成难以预料的结果,甚至可能造成任务的上下文区域被改写而任务消失。造成越界的原因主要是在函数中定义了比较大的数组,以致进栈时越界。这样在编写程序时,就要求在堆栈许可的范围内定义数组。如果确实需要比较大的内存空间,可以使用操作系统的内存分配函数来获得内存。由于堆栈越界后有可能使任务的控制信息被破坏,使得对堆栈越界的检测比较困难,例如可以在栈底写入一串特殊字符,用另外一个任务或者中断服务程序经常来检查是否被改写来判断越界。
CPU异常 在VxWorks中,当任务的指令执行中出现了指令非法、地址寻址错误、总线错、除数为0等情况时,就会出现CPU异常。比较常见的情况是,指针地址非法或者数组下标越界就有可能存取有效地址空间以外的地址而造成CPU异常。VxWorks提供一个异常处理句柄（handler）和一个名为tExcTask的任务来处理异常。异常出现后任务成为挂起状态（suspend）,并且不能转变为其它状态。在VxWorks中,有一个异常向量表来对应各种异常,外部中断也作为一种特殊的异常。VxWorks的做法是把多种异常的处理映射到同一个异常处理函数进行处理,并且VxWorks提供了向这个异常处理函数中钩挂用户的异常处理函数的接口excHookAdd(),也可以将某一个异常向量映射到指定的处理函数。
任务调试模式下的多任务调试 在任务调试模式下，在一个集成环境中，在一个任务中调试，在另一个任务中设置断点，设置的断点不起作用。这是因为一个调试器只能处理一个TCB（任务控制块），每个任务都有一个TCB，因此一个调试器只能调试一个任务，要调试几个任务就要启动几个调试器。一个集成环境只能启动一个调试器，所以要调试几个任务就要启动几个集成环境。另外，需要在被调试的任务的待调试的第一条语句前加入taskSuspend(0)语句，挂起该任务，否则任务就可能会在调试前被执行。 下面是多任务调试的测试用例的源代码
/* VxWorks includes */ #include &#34;vxWorks.h&#34; #include &#34;taskLib.h&#34; #include &#34;stdio.h&#34; #include &#34;msgQLib.h&#34; int g_lTaskATid; int g_lTaskBTid; MSG_Q_ID g_MsgQ1id; MSG_Q_ID g_MsgQ2id; void MultiTaskTestTaskA(void) { char cMsgToTaskB[100]; char cMsgFromTaskB[100]; sprintf(cMsgToTaskB,&#34;To TaskB \n&#34;); printf(&#34; Hello from MultiTaskTestTaskA \n&#34;); /*start point of debugging for MultiTaskTestTaskA*/ taskSuspend(0); for(;;) { printf(&#34; Hello from MultiTaskTestTaskA \n&#34;); /*Send message to MultiTaskTestTaskB*/ msgQSend(g_MsgQ1id,cMsgToTaskB,sizeof(cMsgToTaskB),WAIT_FOREVER,MSG_PRI_NORMAL); /*Receive message from MultiTaskTestTaskB*/ msgQReceive(g_MsgQ2id,cMsgFromTaskB,100,WAIT_FOREVER); printf(&#34;%s&#34;,cMsgFromTaskB); } } void MultiTaskTestTaskB(void) { char cMsgToTaskA[100]; char cMsgFromTaskA[100]; sprintf(cMsgToTaskA,&#34;To TaskA \n&#34;); printf(&#34; Hello from MultiTaskTestTaskB \n&#34;); /*start point of debugging for MultiTaskTestTaskA*/ taskSuspend(0); for(;;) { printf(&#34; Hello from MultiTaskTestTaskB \n&#34;); /*Send message to MultiTaskTestTaskA*/ msgQSend(g_MsgQ2id,cMsgToTaskA,sizeof(cMsgToTaskA),WAIT_FOREVER,MSG_PRI_NORMAL); /*Receive message from MultiTaskTestTaskA*/ msgQReceive(g_MsgQ1id,cMsgFromTaskA,100,WAIT_FOREVER); printf(&#34;%s&#34;,cMsgFromTaskA); } } /*This function spawns MultiTaskTestTaskA and MultiTaskTestTaskB , creates g_MsgQ1id and g_MsgQ2id , is entry for debugging.*/ void MultiTaskTestInit(void) { printf(&#34; Hello from MultiTaskTestInit \n&#34;); g_MsgQ1id=msgQCreate(20,100,MSG_Q_FIFO); if(g_MsgQ1id==NULL) { printf(&#34; ERROR: create g_MsgQ1 error \n&#34;); } g_MsgQ2id=msgQCreate(20,100,MSG_Q_FIFO); if(g_MsgQ1id==NULL) { printf(&#34; ERROR: create g_MsgQ2 error \n&#34;); } printf(&#34; Spawning a new task called MultiTaskTestTaskA \n\n&#34;); g_lTaskATid = taskSpawn(&#34;MultiTaskTestTaskA&#34;,100,0,10000,(FUNCPTR)MultiTaskTestTaskA, 0,0,0,0,0,0,0,0,0,0); if(g_lTaskATid == ERROR) { printf(&#34; ERROR: task did not spawn \n&#34;); exit(1); } printf(&#34; Spawning a new task called MultiTaskTestTaskB\n&#34;); g_lTaskBTid = taskSpawn(&#34;MultiTaskTestTaskB&#34;, 100,0,10000,(FUNCPTR)MultiTaskTestTaskB, 0,0,0,0,0,0,0,0,0,0); if(g_lTaskBTid == ERROR) { printf(&#34; ERROR: task did not spawn \n&#34;); exit(1); } exit(0); } 多任务调试步骤：
 用-g选项编译源代码产生目标文件 下载产生的目标文件 在MultiTaskTestInit函数的开始设置断点 把MultiTaskTestInit设置为调试任务的人口函数 单步执行产生MultiTaskTestTaskA任务的语句后可以在串口（超级终端）上看到字符串Hello from MultiTaskTestTaskA，用Browser查看任务，可以看到任务MultiTaskTestTaskA出于挂起态（suspended），表明程序执行了taskSuspend(0)语句。 运行另一个Tornado集成环境 Attach任务MultiTaskTestTaskA， 在语句msgQReceive(g_MsgQ2id,cMsgFromTaskB,100,WAIT_FOREVER)的下一条语句处设置断点 运行任务MultiTaskTestTaskA。可以看到没有执行到断点处，用Browser查看任务状态，MultiTaskTestTaskA出于阻塞态（pended），因为它在等待消息。 单步执行MultiTaskTestInit到产生MultiTaskTestTaskB任务的下一条语句，可以看到MultiTaskTestTaskB任务处于挂起态 再运行另一个Tornado集成环境 Attach任务MultiTaskTestTaskB， 在语句msgQReceive(g_MsgQ1id,cMsgFromTaskA,100,WAIT_FOREVER)下一条语句处设置断点 运行任务MultiTaskTestTaskB。可以看到执行到断点处停下。这是因为MultiTaskTestTaskA任务已经发送一条消息到MultiTaskTestTaskB的接收队列中。 此时，可以看到MultiTaskTestTaskA任务也运行到断点处，因为为MultiTaskTestTaskB任务已经发送一条消息到MultiTaskTestTaskA的接收队列中。  系统调试模式下程序的调试 Tornado集成环境提供两种调试模式：任务调试模式和系统调试模式。在任务调试模式下，在一个集成环境下一个时间内只能调试一个任务。调试只影响当前被调试的任务，其它任务正常运行。在系统调试模式下，可以同时调试多个任务、中断服务程序（ISR），调试影响整个系统。
Tornado1.0集成环境下，在系统模式下进行程序调试，主机与目标机之间必须使用串口通信。Tornado2.0集成环境提供了通过网口进行系统模式调试的功能。
系统缺省使用网口通信，如果需要使用串口通信，需要修改文件C: \ Tornado \ target \ config
} all \ configAll.h的一些宏定义，修改为：
#define WDB_COMM_TYPE WDB_COMM_SERIAL /使用串口通信/ #define WDB_TTY_CHANNEL 0 /使用第一个串口/ #define WDB_TTY_BAUD 38400 /波特率：38400bps/ 重新编译链接vxWorks。 在启动目标服务器时，要选择串口通信，并进行相应配置。
系统调试模式下多任务的调试： 调试使用的源代码与任务调试模式中使用的代码相同。但是，需要去掉为了能够在任务调试模式下进行多任务调试的MultiTaskTestTaskA和MultiTaskTestTaskB中的语句taskSuspend(0);
多任务调试步骤：
 用-g选项编译源代码产生目标文件。 下载产生的目标文件。 在MultiTaskTestInit函数的开始设置断点。 在Debugger命令窗口输入命令attach system进入系统调试模式。 在Shell窗口输入命令sp MultiTaskTestInit产生一个以MultiTaskTestInit为入口函数的任务，因为整个系统都停下了，新产生的任务还没有执行，这可以通过在Debugger命令窗口输入命令info threads显示当前系统中的任务列表看出来。 执行菜单命令Debug | Continue继续运行程序。 系统在设置的断点处停下。 在函数MultiTaskTestTaskA中的语句msgQReceive(g_MsgQ2id,cMsgFromTaskB, 100,WAIT_FOREVER)的下一条语句处设置断点。 在函数MultiTaskTestTaskB中的语句msgQReceive(g_MsgQ1id,cMsgFromTaskA, 100,WAIT_FOREVER)的下一条语句处设置断点。 执行菜单命令Debug | Continue继续运行程序。 程序在任务MultiTaskTestTaskB中的断点处停下（为什么不是在任务MultiTaskTestTaskA中停下？请考虑）。 执行菜单命令Debug | Continue继续运行程序。 程序在任务MultiTaskTestTaskA中的断点处停下。 执行菜单命令Debug | Continue继续运行程序。 程序又一次在任务MultiTaskTestTaskA中的断点处停下（为什么停两次？请考虑）。 执行菜单命令Debug | Continue继续运行程序。 程序在任务MultiTaskTestTaskB中的断点处停下。  中断服务程序的调试 中断服务程序只能在系统调试模式下调试，不能在任务调试模式下调试。因为中断服务程序是作为系统的一部分运行，不是以任务方式运行，因此不需要为它产生任务。 中断服务程序调试步骤：
 用-g选项编译源代码产生目标文件。 下载产生的目标文件。 在MultiTaskTestInit函数的开始设置断点。 在Debugger命令窗口输入命令attach system进入系统调试模式。 执行菜单命令Debug | Continue继续运行程序。 如果产生相应的中断，程序就会在中断服务程序的断点处停下。进行需要的调试。 ]]></content>
  </entry>
  
  <entry>
    <title>VxWorks系统编程方法</title>
    <url>/post/app/vxworks-system-programming-method.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>System Programming</tag>
    </tags>
    <content type="html"><![CDATA[实时系统主要包括：多任务调度（采用优先级抢占方式），任务间的同步和进程间通信机制.
一个多任务环境允许实时应用程序以一套独立任务的方式构筑，每个任务拥有独立的执行线程和它自己的一套系统资源。进程间通信机制使得这些任务的行为同步、协调。 wind使用中断驱动和优先级的方式。它缩短了上下文转换的时间开销和中断的时延。在 VxWorks 中，任何例程都可以被启动为一个单独的任务，拥有它自己的上下文和堆栈。还有一些其它的任务机制可以使任务挂起、继续、删除、延时或改变优先级。
另一个重要内容是：硬件中断处理。硬件产生中断,通知系统调用相应的中断历程(ISR)，为使系统得到尽快的响应,ISR在它自己独立的上下文和堆栈中运行.它的优先级高于任何任务优先级.
中断延迟(Interrupt Latency) 中断延迟是指从硬件中断发生到开始执行中断处理程序第一条指令之间的这段时间。
优先级驱动(Priority-Driven) 优先级驱动是指多任务系统中，当前运行任务总是具有最高优先级的就绪任务。
多任务调度 两种方式: 优先抢占和轮转调度(Preemptive Priority,Round-Robin Scheduling).
优先抢占(Preemptive Priority): 每一个任务都有一个优先级，系统核心保证优先级最高的任务运行于CPU.如果有任务优先级高于当前的任务优先级,系统立刻保存当前任务的上下文,切换到优先级高的上下文.
抢占(Preemptive): 抢占是指当系统处于核心态运行时, 允许任务的重新调度。换句话说就是指正在执行的任务可以被打断，让另一个任务运行。抢占提高了应用对异步事件的响应性能力。操作系统内核可抢占，并不是说任务调度在任何时候都可以发生。例如当一个任务正在通过一个系统调用访问共享数据时，重新调度和中断都被禁止.
任务上下文(Task Context): 任务上下文是指任务运行的环境。例如，针对x86的CPU，任务上下文可包括程序计数器、堆栈指针、通用寄存器的内容.
上下文切换（Context Switching）: 多任务系统中，上下文切换是指CPU的控制权由运行任务转移到另外一个就绪任务时所发生的事件，当前运行任务转为就绪（或者挂起、删除）状态，另一个被选定的就绪任务成为当前任务。上下文切换包括保存当前任务的运行环境，恢复将要运行任务的运行环境。上下文的内容依赖于具体的CPU.
轮转调度(Round-Robin Scheduling):使所有相同优先级,状态为ready的任务公平分享CPU(分配一定的时间间隔,使每个任务流享有CPU). 系统由256个优先级,从0到255,0为最高,255为最低。 任务在被创建时设定了优先级.也可用taskPrioritySet() 来改变任务优先级.
任务的主要状态: READY,PEND,DELAY,SUSPEND…
ready--------&gt;pended -----------semTake()/msgQReceive()-其他任务 ready--------&gt;delayed-----------taskDelay() ready--------&gt;suspended---------taskSuspend() pended-------&gt;ready-------------semaGive()/msgQSend()-其他任务 pended-------&gt;suspended---------taskSuspend() delayed------&gt;ready-------------expired delay delayed------&gt;suspended---------taskSuspend() suspended----&gt;ready-------------taskResume()/taskActivate() suspended----&gt;pended------------taskResume() suspended----&gt;delayed-----------taskResume() 轮转调度 (Round-Robin): 轮转调度可以扩充到优先抢占方式中,当多个任务优先级相同的情况下,轮转调度算法使任务按平等的时间片运行于CPU,共享CPU.避免一个任务长时间占用CPU,而导致其他任务不能运行.可以用 kernelTimeSlice() 来定义时间长度. taskLock()和 taskUnlock()用来取消优先抢占方式 和恢复优先抢占方式.
注意: 一个任务可以调用taskDelete()删除另一个任务,但是如果一个当前正在运行的任务被删除后,该任务的内存没有释放,而其他任务不知道,依然在等待,结果导致系统stop.用 taskSafe()和 taskUnsafe() 来保证正在运行的任务不被删除.
用法如下:
taskSafe (); semTake (semId, WAIT_FOREVER); /* Block until semaphore **ailable */ . .　. .　critical region . semGive (semId); semGive (semId); /* Release semaphore */ taskUnsafe (); 任务间的同步和进程间协调 信号量作为任务间同步和互斥的机制。在 wind 核中有几种类型的信号量，它们分别针对不同的应用需求：二进制信号量、计数信号量、互斥信号量和 POSIX 信号量。所有的这些信号量是快速和高效的，它们除了被应用在开发设计过程中外，还被广泛地应用在VxWorks 高层应用系统中。对于进程间通信，wind 核也提供了诸如消息队列、管道、套接字和信号等机制。
任务间的同步和进程间协调的几种方式:
 内存共享(Shared Memory),对简单的数据共享而言. 信号量(Semaphore),基本的互斥和同步. 消息队列(Message queues)和管道(Pipe),单个CPU中,任务间的信息传递. 套结字(Socket)和远程调用(Remote procedure calls),相对于网络任务间的通信. 信号(Signals),出错处理(Exception handling). 互斥(Mutual Exclusion) 互斥是用来控制多任务对共享数据进行串行访问的同步机制。在多任务应用中，当两个或多个任务同时访问共享数据时，可能会造成数据破坏。互斥使它们串行地访问数据，从而达到保护数据的目的.  解决互斥的几种方法:
 关闭中断的方法(intLock): 能解决任务和中断ISR之间产生的互斥.  funcA () { int lock = intLock(); . . critical region that cannot be interrupted . intUnlock (lock); } 但在实时系统中采取这个办法会影响系统对外部中断及时响应和处理的能力.
关闭系统优先级(taskLock): 关闭系统优先级,这样在当前任务执行时,除了中断外,不会有其他优先级高的任务来抢占CPU,影响当前程序运行.  funcA () { taskLock (); . . critical region that cannot be interrupted . taskUnlock (); } 这种方法阻止了高优先级的任务抢先运行,在实时系统中也是不适合的,除非关闭优先级的时间特别短.
信号量(Semaphore): 信号量是解决互斥和同步协调进程最好的方法  SEM_ID semMutex; semMutex = semBCreate (SEM_Q_PRIORITY, SEM_FULL); ......... semTake (semMutex, WAIT_FOREVER); . . critical region, only accessible by a single task at a time . semGive (semMutex); semBCreat(SEM_Q_FIFO,SEM_EMPTY), SEM_EMPTY 指明用于任务间同步. /* includes */ #include &#34;vxWorks.h&#34; #include &#34;semLib.h&#34; SEM_ID syncSem; /* ID of sync semaphore */ init ( int someIntNum ) { /* connect interrupt service routine */ intConnect (INUM_TO_IVEC (someIntNum), eventInterruptSvcRout, 0); /* create semaphore */ syncSem = semBCreate (SEM_Q_FIFO, SEM_EMPTY); /* spawn task used for synchronization. */ taskSpawn (&#34;sample&#34;, 100, 0, 20000, task1, 0,0,0,0,0,0,0,0,0,0); } task1 (void) { ... semTake (syncSem, WAIT_FOREVER); /* wait for event to occur */ printf (&#34;task 1 got the semaphore\n&#34;); ... /* process event */ } eventInterruptSvcRout (void) { ... semGive (syncSem); /* let task 1 process event */ ... } 函数介绍:
semTake(semID,time out)&mdash;&mdash;&ndash;有Semaphore空闲,就Take, 如果没有,由time out 定,超时则向下执行
 优先级反转(Priority Inversion) 优先级反转是指一个任务等待比它优先级低的任务释放资源而被阻塞，如果这时有中等优先级的就绪任务，阻塞会进一步恶化。优先级继承技术可用来解决优先级反转问题。
  优先级继承(Priority Inheritance) 优先级继承可用来解决优先级反转问题。当优先级反转发生时，优先级较低的任务被暂时地提高它的优先级，使得该任务能尽快执行，释放出优先级较高的任务所需要的资源。
  互斥信号量具有选项SEM_INVERSION_SAFE，它支持优先级继承算法。优先级继承协议确保拥有资源的任务以该资源上阻止的最高优先级任务的优先级执行。一旦任务优先级被提升，它将保持在更高的级别，直到任务拥有的所有互斥信号量被释放；然后任务返回其正常或标准优先级。因此，“继承”任务不受任何中间优先级任务的抢占。此选项必须与优先级队列（SEM_Q_priority）一起使用。
]]></content>
  </entry>
  
  <entry>
    <title>嵌入式操作系统VxWorks简介</title>
    <url>/post/bsp/embedded-os-vxworks-introduction.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Embedded OS</tag>
    </tags>
    <content type="html"><![CDATA[ VxWorks  操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），是嵌入式开发环境的关键组成部分。
嵌入式操作系统VxWorks简介 良好的持续能力、高性能的内核以及友好的用户开发环境，在嵌入式实时操作系统领域占据一席之地。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的F-16、FA-18战斗机、B-2隐形轰炸机和爱国者导弹上，甚至连1997年在火星表面登陆的火星探测器上也使用到了VxWorks。
实时操作系统和分时操作系统的区别 从操作系统能否满足实时性要求来区分，可把操作系统分成分时操作系统和实时操作系统。
分时操作系统按照相等的时间片调度进程轮流运行，分时操作系统由调度程序自动计算进程的优先级，而不是由用户控制进程的优先级。这样的系统无法实时响应外部异步事件。
实时操作系统能够在限定的时间内执行完所规定的功能，并能在限定的时间内对外部的异步事件作出响应。分时系统主要应用于科学计算和一般实时性要求不高的场合。实时性系统主要应用于过程控制、数据采集、通信、多媒体信息处理等对时间敏感的场合。
实时操作系统的结构 在计算的早期开发的操作系统的最原始的结构形式是一个统一的实体(monolithic)。在这样的系统中，提供的不同功能的模块，如处理器管理、内存管理、输入输出等，通常是独立的。然而他们在执行过程中并不考虑其他正在使用中的模块，各个模块都以相同的时间粒度运行。
由于现代实时环境需要许多不同的功能，以及在这样的环境中存在的并发活动所引起的异步性和非确定性，操作系统变得更加复杂。所以早期操作系统的统一结构的组织已经被更加精确的内部结构所淘汰。层次结构的起点————内核
操作系统的最好的内部结构模型是一个层次性的结构，最低层是内核。这些层次可以看成为一个倒置的金字塔，每一层都建立在较低层的功能之上。 内核仅包含一个操作系统执行的最重要的低层功能。正象一个统一结构的操作系统，内核提供了在高层软件与下层硬件之间的抽象层。然而，内核仅提供了构造操作系统其他部分所需的最小操作集。
拥有其它名字的内核 许多商用化的内核支持的功能远强于上面所列的要求。在这方面，他们不是真正的内核，而更象一个小的统一结构的操作系统。因为他们包含简单的内存分配、时钟管理、甚至一些输入输出系统调用的功能。
这种分类不仅仅是在语义上的争论，在这篇文章的后面章节将说明限制内核功能和油画这些功能的重要性。
VxWorks的特点 可靠性 操作系统的用户希望在一个工作稳定，可以信赖的环境中工作，所以操作系统的可靠性是用户首先要考虑的问题。而稳定、可靠一直是VxWorks的一个突出优点。自从对中国的销售解禁以来，VxWorks以其良好的可靠性在中国赢得了越来越多的用户。
实时性 实时性是指能够在限定时间内执行完规定的功能并对外部的异步事件作出响应的能力。实时性的强弱是以完成规定功能和作出响应时间的长短来衡量的。
VxWorks的实时性做得非常好，其系统本身的开销很小，进程调度、进程间通信、中断处理等系统公用程序精练而有效，它们造成的延迟很短。VxWorks提供的多任务机制中对任务的控制采用了优先级抢占（Preemptive Priority Scheduling）和轮转调度（Round-Robin Scheduling）机制，也充分保证了可靠的实时性，使同样的硬件配置能满足更强的实时性要求，为应用的开发留下更大的余地。
可裁减性 用户在使用操作系统时，并不是操作系统中的每一个部件都要用到。例如图形显示、文件系统以及一些设备驱动在某些嵌入系统中往往并不使用。
VxWorks由一个体积很小的内核及一些可以根据需要进行定制的系统模块组成。VxWorks内核最小为8kB，即便加上其它必要模块，所占用的空间也很小，且不失其实时、多任务的系统特征。由于它的高度灵活性，用户可以很容易地对这一操作系统进行定制或作适当开发，来满足自己的实际应用需要。
对一个实时内核的要求 一个实时操作系统内核需满足许多特定的实时环境所提出的基本要求，这些包括：
 多任务：由于真实世界的事件的异步性，能够运行许多并发进程或任务是很重要的。多任务提供了一个较好的对真实世界的匹配，因为它允许对应于许多外部事件的多线程执行。系统内核分配CPU给这些任务来获得并发性。 抢占调度：真实世界的事件具有继承的优先级，在分配CPU的时候要注意到这些优先级。基于优先级的抢占调度，任务都被指定了优先级， 在能够执行的任务（没有被挂起或正在等待资源）中，优先级最高的任务被分配CPU资源。换句话说，当一个高优先级的任务变为可执行态，它会立即抢占当前正在运行的较低优先级的任务。 快速灵活的任务间的通信与同步：在一个实时系统中，可能有许多任务作为一个应用的一部分执行。系统必须提供这些任务间的快速且功能强大的通信机制。内核也要提供为了有效地共享不可抢占的资源或临界区所需的同步机制。 方便的任务与中断之间的通信：尽管真实世界的事件通常作为中断方式到来，但为了提供有效的排队、优先化和减少中断延时，我们通常希望在任务级处理相应的工作。所以需要杂任务级和中断级之间存在通信。 性能边界：一个实时内核必须提供最坏情况的性能优化，而非针对吞吐量的性能优化。我们更期望一个系统能够始终以50微妙执行一个函数，而不期望系统平均以10微妙执行该函数，但偶尔会以75微妙执行它。 特殊考虑：由于对实时内核的要求的增加，必须考虑对内核支持不断增加的复杂功能的要求。这包括多进程处理，Ada和对更新的、功能更强的处理器结构如RISC的支持。  VxWorks内核：Wind VxWorks操作系统是一种功能最全的现在可以获得的独立于处理器的实时系统。然而，VxWorks是带有一个相当小的真正微内核的层次结构。内核仅提供多任务环境、进程间通信和同步功能。这些功能模块足够支持VxWorks在较高层次所提供的丰富的性能的要求。 通常内核操作对于用户是不可见的。应用程序为了实现需要内核参与的任务管理和同步使用一些系统调用，但这些调用的处理对于调用任务是不可见的。应用程序仅链接恰当的VxWorks例程（通常使用VxWorks的动态链接功能），就象调用子程序一样发出系统调用。这种接口不象有些系统需要一个笨拙的跳转表接口，用户需要通过一个整数来指定一个内核功能调用。
多任务 内核的基本功能是提供一个多任务环境。多任务使得许多程序在表面上表现为并发执行，而事实上内核是根据基本的调度算法使他们分段执行。每个明显独立的程序被成为一个任务。每个任务拥有自己的上下文，其中包含在内核调度使该任务执行的时候它所看到的CPU环境和系统资源。
任务状态和状态迁移 内核维护系统中的每个任务的当前状态。状态迁移发生在应用程序调用内核功能服务的时候。下面定义了wind内核状态：
 就绪态&mdash;-一个任务当前除了CPU不等待任何资源 阻塞态&mdash;-一个任务由于某些资源不可获得而被阻塞 延迟态&mdash;-一个任务睡眠一段时间 挂起态&mdash;-主要用于调试的一个辅助状态，挂起禁止任务的执行 任务被创建以后进入挂起态，需要通过特定的操作使被创建的任务进入就绪态，这一操作执行速度很快，使应用程序能够提前创建任务，并以一种快捷的方式激活该任务。  实时系统的一个任务可有多种状态，其中最基本的状态有四种：
 就绪态：任务只等待系统分配CPU资源； 悬置态：任务需等待某些不可利用的资源而被阻塞； 休眠态：如果系统不需要某一个任务工作，则这个任务处于休眠状态； 延迟态：任务被延迟时所处状态；  当系统函数对某一任务进行操作时，任务从一种状态迁移到另一状态。处于任一状态的任务都可被删除。
状态迁移调用
就绪态 ----&gt; 悬置态semTake()/msgQReceive() 就绪态 ----&gt; 延迟态taskDelay() 就绪态 ----&gt; 休眠态taskSuspend() 悬置态 ----&gt; 就绪态semGive()/msgQSend() 悬置态 ----&gt; 休眠态taskSuspend() 延迟态 ----&gt; 就绪态expireddelay 延迟态 ----&gt; 休眠态taskSuspend() 休眠态 ----&gt; 就绪态taskResume()/taskActivate() 休眠态 ----&gt; 悬置态taskResume() 休眠态 ----&gt; 延迟态taskResume() 调度控制 多任务需要一个调度算法分配CPU给就绪的任务。在VxWorks中默认的调度算法是基于优先级的抢占调度，但应用程序也可以选择使用时间片轮转调度。
  基于优先级抢占调度：基于优先级的抢占调度，每个任务被指定一个优先级，内核分配CPU给处于就绪态的优先级最高的任务。调度采用抢占的方式，是因为当一个优先级高于当前任务的任务变为就绪态时，内核将立即保存当前任务的上文，并切换到高优先级任务的上文。VxWorks有从0到255共256个优先级。在创建的时候任务被指定一个优先级，在任务运行的过程中可以动态地修改优先级以便跟踪真实世界的事件优先级。外部中断被指定优先于任何任务的优先级，这样能够在任何时候抢占一个任务。
  时间片轮转：基于优先级抢占调度可以扩充时间片轮转调度。时间片轮转调度允许在相同优先级的处于就绪态的任务公平地共享CPU。没有时间片轮转调度，当有多个任务在同一优先级共享处理器时，一个任务可能独占CPU，不会被阻塞直到被一个更高优先级的任务抢占，而不给同一优先级的其他任务运行的机会。如果时间片轮转被使能，执行任务的时间计数器在每个时钟滴答递增。当指定的时间片耗尽，计数器会被清零，该任务被放在同一优先级任务队列的队尾。加入特定优先级组的新任务被放在该组任务的队尾，并将运行计数器初始化为零。
  基本的任务函数 用于状态控制的基本任务函数包括一个任务的创建、删除、挂起和唤醒。一个任务也可以使自己睡眠一个特定的时间间隔不去运行。许多其他任务例程提供由任务上下文获得的状态信息。这些例程包括访问一个任务当前处理器寄存器控制。
高效的任务管理：
 多任务，具有256个优先级。 具有优先级排队和循环调度。 快速的、确定性的上下文切换。  任务删除问题 wind内核提供防止任务被意外删除的机制。通常，一个执行在临界区或访问临界资源的任务要被特别保护。我们设想下面的情况：一个任务获得一些数据结构的互斥访问权，当它正在临界区内执行时被另一个任务删除。由于任务无法完成对临界区的操作，该数据结构可能还处于被破坏或不一致的状态。而且，假想任务没有机会释放该资源，那麽现在其他任何任务现在就不能获得该资源，资源被冻结了。
任何要删除或终止一个设定了删除保护的任务的任务将被阻塞。当被保护的任务完成临界区操作以后，它将取消删除保护以使自己可以被删除，从而解阻塞删除任务。
正如上面所展示的，任务删除保护通常伴有互斥操作。
这样，为了方便性和效率，互斥信号量包含了删除保护选项。（参见&quot;互斥信号量&quot;）
任务间通信 为了提供完整的多任务系统的功能，wind内核提供了一套丰富的任务间通信与同步的机制。这些通信功能使一个应用中各个独立的任务协调他们的活动。
灵活的任务间通讯：
 三种信号灯：二进制、计数、有优先级继承特性的互斥信号灯。 消息队列。 套接字（Socket）。 共享内存。 信号（Signals） 微秒级的中断处理。 支持POSIX 1003.1b实时扩展标准。 支持多种物理介质及标准的、完整的TCP/IP网络协议。 灵活的引导方式。支持从ROM、flash、本地盘（软盘或硬盘）或网络引导。 支持多处理器并行处理。 快速灵活的I/O系统。 支持MS-DOS和RT－11文件系统。 支持本地盘，flash，CD-ROM的使用。 完全符合ANSI C标准。 多个系统调用。  共享地址空间 wind内核的任务间通信机制的基础是所有任务所在的共享地址空间。通过共享地址空间，任务能够使用共享数据结构的指针自由地通信。管道不需要映射一块内存区到两个互相通信任务的寻址空间。
不幸的是，共享地址空间具有上述优点的同时，带来了未被保护内存的重入访问的危险。UNIX操作系统通过隔离进程提供这样的保护，但同时带来了对于实时操作系统来说巨大的性能损失。
互斥操作 当一个共享地址空间简化了数据交换，通过互斥访问避免资源竞争就变为必要的了。用来获得一个资源的互斥访问的许多机制仅在这些互斥所作用的范围上存在差别。实现互斥的方法包括禁止中断、禁止任务抢占和通过信号量进行资源锁定。
  中断禁止：最强的互斥方法是屏蔽中断。这样的锁定保证了对CPU的互斥访问。这种方法当然能够解决互斥的问题，但它对于实时是不恰当的，因为它在锁定期间阻止系统响应外部事件。长的中断延时对于要求有确定的响应时间的应用来说是不可接受的。
  抢占禁止：禁止抢占提供了强制性较弱的互斥方式。 当前任务运行的过程中不允许其他任务抢占，而中断服务程序可以执行。这也可能引起较差的实时响应，就象被禁止中断一样，被阻塞的任务会有相当长时间的抢占延时，就绪态的高优先级的任务可能会在能够执行前被强制等待一段不可接受的时间。为避免这种情况，在可能的情况下尽量使用信号量实现互斥。
  互斥信号量：信号量是用于锁定共享资源访问的基本方式。不象禁止中断或抢占，信号量限制了互斥操作仅作用于相关的资源。一个信号量被创建来保护资源。VxWorks的信号量遵循Dijkstra的P()和V()操作模式。
  当一个任务请求信号量，P()， 根据在发出调用时信号量的置位或清零的状态， 会发生两种情况。如果信号量处于置位态， 信号量会被清零，并且任务立即继续执行。如果信号量处于清零态，任务会被阻塞来等待信号量。
当一个任务释放信号量，V()，会发生几种情况。如果信号量已经处于置位态，释放信号量不会产生任何影响。如果信号量处于清零态且没有任务等待该信号量，信号量只是被简单地置位。如果信号量处于清零态且有一个或多个任务等待该信号量，最高优先级的任务被解阻塞，信号量仍为清零态。
通过将一些资源与信号量关联，能够实现互斥操作。当一个任务要操作资源，它必须首先获得信号量。只要任务拥有信号量，所有其他的任务由于请求该信号量而被阻塞。当一个任务使用完该资源，它释放信号量，允许等待该信号量的另一个任务访问该资源。
Wind内核提供了二值信号量来解决互斥操作所引起的问题。 这些问题包括资源拥有者的删除保护，由资源竞争引起的优先级逆转。
  删除保护：互斥引起的一个问题会涉及到任务删除。在由信号量保护的临界区中，需要防止执行任务被意外地删除。删除一个在临界区执行的任务是灾难性的。资源会被破坏，保护资源的信号量会变为不可获得，从而该资源不可被访问。通常删除保护是与互斥操作共同提供的。由于这个原因，互斥信号量通常提供选项来隐含地提供前面提到的任务删除保护的机制。
  优先级逆转/优先级继承： 优先级逆转发生在一个高优先级的任务被强制等待一段不确定的时间以便一个较低优先级的任务完成执行。考虑下面的假设：
  T1，T2和T3分别是高、中、低优先级的任务。T3通过拥有信号量而获得相关的资源。当T1抢占T3，为竞争使用该资源而请求相同的信号量的时候，它被阻塞。如果我们假设T1仅被阻塞到T3使用完该资源为止，情况并不是很糟。毕竟资源是不可被抢占的。然而，低优先级的任务并不能避免被中优先级的任务抢占，一个抢占的任务如T2将阻止T3完成对资源的操作。这种情况可能会持续阻塞T1等待一段不可确定的时间。这种情况成为优先级逆转，因为尽管系统是基于优先级的调度，但却使一个高优先级的任务等待一个低优先级的任务完成执行。 互斥信号量有一个选项允许实现优先级继承的算法。优先级继承通过在T1被阻塞期间提升T3的优先级到T1解决了优先级逆转引起的问题。这防止了T3，间接地防止T1，被T2抢占。通俗地说，优先级继承协议使一个拥有资源的任务以等待该资源的任务中优先级最高的任务的优先级执行。当执行完成，任务释放该资源并返回到它正常的或标准的优先级。因此，继承优先级的任务避免了被任何中间优先级的任务抢占。
同步 信号量另一种通常的用法是用于任务间的同步机制。在这种情况下，信号量代表一个任务所等待的条件或事件。最初，信号量是在清零态。一个任务或中断通过置位该信号量来指示一个事件的发生。等待该信号量的任务将被阻塞直到事件发生、该信号量被置位。一旦被解阻塞，任务就执行恰当的事件处理程序。信号量在任务同步中的应用对于将中断服务程序从冗长的事件处理中解放出来以缩短中断响应时间是很有用的。
消息队列 消息队列提供了在任务与中断服务程序或其他任务间交换变长消息的一种较低层的机制。这种机制在功能上类似于管道，但有较少的开销。
管道、套接字、远程过程调用和更多高层的VxWorks机制提供任务间通信的更高层的抽象，包括管道、TCP/IP套接字、远程过程调用和更多。为了保持裁减内核为仅包含足够支持高层功能的一个最小函数集的设计目标，这些特性都是基于上面描述的内核同步方式的。
内核设计的优点 wind内核的一个重要的设计特性是最小的抢占延时。其他的主要设计的优点包括史无前例的可配置性，对不可预见的应用需求的可扩展性，在各种微处理器应用开发中的移植性。
最小的抢占延时 正如前面所讨论的，禁止抢占是获得代码临界资源互斥操作的通常手段。这种技巧的不期望的负面影响是高的抢占延时，这可以通过尽量使用信号量实现互斥和保持临界区尽量紧凑被减小。但即使广泛地使用信号量也不能解决所有的可能导致抢占延时的根源。内核本身就是一个导致抢占延时的根源。为了理解其原因，我们必须更好地理解内核所需的互斥操作。
内核级和任务级 在任何多任务系统中，大量的应用是发生在一个或多个任务的上下文。然而，有些CPU时间片不在任何任务的上下文。这些时间片发生在内核改变内部队列或决定任务调度。在这些时间片中，CPU在内核级执行，而非任务级。
为了内核安全地操作它的内部的数据结构，必须有互斥操作。内核级没有相关的任务上下文，内核不能使用信号量保护内部链表。内核使用工作延期作为实现互斥的方式。当有内核参与时，中断服务程序调用的函数不是被直接激活，而是被放在内核的工作 队列中。内核完成这些请求的执行而清空内核工作队列。
当内核正在执行已经被请求服务时系统将不响应到达内核的函数调用。可以简单地认为内核状态类似于禁止抢占。如前面所讨论的，抢占延时在实时系统中是不期望有的，因为它增加了对于会引起应用任务重新调度的事件的响应时间.
管操作系统在内核级（此时禁止抢占）完全避免消耗时间是不可能的，但减少这些时间是很重要的。这是减少由内核执行的函数的数量的主要原因， 也是不采用统一结构的系统设计方式的原因。例如，有一种流行的实时操作系统的每个函数都是在内核级执行。这意味着当一个低优先级的任务在执行分配内存、获得任务信息的函数时所有高优先级的任务被禁止抢占。
一个最小的内核 已经说明了一个最小内核的优点和构造高层操作系统功能的必要功能，我们使用这些操作原语来执行一个传统的内核级功能，而在VxWorks中作为任务级功能执行，内存管理。 在这个例子中，考虑用户可调用的子例程malloc， 用于分配所请求大小的内存区并返回一个指向该内存区的指针。假定空闲内存区是通过搜索一个空闲内存块的队列找到的，一个信号量必须被用来保护这个非抢占多用户资源。分配内存的操作如下：
 获得互斥信号量 搜索空闲内存块链表 释放互斥信号量  值得注意的是搜索一个足够大的空闲内存块的可能的冗长的时间是发生在调用任务的上下文中。这是可以被高优先级的任务抢占的（除了信号量调用的这段执行时间）。
在一个标准的统一结构的实时内核中，内存分配例程操作如下：
 进入内核 搜索空闲内存块链表 退出内核 整个内存分配发生在内核级，任务抢占被禁止如果高优先级的任务在此时变为就绪态，它必须等待直到内核为低优先级的任务完成内存分配。有些操作系统甚至在这段市时间禁止中断。  任务级操作系统服务 Wind River System的实时操作系统，VxWorks，显示了这样设计的一个最小内核是能够满足需求的。VxWorks是现在能够获得的独立于任何处理器的、拥有相当小内核的、功能完全的层次结构的实时操作系统。
VxWorks在内核之上提供了大量的功能。它包括内存管理，一个完整的BSD4.3网络包，TCP/IP，网络文件系统（NFS），远程过程调用（RPC），UNIX兼容的链接加载模块，C语言的解释界面，各种类型的定时器，性能监测组件，调试工具，额外的通信工具如管道、信号和套接字，I/O和文件系统，和许多功能例程。这些都不是运行在内核级，所以不会禁止中断或任务抢占。
可配置性 实时应用有多种内核需求。没有哪个内核有一个用来满足每种需求的很好的设计折衷。然而，一个内核可以通过配置来调整特定的性能特性，裁减实时系统来最好地适应一个应用的要求。不可预见的内核配置性以用户可选择的内核排队算法的形式提供给应用。
排队策略 VxWorks中的排队库是独立于使用他们的内核队列功能而执行的，这样提供了将来增加新的排队方式的灵活性。
在VxWorks中有各种内核队列。就绪队列是一个按优先级索引的所有等待调度的任务队列。滴答队列用于定时功能。信号量是一个等待信号量的被阻塞任务的链表。活动队列是一个系统中所有任务的一个先进先出（FIFO）的链表。这些队列中的每个队列都需要一个不同的排队算法。这些算法不是被内嵌在内核中，而是被抽取到一个自治的、可转换的排队库中。这种灵活的组织形式是满足特殊的配置需求的基础。
可扩展性 支持不可预见的内核扩展的能力与以有功能的可配置性是同样重要的。简单的内核接口和互斥方法使内核级功能扩展相当容易； 在某些情况下，应用可以仅利用内核钩子函数来实现特定的扩展。
内部钩子函数 为了不修改内核而能够向系统增加额外的任务相关的功能，VxWorks提供了任务创建、切换和删除的钩子函数。这些允许在任务被创建、 上下文切换和任务被删除的时候额外的例程被调用执行。这些钩子函数可以利用任务上下文中的空闲区创建wind内核的任务特性。
未来考虑 有许多系统函数现在变得越来越重要，而且会影响到内核设计时的抢占延时。尽管涉及这些问题一个完整的讨论超出了本文的范围，但值得简单地提一下。 RISC/CISC设计一个独立于CPU的操作系统一直是一个挑战。随着新的RSIC（精简指令集）处理器变得很流行，这些难度也加大了。为了在RISC环境下有效地执行，内核和操作系统需要有执行不同策略的灵活性。
例如，考虑在任务切换时内核执行的例程。在CISC（复杂指令集，如680x0或80x86）CPU，内核为每个任务存储一套完整的寄存器，在运行任务的时候将这些寄存器换入换出。在一个RISC机器上，这样是不合理的，因为涉及到太多的寄存器。所以内核需要一个更精密复杂的策略，如为任务缓存寄存器，允许应用指定一些寄存器给特殊的任务。
移植性 为了使wind内核在他们出现的结构上能够运行，需要有一个可移植的内核版本。这使移植是可行的，但不是最优化的。
多处理 支持紧耦合的多处理需求要求实时内核的内部功能包含，在理想情况下，在远端请求内核调用，如从一个处理器到另一个处理器。这就要涉及到信号量调用（为处理器间同步）和任务调用（为了控制另一个CPU上的任务）。这种复杂性无疑会增加内核级功能调用的开销，但是许多服务如对象标识可以在任务级执行。在多处理系统中保持一个最小内核的优点是处理器之间的互锁可以有较好的时间粒度。大的内核将在内核级消耗额外的时间，仅能获得粗糙的互锁时间粒度。
Ada Ada语言为实时系统设计者提供了象聚会机制这样的任务原语。异常处理、任务终止、终止替换和聚会都将潜在地影响内核设计。这些操作可以由前面讨论的任务和同步机制构造，为了保持减小抢占延时的设计目标，许多工作能够在任务级执行。
实时内核的重要尺度 许多性能特性被用来比较以有的实时内核，这些包括：
 快速的任务上下文切换&mdash;-由于实时系统的多任务的特性，系统能够快速地从一个任务切换到另一个任务是很重要的。在分时系统中，如UNIX，上下文切换是在ms级。Wind内核执行原始上下文切换只用17us。 最小的同步开销&mdash;-因为同步是实现资源互斥访问的基本方法，这些操作所引起的开销最小化是很重要的。在VxWorks中，请求和释放二值信号量仅用8us。 最小的中断延时&mdash;-因为外部世界来的事件通常以中断的形式到来，操作系统快速的处理这些中断是很重要的。内核在操作一些临界数据结构的时候必须禁止中断。为了减小中断延时，必须使这些时间最小化。Wind内核的中断延时小于10us。  抢占延时对性能指标的影响 当许多的实时解决方案被提交给应用工程师时， 性能指标对于评估供应商的产品变得越来越重要。不象上下文切换和中断延时，抢占延时很难测量。所以它很少在说明中被提及。但是考虑到当内核通常禁止上下文切换会长达数百微妙，而声称一个50us的固定长度（与任务个数无关）的上下文切换时间是毫无意义的。除了很难测量外，抢占延时可能会削弱许多性能指标的有效性。
Wind内核通过减小内核的大小来尽量减小抢占延时。 包含繁多功能的内核必将引起长的抢占延时。
任务管理 任务是代码运行的一个映象，从系统的角度看，任务是竞争系统资源的最小运行单元。任务可以使用或等待CPU、I/O设备及内存空间等系统资源，并独立于其它任务，与它们一起并发运行（宏观上如此）。VxWorks内核使任务能快速共享系统的绝大部分资源，同时有独立的上下文来控制个别线程的执行。
任务结构 多任务设计能随时打断正在执行着的任务，对内部和外部发生的事件在确定的时间里作出响应。VxWorks实时内核Wind提供了基本的多任务环境。从表面上来看，多个任务正在同时执行，实际上，系统内核根据某一调度策略让它们交替运行。系统调度器使用任务控制块的数据结构（简记为TCB)来管理任务调度功能。任务控制块用来描述一个任务，每一任务都与一个TCB关联。TCB包括了任务的当前状态、优先级、要等待的事件或资源、任务程序码的起始地址、初始堆栈指针等信息。调度器在任务最初被激活时以及从休眠态重新被激活时，要用到这些信息。
此外，TCB还被用来存放任务的&quot;上下文&quot;（context)。任务的上下文就是当一个执行中的任务被停止时，fPW&quot;教T供\aI管h;`所要保存的所有信息。在任务被重新执行时，必须要恢复上下文。通常，上下文就是计算机当前的状态，也即各个寄存器的内容。如同在发生中断所要保存的内容一样。当发生任务切换时，当前运行的任务的上下文被存入TCB，将要被执行的任务的上下文从它的TCB中取出，放入各个寄存器中。于是转而执行这个任务，执行的起点是前次它在运行时被中止的位置。
VxWorks中，内存地址空间不是任务上下文的一部分。所有的代码运行在同一地址空间。如每一任务需各自的内存空间，需可选产品VxVMI的支持。
任务调度策略 多任务调度须采用一种调度算法来分配CPU给就绪态任务。Wind内核采用基于优先级的抢占式调度法作为它的缺省策略，同时它也提供了轮转调度法。
基于优先级的抢占式调度，它具有很多优点。这种调度方法为每个任务指定不同的优先级。没有处于悬置或休眠态的最高优先级任务将一直运行下去。当更高优先级的任务由就绪态进入运行时，系统内核立即保存当前任务的上下文，切换到更高优先级的任务。
多任务调度须采用一种调度算法来分配CPU给就绪态任务。Wind内核采用基于优先级的抢占式调度法作为它的缺省策略，同时它也提供了轮转调度法。
基于优先级的抢占式调度，它具有很多优点。这种调度方法为每个任务指定不同的优先级。没有处于悬置或休眠态的最高优先级任务将一直运行下去。当更高优先级的任务由就绪态进入运行时，系统内核立即保存当前任务的上下文，切换到更高优先级的任务。
Wind内核划分优先级为256 级（0~255）。优先级0为最高优先级，优先级255为最低。当任务被创建时，系统根据给定值分配任务优先级。然而，优先级也可以是动态的，它们能在系统运行时被用户使用系统调用taskPrioritySet()来加以改变，但不能在运行时被操作系统所改变。
轮转调度法分配给处于就绪态的每个同优先级的任务一个相同的执行时间片。时间片的长度可由系统调用KernelTimeSlice()通过输入参数值来指定。很明显，每个任务都有一运行时间计数器，任务运行时每一时间滴答加1。一个任务用完时间片之后，就进行任务切换，停止执行当前运行的任务，将它放入队列尾部，对运行时间计数器置零，并开始执行就绪队列中的下一个任务。当运行任务被更高优先级的任务抢占时，此任务的运行时间计数器被保存，直到该任务下次运行时。
抢占禁止 Wind内核可通过调用taskLock()和taskUnlock（）来使调度器起作用和失效。当一个任务调用taskLock()使调度器失效，任务运行时没有基于优先级的抢占发生。然而，如果任务被阻塞或是悬置时，调度器从就绪队列中取出最高优先级的任务运行。当设置抢占禁止的任务解除阻塞，再次开始运行时，抢占又被禁止。这种抢占禁止防止任务的切换，但对中断处理不起作用。
异常处理 程序代码和数据的出错，如非法命令、总线或地址错误、被零除等。VxWorks异常处理包，一般是将引起异常的任务休眠，保存任务在异常出错处的状态值。内核和其它任务继续执行。用户可借助Tornado开发工具，查看当前任务状态，从而确定被休眠的任务。
任务管理 VxWorks内核的任务管理提供了动态创建、删除和控制任务的功能，具体实现通过如下一些系统调用：
 taskSpawn()创建（产生并激活）新任务 taskInit() 初始化一个新任务 taskActivate() 激活一个已初始化的任务 taskName() 由任务ID号得到任务名 taskNameToId（）由任务名得到任务ID号 taskPriorityGet()获得任务的优先级 taskIsSuspended()检查任务是否被悬置 taskIsReady()检查任务是否准备运行 taskTcb()得到一个任务控制块的指针 taskDelete() 中止指定任务并自由内存（仅任务堆栈和控制块） taskSafe() 保护被调用任务 taskSuspend()悬置一个任务 taskResume() 恢复一个任务 taskRestart()重启一个任务 taskDelay()延迟一个任务  VxWorks中的多任务通讯机制 通常，在一个实时系统中，存在着多个并发的任务来协同实现系统的功能，操作系统必须为这些任务提供快速且功能强大的通信机制。在VxWorks系统中，有信号量（semaphore）、消息队列（message queue）、管道（pipe）、事件（event）等通信机制，对一个系统开发人员来说，如何合理地使用这些通信机制，是系统能够长期高效、可靠、安全运行的关键。
信号量（semaphore） 在VxWorks种，信号量是提供任务间同步和互斥的最快速、开销最小的机制，VxWorks有三种不同类型的信号量：
 二进制信号量：可用于2个任务之间的同步工作。如任务A必须在任务B完成特定的动作以后才能进行，在这种情况下，任务A可以获取信号量而处于阻塞（pend）状态，任务B在完成特定的动作后释放该信号量。一般来说二进制信号量适用于一对一的任务之间的同步。 互斥信号量：主要用于任务之间共享数据区的互斥保护，具有优先级反转、安全删除、递归等特性。在有2个或2个以上的任务共享一个数据区的时候，必须使用互斥机制进行保护。 计数器信号量：类似于二进制信号量，但是对信号量的释放、获取有计数功能，而二进制信号量则只有0和1两种状态。 VxWorks提供了一组管理信号量的函数接口供开发者使用，包括创建、删除、获取、释放等。  虽然信号量具有快速、开销小的优点，但也有它的局限性，首先它无法提供额外的信息，其次对于一个任务必须与多个任务进行同步的情况，信号量也无能为力。因此在许多场合，信号量必须与其它通信机制配合使用来完成任务之间的通信。
消息队列（message queue） 消息队列是VxWorks提供的单个CPU中的任务之间通信的主要机制之一。消息队列允许基于FIFO或基于任务优先级方式排队消息，一个消息队列的消息数目和消息长度可以由开发者在创建消息队列时指定。在理论上，VxWorks允许多个任务向同一个消息队列发送消息，或者从同一个消息队列接收消息；而在实际应用中，一般来说只有一个任务从消息队列接收消息，有一个或多个任务发送消息，即这个消息队列有多个生产者，而只有一个消费者。消息队列时单向的，对于需要进行双向通信的两个任务，必须使用两个消息队列。消息队列非常适合于Client-Server结构的任务之间的通信，如图一，任务Client1和Client2都需要任务Server的服务，它们通过消息队列“Request Queue”向任务Server发送请求和参数，任务Server处理请求后分别通过“Reqpy Queue 1”和“Reqpy Queue 2”向这两个任务返回结果。
在VxWorks中，消息队列是一种代价比较高的一种通信机制，因此在使用时应该使消息的长度尽量短，而且应避免在需要十分频繁通信的场合使用消息队列。另外消息队列中的消息是排队的，即使是完全相同的消息，后面的消息也不会覆盖前面的消息。
管道（pipe） 在VxWorks中，管道是一种通过虚拟的I/O设备来实现的消息队列通信机制。使用函数pipeDevCreate()和pipeDevDelete()来生成和删除管道，管道一经生成后，任务之间就可以使用标准I/O操作主要是read()和write()进行通信。管道的优点在于它是一个I/O设备，与标准的VxWorks I/O一样，可以使用select机制，而有了select机制，一个任务很方便地使用多个异步I/O设备，如任务要处理同时从串口、管道、socket接收到的数据，就可以使用select。
事件（event） 在5.5版本之前，VxWorks并没有事件这一通信机制。事件(event) 最早出现在pSOS实时操作系统中，在风河公司收购了pSOS之后，从VxWorks 5.5之后，加入了事件机制，并在pSOS事件的基础上做了增强和改进。事件可用于任务和中断服务程序ISR之间、任务和任务之间、任务和VxWorks资源之间进行通信。任务用函数eventReceive()来接收它关心的事件，用eventSend()来向另一个任务发送事件。
VxWorks资源主要是指信号量和消息队列，一个任务要想从VxWorks资源接收到事件，必须先进行注册(register)，那么当资源处于FREE状态时，会向注册过的任务发送一个事件。对于每一个VxWorks资源，最多只允许有一个任务注册。如对于消息队列，任务可以使用函数msgQEvStart()来进行注册，那么当有消息到达这个消息队列而又没有任务等待这个消息队列时，会向这个任务发送一个事件，表明消息队列可用。而对于信号量，可以用函数semEvStart()来进行注册。但必须注意的是，一个任务接收到资源发送的事件后，并不能保证这个任务能获取该资源，如获取信号量、从消息队列接收到消息。
在VxWorks中，每一个任务都有一个32位事件寄存器，其中高8位由VxWorks系统保留，开发者可以使用低24位，其每一位表示一种事件，而事件的意义则完全有任务来定义，因此对于不同的任务，相同的位可能有不同的意义。而VxWorks并不对事件进行计数，而只表示该事件发生过，这与消息队列不同，因此接收事件的任务并不能知道接受到的事件发生的次数。
事件非常适合于一个任务必须与多个任务进行通信的场合，如任务A必须同时与任务B、任务C、任务D进行通信，其中任务B通过消息队列向任务A发送数据，其发送频率较低，它要求任务A必须及时进行处理；而任务C则只是向任务A指示一种状态，但频率很高；而任务D用来通知任务A释放动态申请的资源，并停止运行。在这种场合，事件机制能很好地解决问题。
总结 在VxWorks中，任务之间高效、经济地通信对整个系统的性能有很大的影响。一般来说并不能使用一种单一的通信机制就能解决问题，而是需要同时使用多种通信机制。另外，对任务的合理划分，又能简化任务之间的通信。总之，开发者必须通过足够的实践，才能充分利用VxWorks的各种通信机制，设计出高效、可靠的实时系统
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks 7自启动应用程序的四种方法</title>
    <url>/post/app/vxworks-7-app-auto-boot-method.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks 7</tag>
      <tag>APP Auto Boot</tag>
    </tags>
    <content type="html"><![CDATA[本文介绍了VxWorks 7系统下自启动应用程序的四种方法
背景介绍 在开始之前我们先来了解一下一些vxworks的一些基础知识。
VxWorks工程 VxWorks 7 可以创建以下几种典型的工程：
   Project Type Output Description     VSB (VxWorks Source Build) .a 基于某个特定的bsp，根据支持的cpu架构，把vxworks内核源码编译成静态库。注意这里这是只是把内核源码编译成库，供后续创建的VIP工程使用，并不会产生任何的映像文件。内核公共代码预先编译成库，也可以加速用户VIP工程的编译速度。另外也说明，如果你修改了内核代码，你需要重新编译VSB工程才会生效。   VIP (VxWorks Image Project) vxworks	用户自定义的vxworks映像工程。把用户选择的各种内核组件(使用CDF文件描述)，根据vxworks的启动顺序编译链接起来，得到常用的vxworks映像。各种内核组件在VSB工程中已经预先编译好，供VIP工程挑选使用。   DKM (Downloadable Kernel Module) .out VxWorks内核态应用程序。可加载的内核模块，类似如linux下的ko文件。对于跑在内核态的用户代码，即可以添加到VIP工程中，也可以使用DKM工程独立成内核模块。在vxworks启动完成后，使用&quot;ld &lt; xxx.out&quot;的命令来动态加载。   RTP(Real-Time Process) .vxe VxWorks用户态应用程序。跑在用户态的用户代码，使用RTP工程编译成.vxe文件。在vxworks启动完成后，使用“rtp exec xxx.vxe”命令来执行。    VxWorks shell VxWorks拥有自己的命令行交互工具kernel shell，比较特殊的是shell有两种模式分别支持两种解析器：C Interpreter和Command Interpreter。
   Mode 提示符 模式切换 Description     C Interpreter -&gt; 使用“cmd”命令切换到Command Interpreter模式 C Interpreter设计的目的是用来监控、调试内核代码。它最大的特点是可以直接调用函数名来执行，非常方便调试。   Command Interpreter # 使用“C”命令切换到C Interpreter模式 Command Interpreter设计的目的是用来启动、监控、调试用户态的RTP应用程序。它提供了很多专门的调试命令，类似于linux shell。    详细描述可以参考文档：“installDir\docs\vxworks-7-1.0.8.6\Core\vxworks_7_programmers_guide.pdf”。  内核应用程序(DKM)自启动 需求来源 用户有两个内核应用程序，已经使用DKM工程编译成了.out文件：pruss_eth.out、s24_DriveRotationCiA402.out。在shell的C Interpreter模式下可以动态加载和运行：
step 1 手工加载pruss_eth.out，并调用prussStart()函数进行运行：
-&gt; ld&lt;/mmc1:1/pruss_eth.out value = 541560848 = 0x20479010 -&gt; prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 step 2 手工加载s24_DriveRotationCiA402.out，并调用main()函数进行运行：
-&gt; ld&lt;/mmc1:1/s24_DriveRotationCiA402.out Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerStop. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerCreate. Warning: module 0x20479874 holds reference to undefined symbol MasterStartPIClientProcessor. Warning: module 0x20479874 holds reference to undefined symbol MasterStopPIClientProcessor. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. value = 0 = 0x0 -&gt; main Initialize Master ... Create Master instance ... Get network adapter name ... Network adapters count: Attach Master to adapter &#39;kpa_pruss0&#39; ... Create Configurator instance to load configuration ... Loading ENI &#39;/master.xml&#39; ... ... 用户希望在做硬件测试或者正式产品时，以上两步骤能够自动运行。
方案1(失败) VxWorks支持使用INCLUDE_RTP_APPL_INIT_BOOTLINE组件来配置系统启动时自动运行C Interpreter格式的脚本，我们尝试使用此方法来实现系统启动时自加载DKM并运行。
  首先我们在VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_BOOTLINE选项：   VIP工程的SCRIPT_DEFAULT选项设置为我们需要运行的脚本“/mmc1:1/autorun_c.sh”：   SCRIPT_DEFAULT主要的作用是设置default bootline中的startup script选项。vxworks在INCLUDE_RTP_APPL_INIT_BOOTLINE使能的情况下，会在启动阶段执行bootline中startup script选项描述的C脚本：
usrRoot() -&gt; usrToolsInit() -&gt; usrShellInit(): void usrShellInit (void) { shellLibInit (); /* This component includes the shell core files. */ shellHistLibInit (); /* This component provides the histSave() and histLoad() functions for the C interpreter. */ dbgLibInit (DEBUG_STACK_TRACE_BUF_SIZE); /* This component includes the primary interactive functions for VxWorks. The following facilities are provided: task breakpoints, task single-stepping, symbolic disassembly, symbolic task stack tracing. */ vxdbgRtpLibInit (); /* This component includes the process debugging library. */ ledModeRegister (emacsLedLibInit); /* This component provides an editing mode similar to the Emacs editor. */ shellInterpRegister (shellInterpCInit); /* This component provides the C interpreter for the kernel shell. */ shellInterpRegister (shellInterpCmdInit); /* This component provides the command interpreter for the kernel shell. */ usrShellCmdInit (); /* The kernel shell commands initialization sequence */ /* (1) 从bootline参数的startupScript选项中解析出脚本名，并执行 */ usrStartupScript (startupScriptFieldSplit (sysBootParams.startupScript)); /* Including this component results in the execution of a kernel shell script at VxWorks startup. */ usrShell (); /* This component includes the target-resident kernel shell, which is spawned as a task. Any function that is invoked from the kernel shell, rather than spawned, runs in the shell&#39;s context. The task name for a shell on the console is &#34;tShell0&#34;. The kernel shell is re-entrant, and more than one shell task can run at a time (hence the number suffix). In addition, if a user logs in remotely (using rlogin or telnet) to a VxWorks target, the name reflects that fact as well. For example, &#34;tShellRem1&#34;. The &#34;tShell&#34; basename is configurable, see the VxWorks 7 Kernel Shell User&#39;s Guide. */ } 如果使用vxworks自带的bootloader，可以在boot cmd命令行中配置bootline的startup script选项:
startup script (s) : /mmc1:1/autorun_c.sh 但是我们目前方案的bootloader使用的是uboot，所有我们只需配置好默认bootline中的startup script选项。
autorun_c.sh脚本中的内容非常简单，就是我们手工执行时需要键入的4条指令：  ld&lt;/mmc1:1/pruss_eth.out prussStart ld&lt;/mmc1:1/s24_DriveRotationCiA402.out main 运行结果： 实际的运行结果，发现vxworks启动后，卡住几分钟才能执行到autorun_c.sh脚本：  Adding 11197 symbols for standalone. // vxworks启动完成 // 卡住了好几分钟 Waiting for device to mount // autorun_c.sh脚本才得到执行 Executing startup script &#39;/mmc1:1/autorun_c.sh&#39;... ld&lt;/mmc1:1/pruss_eth.out value = 541474832 = 0x20464010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 ...  初步分析卡住的原因：  在“usrRoot() -&gt; usrToolsInit() -&gt; usrShellInit()-&gt;usrStartupScript()”这个时间点执行“/mmc1:1/autorun_c.sh”脚本时，“/mmc1:1/”设备并没有mount好，usrStartupScript()函数中重试机制在不停的重新尝试执行，但是这个重试机制又会阻止“/mmc1:1/”的mount进程，所以会卡死很久。
因为没有深入研究vxworks的初始化流程，我们先尝试使用别的方法，后续有时间可以研究卡住问题的解决方案。
方案2(成功) VxWorks执行自定义内核程序，还有一个公共的入口在usrAppInit()函数当中，函数调用关系如下：
void usrRoot (char *pMemPoolStart, unsigned memPoolSize) { ... usrToolsInit (); // 这里进行usrShellInit()-&gt;usrStartupScript()的调用  usrAppInit (); ... } 可以看到usrAppInit()调用点比方案1的usrShellInit()调用点靠后，我们尝试在usrAppInit()里面实现内核模块DKM的自加载。
 我们在usrAppInit()函数中直接调用usrStartupScript()来运行&quot;/mmc1:1/autorun_c.sh&quot;脚本：  void usrAppInit (void) { #ifdef	USER_APPL_INIT 	USER_APPL_INIT;	/* for backwards compatibility */ #endif  /* TODO: add application specific code here */ ioDefPathSet(&#34;/mmc1:1/&#34;); usrStartupScript(&#34;/mmc1:1/autorun_c.sh&#34;); } autorun_c.sh脚本的内容还是和方案1一样：  ld&lt;/mmc1:1/pruss_eth.out prussStart ld&lt;/mmc1:1/s24_DriveRotationCiA402.out main 运行结果：  vxworks启动后，没有卡住的现象，autorun_c.sh脚本能迅速得到执行：
Adding 11197 symbols for standalone. Waiting for device to mount .-&gt; Executing startup script &#39;/mmc1:1/autorun_c.sh&#39;... ld&lt;/mmc1:1/pruss_eth.out value = 541536272 = 0x20473010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 ld&lt;/mmc1:1/s24_DriveRotationCiA402.out Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStop. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerCreate. Warning: module 0x204735b8 holds reference to undefined symbol MasterStartPIClientProcessor. Warning: module 0x204735b8 holds reference to undefined symbol MasterStopPIClientProcessor. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. value = 0 = 0x0 Done executing startup script &#39;/mmc1:1/autorun_c.sh&#39;. -&gt; 但细心的同学会发现autorun_c.sh脚本中的4条指令只执行了3条，最后一条&quot;main&quot;指令并没有得到执行，但是在shell下手工键入又可以得到执行，这是为什么呢？
首先怀疑&quot;main&quot;这个符号和其他人重名，造成调用失败。但是查找符号表后，发现并没有重名情况：
-&gt; -&gt; cmd [vxWorks *]# [vxWorks *]# lookup main ipnet_radvd_main 0x001b8988 text main 0x00c9976c text (s24_DriveRotationCiA402.out) ipftpc_cmd_main 0x001325bc text vxbClkDomainInit 0x003d5c00 text tiClkDomainDrv 0x004cf6fc data vxbClkDomainRegister 0x003d4af8 text ipnet_flow_spec_domain 0x0015bc78 text ipftps_main 0x001374a8 text __dataset__driver_tiClkDomainDrv 0x004ddaa4 data [vxWorks *]#  进一步分析运行log发现一个情况：同样是加载.out文件，“ld&lt;/mmc1:1/pruss_eth.out”的返回值0x20473010其实是pruss_eth.out加载后的MODULE ID，但是&quot;ld&lt;/mmc1:1/s24_DriveRotationCiA402.out&quot;的返回值却为0:
-&gt; cmd [vxWorks *]# module MODULE NAME MODULE ID GROUP # TEXT START DATA START BSS START --------------- ---------- ---------- ---------- ---------- ---------- pruss_eth.out 0x20473010 1 0x00b59010 0x00b5b0e4 NO SEGMENT s24_DriveRotati 0x20473874 2 0x00b5c010 0x00cade18 0x00cb4064 于是怀疑&quot;ld&lt;/mmc1:1/s24_DriveRotationCiA402.out&quot;的加载过程出错，autorun_c.sh脚本执行中断，造成了随后的&quot;main&quot;命令没有得到运行。 在&quot;ld&lt;/mmc1:1/s24_DriveRotationCiA402.out&quot;我们可以看到有几个人符号没有得到解析的告警，虽然module还是加载上了还能手工执行，但是这个出错可能会中断脚本的运行：
... Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. 沿着这个分析方向，让用户编译一份没有符号解析错误的.out文件进行测试。
没有符号解析错误的.out，运行结果：  用户编译了一份没有符号解析错误的newmaster.out，来替换之前出错的s24_DriveRotationCiA402.out。autorun_c.sh脚本中的4条指令能够完美的得到执行：
Adding 11197 symbols for standalone. Waiting for device to mount .-&gt; Instantiating /sd0:2 as rawFs, device = 0x50001 Executing startup script &#39;/mmc1:1/autorun_c.sh&#39;... ld&lt;/mmc1:1/pruss_eth.out value = 541560848 = 0x20479010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 ld&lt;/mmc1:1/newmaster.out value = 541562996 = 0x20479874 = &#39;t&#39; main Initialize Master ... Create Master instance ... Get network adapter name ... Network adapters count: Attach Master to adapter &#39;kpa_pruss0&#39; ... Create Configurator instance to load configuration ... Loading ENI &#39;/master.xml&#39; ... Starting Master ... Master started. Start EtherCAT frames exchange ... Requesting Operational Master state ... ... 用户应用程序(RTP)自启动 在文档&quot;installDir\docs\vxworks-7-1.0.8.6\Core\vxworks_7_programmers_guide.pdf&quot;的&quot;Automatic Execution of RTP Applications&quot;章节，对RTP自启动的几种方法有着详细的描述，感兴趣可以自行学习。
我们以vxsim架构下的一个RTP程序为例来详细介绍这些方法。
首先我们创建了基于vxsim架构的VSB、VIP工程，并且创建了一个测试使用的RTP工程。测试代码的内容很简单：
rtp.c: #include &lt;stdio.h&gt; int main ( int	argc,	/* number of arguments */ char * argv[]	/* array of arguments */ ) { int i = 0; printf(&#34;Hello World!\nFrom your RTP application...\nBy pwl.\n&#34;); while(i&lt;3){ i++; taskDelay(100); printf(&#34;%d ticks\n&#34;, i*100); } return 0; } 我们使用这个RTP工程编译出TestSimRtp.vxe映像文件。
手工执行TestSimRtp.vxe文件有两种方式：
 在C shell下执行：  -&gt; -&gt; rtpSp &#34;host:D:/pwl_workspace/TestSimRtp.vxe&#34; value = 941088064 = 0x3817dd40 = &#39;@&#39; -&gt; Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -&gt; 在Command shell下执行：  -&gt; -&gt; cmd [vxWorks *]# rtp exec host:D:/pwl_workspace/TestSimRtp.vxe Launching process &#39;host:D:/pwl_workspace/TestSimRtp.vxe&#39; ... Process &#39;host:D:/pwl_workspace/TestSimRtp.vxe&#39; (process Id = 0x38cfb358) launched. Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks [vxWorks *]#  自动执行方式1 (RTP_APPL_INIT_STRING)  首先在vxsim的VIP工程中的配置选项中，使能INCLUDE_RTP_APPL_INIT_STRING选项：  配置其中的RTP_APPL_INIT_STRING参数： RTP_APPL_INIT_STRING参数的具体内容为：  &#34;#host:D:/pwl_workspace/TestSimRtp.vxe&#34; 这个字符串的详细语法可以参考&quot;installDir\docs\vxworks-7-1.0.8.6\Core\vxworks_7_programmers_guide.pdf&quot;中的&quot;Application Startup String Syntax&quot;小节。  启动vxworks simulator，查看运行结果，成功自动运行：  Loading symbol table from host:D:/pwl_workspace/TestSimVip/default/vxWorks.sym ...done -&gt; Spawning RTP: host:D:/pwl_workspace/TestSimRtp.vxe Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -&gt; 自动执行方式2 (RTP_APPL_INIT_BOOTLINE) VxWorks支持使用INCLUDE_RTP_APPL_INIT_BOOTLINE组件来配置系统启动时自动运行C Interpreter格式的脚本，我们尝试使用此方法来实现系统启动时自动运行RTP程序。
  首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_BOOTLINE选项：   vxsim VIP工程的SCRIPT_DEFAULT选项设置：   startup script具体的配置如下：
&#34;host:D:/pwl_workspace/autorun_c.sh#host:D:/pwl_workspace/TestSimRtp.vxe&#34; 需要注意的是startup script中可以配置两种不同的自启动方式，上述的参数可以分成两部分：
(1) “host:D:/pwl_workspace/autorun_c.sh”这部分配置的是vxworks在启动阶段执行一个C Interpreter格式的脚本。autorun_c.sh脚本的具体内容如下：
rtpSp &#34;host:D:/pwl_workspace/TestSimRtp.vxe&#34; 需要特别注意的是，这里调用的是C Interpreter格式的脚本，后面的RTP_APPL_INIT_CMD_SHELL_SCRIPT方式调用的是Command Interpreter格式的脚本。  (2)&quot;#host:D:/pwl_workspace/TestSimRtp.vxe&quot;这部分配置的语法和INCLUDE_RTP_APPL_INIT_STRING选项一样。
上述参数分别运行了一次TestSimRtp.vxe，所以TestSimRtp.vxe会被运行两次。
启动vxworks simulator，查看运行结果，成功自动运行两次：  Loading symbol table from host:D:/pwl_workspace/TestSimVip/default/vxWorks.sym ...done // (1) 第一次执行，使用autorun_c.sh脚本的执行 Executing startup script &#39;host:D:/pwl_workspace/autorun_c.sh&#39;... rtpSp &#34;host:D:/pwl_workspace/TestSimRtp.vxe&#34; value = 950476976 = 0x38a720b0 Hello World! From your RTP application... By pwl. Done executing startup script &#39;host:D:/pwl_workspace/autorun_c.sh&#39;. // (2) 第二次执行，使用&#34;#host:D:/pwl_workspace/TestSimRtp.vxe&#34;选项配置的执行 -&gt; Spawning RTP: host:D:/pwl_workspace/TestSimRtp.vxe Hello World! From your RTP application... By pwl. 100 ticks 100 ticks 200 ticks 200 ticks 300 ticks 300 ticks -&gt; 自动执行方式3 (RTP_APPL_INIT_CMD_SHELL_SCRIPT)  首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_CMD_SHELL_SCRIPT选项，并配置其中的RTP_APPL_CMD_SCRIPT_FILE参数：   参数的具体内容为：&ldquo;host:D:/pwl_workspace/autorun_cmd.sh&rdquo; 系统启动时自动运行配置的Command Interpreter格式的脚本autorun_cmd.sh,autorun_cmd.sh脚本的具体内容为：
rtp exec host:D:/pwl_workspace/TestSimRtp.vxe 启动vxworks simulator，查看运行结果，成功自动运行：  -&gt; Executing startup script &#39;host:D:/pwl_workspace/autorun_cmd.sh&#39;... rtp exec host:D:/pwl_workspace/TestSimRtp.vxe Launching process &#39;host:D:/pwl_workspace/TestSimRtp.vxe&#39; ... Process &#39;host:D:/pwl_workspace/TestSimRtp.vxe&#39; (process Id = 0x38d3a890) launched. Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks Done executing startup script &#39;host:D:/pwl_workspace/autorun_cmd.sh&#39;. -&gt; 自动执行方式4 (RTP_APPL_USER)  首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_USER选项：  在INCLUDE_RTP_APPL_USER选项被使能以后，vxworks启动时会调用usrRtpAppInit.c文件中的usrRtpAppInit()函数。我们可以在此函数中加入自己的rtp启动代码：  void usrRtpAppInit (void) { /* TODO - add your own application launch code here */ /* (1) 使用代码调用rtpSpawn()函数来运行TestSimRtp.vxe文件 */ char * vxeName = &#34;host:D:/pwl_workspace/TestSimRtp.vxe&#34;; char * argv[5]; RTP_ID rtpId = NULL; /* set the application&#39;s arguments */ argv[0] = vxeName; argv[1] = NULL; argv[2] = NULL; argv[3] = NULL; argv[4] = NULL; /* Spawn the RTP. No environment variables are passed */ if ((rtpId = rtpSpawn (vxeName, argv, NULL, 220, 0x10000, 0, 0)) == NULL) { printf (&#34;Impossible to start %s application &#34;, vxeName); } } 启动vxworks simulator，查看运行结果，成功自动运行：  -&gt; Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -&gt; ]]></content>
  </entry>
  
  <entry>
    <title>VxBus设备驱动模型</title>
    <url>/post/bsp/vxbus-device-driver-model-in-vxworks.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>vxbus</tag>
      <tag>Device Driver</tag>
    </tags>
    <content type="html"><![CDATA[VxBus是指在VxWorks中用于支持设备驱动的特有的架构，这种架构包含对minimal BSP的支持。
VxBus简介 它包括以下功能:
 允许设备驱动匹配对应设备; 提供驱动程序访问硬件的机制; 软件其他部分访问设备功能; 在VxWorks系统中，实现设备驱动的模块化。  VxBus在总线控制器驱动程序服务的支持下，能在总线上发现设备，并执行一些初始化工作，使驱动与硬件设备之间正常的通讯。
LOCAL struct vxbPlbRegister windmlGraphicsPlbDevRegistration = { { NULL, /* register next driver */ VXB_DEVID_BUSCTRL, /* bus controller */ VXB_BUSID_PLB, /* bus id - PCI Bus Type */ VXB_VER_4_0_0, /* vxBus version Id */ &#34;graphics&#34;, /* drv name */ &amp;windmlvxbFuncs, /* pDrvBusFuncs */ NULL, /* pMethods */ windmlGraphicsProbe, /* probe routine */ NULL /* vxbParams */ } }; LOCAL struct vxbPciRegister windmlGraphicsPciDevRegistration = { /* b */ { (DRIVER_REGISTRATION *)(&amp;windmlGraphicsPlbDevRegistration), /* pNext */ VXB_DEVID_DEVICE, /* devID */ VXB_BUSID_PCI, /* busID = PCI */ VXB_VER_4_0_0, /* vxbVersion */ &#34;graphics&#34;, /* drvName */ &amp;windmlvxbFuncs, /* pDrvBusFuncs */ NULL, /* pMethods */ windmlGraphicsProbe, /* devProbe */ NULL, }, NELEMENTS(windmlPciDevIDList), &amp;windmlPciDevIDList[0], }; 这个结构就是用于描述一个需要注册的驱动。驱动的初始化的入口函数都需要放在windmlvxbFuncs中。
//通过这个数据结构，可以向系统注册一些设备初始化函数 LOCAL struct drvBusFuncs windmlvxbFuncs = { windmlStub, /* devInstanceInit */ windmlStub, /* devInstanceInit2 */ windmlStub /* devConnect */ }; 上述代码中把这些函数都设置为了空。这里对三个初始化阶段函数简单介绍一下。devInstanceInit是在vxworks内核启动之前预初始化时调用，完成的主要是关闭设备的中断。然后内核启动初始化，调用init2，这时候就会完成设备驱动内存的初始化，如果驱动初始过程需要使用内核的一些基础设施，那么都可以放到这时候。devInstanceConnect用于设备的连接，通常可以不使用，但如果它依赖于其他设备，则可以把启动代码放在这里。
另外，还需要注意到的一个就是windmlGraphicsProbe，这是一个设备探测函数，用于探测所有驱动所驱动的设备，并加入到设备列表中。
windmlGraphicsPciDevRegistration 是通过 usrWindMlInit中的vxbDevRegister函数，完成每个被wind media所支持的设备类型的驱动注册。
vxbDevRegister((struct vxbDevRegInfo *)&amp;windmlGraphicsPciDevRegistration); vxbDevRegister((struct vxbDevRegInfo *)&amp;windmlKeyboardDevRegistration); vxbDevRegister((struct vxbDevRegInfo *)&amp;windmlMouseDevRegistration); vxbDevRegister((struct vxbDevRegInfo *)&amp;windmlAudioPciDevRegistration); 然后调用uglODrvInit()；这个函数完成的工作就是创建所有的设备驱动，通过阅读源码就可以知道，其实仅仅是创建了设备节点而已。
]]></content>
  </entry>
  
  <entry>
    <title>确保可靠性、功能安全性和信息安全性 发展电动垂直起降飞行汽车</title>
    <url>/post/news/vxworks-support-development-of-electric-vertical-take-off-and-landing-flying-cars.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>WindRiver</tag>
      <tag>VxWorks 7</tag>
      <tag>Safety</tag>
      <tag>Security</tag>
      <tag>Vehicle</tag>
    </tags>
    <content type="html"><![CDATA[从莱特兄弟首次从基蒂霍克（Kitty Hawk）的沙滩首次成功试飞，到超音速喷气机和高超音速飞行汽车，航空工业稳步发展，创新的步伐前赴后继、波澜壮阔。
多年来，专家们努力进行既有技术改善，同时不断吸收新技术，使航空器有能力应对一个又一个新的飞行挑战。时至今日，最令人兴奋的机会之一是应用电动垂直起降（eVTOL）飞行汽车，实现先进空中交通（AAM，Advanced Air Mobility），支持商业运营和军事任务。
为了更快将先进的eVTOL技术创新成果推向市场，并克服AAM挑战，美国空军推出了一项名为Agility Prime的计划。这项计划支持美国空军开放各种资源，如测试场地和专业知识，以便支持商业eVTOL发展，并将其参与者聚集在一起，确保功能安全和信息安全符合标准。风河公司是航空航天和国防市场的软件解决方案领导者，致力于提供完整软件产品集，支持相关企业推出eVTOL，并拥有经过验证的可靠性和安全性。 eVTOL智能系统平台 高质量eVTOL的核心是一套智能系统平台，其基础是高效、经济且具备功能安全性和信息安全性的软件。人工智能（AI）和机器学习（ML）技术的持续进步将是这一智能系统的关键。eVTOL系统需要一套RTOS，才能支持飞行汽车的快速运行并实现高确定性的功能。eVTOL中还有一些系统可以在Linux等开源软件上运行。
然而，无论该系统的基础是 RTOS  还是通用操作系统，它都必须为交通工具运行提供可靠性、功能安全性和信息安全性。此外，云计算现在是商业、制造、能源、运输系统等所有领域必不可少的一部分。由于云计算结合了AI、ML和5G通信，因此它将在eVTOL飞行数据和控制系统中发挥重要作用。
智能系统平台将成为每一台eVTOL飞行汽车中不可或缺的功能部件基础。其软件应用系统将提供至关重要的AI和ML技术：承担起管理、导航和操作职能，诸如空域冲突化解、辅助导航、飞行安全和航站区域运营等。除了传统的航空电子设备，智能系统平台还将包括车辆、任务和通信管理系统。
电动垂直起降飞行汽车,面临的挑战 为了使eVTOL成为现实中可以真正可靠的基础设施，整个行业必须克服四大技术挑战：设计、开发、功能安全和信息安全。下面，让我们分别探讨一下各项挑战的要点。
设 计 eVTOL制造商正在把越来越多的科技专家和工程人员投入此项工作，他们需要专注于设计和相关技术的运用，以实现安全顺畅的垂直起飞和着陆，并提供最远的飞行距离，这就对体积、重量和功率（SWaP）提出了比以往任何时候都更高的要求。目前来看，虽然增加电池容量可以增加飞行距离，但电池自重又会缩短飞行时间和航程。为了在功率和航程的挑战方面获得设计上的飞跃，一些企业正在考虑将电力与传统发动机相结合，这就是混合动力VTOL（HVTOL）。总体而言，成功的eVTOL设计必须从一开始就充分发挥软件解决方案的能力，解决好航程/续航时间和SWaP挑战。
开 发 智能化的计算系统是现代航空技术的重要组成部分。其开发工作与DevOps密切相关，采用敏捷实践来支持持续集成、新代码编写和已有代码更新。目前的最新进展是采用DevSecOps方法，从一开始就将安全性整合到智能软件平台之中。
eVTOL软件开发人员需要规划系统开发生命周期（SDLC），该生命周期包括：
 调查分析 设计 建构 测试 实施 维护和支持  DevSecOps方法有助于确保开发工作流的安全，确保系统不存在漏洞，同时确保eVTOL在运中的安全性。为了将敏捷软件开发融入eVTOL系统的生产过程，开发人员必须借助于许多软件工具和技术，如虚拟化、容器化、编排、自动化、商用现货（COTS）软件、配置管理工具等。
安 全 eVTOL制造商面临的最重要挑战之一就是安全性。2008年至2018年间，美国国家公路交通安全管理局（NHTSA）的数据显示，乘用车辆平均每行驶1亿英里有一人死亡。从2008年到2017年，在同样的1亿英里内，摩托车的平均死亡人数超过24人。美国联邦航空局的数据显示，在2017财政年度，民用航空死亡事故率为每100000飞行小时0.84起：总共发生了209起民用航空事故，造成了347人死亡。
在进行eVTOL安全设计时，开发人员必须考虑到的主要安全因素包括动力电池、电机/螺旋桨、导航系统、飞行控制系统，以及飞行汽车经常飞越的人口稠密地区。确保交通运输设施安全运行并符合联邦法规，这需要投入大量成本和时间。然而，采用符合安全认证标准的硬件和软件组件，可以加快开发速度，减少资源投入，并最终降低成本。风河公司擅长确保各类产品的安全性，了解安全认证的重要性。而且，针对各类产品风河都可以交付所需的资料，以支持商用和军用环境中的安全性认证手续。
信息安全性 eVTOL系统必须从一开始就规划和构建安全机制以避免潜在的安全性威胁。遵循DevSecOps方法，设备制造商可以创建功能强大、安全性高的系统，具有内置的安全功能，可以在新的网络安全威胁出现时快速、无风险地进行更新。eVTOL系统开发人员应该采用实时操作系统和具有强大安全特性和功能的开放系统软件——特别是虚拟化和容器化技术，必须包含强大的安全功能，以确保系统的可靠运行。
为确保系统开发和运行安全，应在整个产品生命周期内遵循DevSecOps方法进行安全测试。模拟测试可以帮助开发人员创建eVTOL系统的数字孪生并进行安全测试，以了解系统的脆弱性及其影响，从而避免造成实际上的损失。仿真软件可以创建eVTOL的数字孪生模型，以对系统进行持续性评估。eVTOL必须满足基于NIST 800-53、静态机密数据、多级安全和防篡改要求等严格安全标准。
风河在航空航天与国防业界 继往开来 风河公司的软件产品始终伴随着航空航天技术的发展，已有近40年的历史。在VxWorks®实时操作系统（RTOS）中，风河提供了最佳的实时性和确定性技术，广泛应用于火星探测器、波音787梦想飞机、军用喷气机以及多种型号的直升机。许多应用VxWorks的项目都是无人操纵的，其中包括许多军用系统，例如欧洲的nEUROn和美国的MQ-4C Triton。最近，许多eVTOL制造企业都分别为商业和军事应用推出了创新的城市空中交通（UAM）。风河公司的软件产品正在用于这一全新航空领域，与相关合作伙伴携手推进最先进的航空交通系统。
风河公司与他们合作进行垂直起降技术创新，而且其中的软件特别强调可靠性、功能安全性和信息安全性。
风河支持业界迎接挑战 风河软件产品集支持eVTOL开发人员利用风河的虚拟化技术和容器化功能，为车辆和飞行汽车设计出软件定义的体系结构，最终可以构建灵活、可扩展的智能平台。风河软件可以提供有价值的认证，帮助eVTOL制造商满足安全性要求，同时节省时间、资源和成本。风河软件提供了经得起未来考验的开放式体系结构，支持从原型到生产的无缝迁移。
VxWorks ——领先的实时操作系统 VxWorks是风河公司推出多年、经业界广泛验证的RTOS，其强大功能足以支持现代开发方法，用于构建安全、可靠的解决方案。而且，可认证版VxWorks更进一步加快了飞行系统环境中的数据处理能力，并确保在任务关键型部署中的响应性操作。VxWorks支持32位和64位以及多核处理器，包括Intel®、Arm®、Power Architecture®和RISC-V。VxWorks可满足严格的行业标准，如DO-178C、ED-12C、ARINC 653、POSIX®和FACE™，而且可以采用COTS标准和安全性认证依据， 包括DO-178C DAL A, ISO 26262 ASIL D, IEC 62304, and IEC 61508 SIL 3，因此可以极大地降低制造商的采购和认证成本。 此外，VxWorks还支持C11/C++ 17、RISE、LLVM、Python等编程语言和Boost C++库，从而帮助应用程序开发者创建高效、四处可用的应用软件。
DO-178C Certification Ready的货架产品，丰富的适航认证经验，以及在中国本地化的适航认证团队，使得风河公司有能力为用户的适航认证项目提供本地化服务。
Wind River VxWorks 653平台 ——基于开放标准的虚拟化平台 VxWorks 653平台是一个安全、可靠的RTOS，具有FACE达标认证，并提供完全符合ARINC 653规范的虚拟化开放平台，在最新的ARM、Intel和PowerPC等多核处理器平台上具有强大的时间和空间分区能力。通过使用硬件虚拟化辅助的多核调度程序，让VxWorks 653具有高度的功能安全性和信息安全性。VxWorks 653平台提供COTS认证支持资料，可以缩短完成认证所需的时间，同时降低认证流程中的不确定性。它支持强健的开放式体系结构，使供应商能够修改现有认证系统中的的应用软件部件，而只需重新测试被更改的部件，从而显著降低重新认证成本和总体拥有成本（TCO）。VxWorks 653多核版依循RTCA DO-297规范设计，具有独立构建、链接和加载（IBLL）功能，适合多供应商、基于角色的供应链设计，允许应用软件供应商独立进行开发、测试和交付。
Wind River Linux ——专用于关键任务应用的Linux Wind River Linux是一个具备商业级支持的Linux版本，用于嵌入式应用软件、经济高效安全性系统，可接入预构建容器（具有Docker和Kubernetes支持）。它在云原生5G环境中发挥着关键作用，通过创建独立的应用程序包最大限度地提高服务器使用率，这些应用程序包可以在共享一个通用操作系统内核的环境中安装和运行。Wind River Linux通过了FACE认证，符合ISO 9001-2015标准。风河针对新发现的漏洞提供持续的威胁应对措施。风河安全团队持续监控安全漏洞，包括来自政府机构的特定安全通知。此外，Wind River Linux Cyberseurity订阅提供了增强的安全性和网络系统强化功能，Star Lab Titanium security Suite则专门为特定的航空航天应用场景提供支持。Wind River Linux提供了验证社区代码、Wind River Long Term Support（风河长期支持）、Wind River Long Term Maintenance（风河长期维护）和持续交付生命周期服务。
Wind River Helix虚拟化平台 ——以虚拟化实现高度灵活性 Helix平台凝聚了风河公司近40年来在满足航空航天与国防工业严格要求、整合多个虚拟机工作负载、支持容器技术以及使运营商完全虚拟化以及工业控制系统方面的丰富经验。其中的实时嵌入式Type 1 hypervisor支持多种操作系统，提供了足够的安全性、性能和灵活性。Helix平台增强了机载航空系统内的低延迟性能。Helix平台旨在根据航空、汽车和工业安全标准的严格要求取得认证并简化安全关键应用的认证流程。Helix平台中的Hypervisor与操作系统无关，提供在虚拟机内运行任何操作系统的能力，客户操作系统支持领先的嵌入式RTO VxWorks；领先的商用嵌入式Linux操作系统、Wind River Linux（以及其他Linux版本）；Microsoft® Windows®；安卓和其他操作系统。
Wind River Simics ——降低风险且加快上市速度的模拟工具 Simics®通过精准的模拟功能帮助制造商创建高度安全的应用安装，可以检测系统漏洞并简化DevSecOps开发项目。Simics提供了一个模拟环境，通过安全的虚拟硬件测试系统和网络安全保护确保安全受控环境，而且包括用于改进开发过程的协作工具。这个模拟工具允许开发人员将开发环境与物理硬件分离，同时保留在需要时连接物理硬件的能力。Simics虚拟硬件允许开发人员按需访问目标eVTOL系统，支持与开发团队成员的持续集成和自动化测试。通过使用Simics进行模拟，eVTOL设计团队可以测试飞行汽车的系统和操作，以降低风险并缩短上市时间，使飞行汽车做好实用化准备。
Wind River Cloud Platform ——面向边缘云的生产级分布式Kubernetes解决方案 Cloud Platform是用于管理边缘云基础设施的开源、生产级分布式Kubernetes解决方案。Cloud Platform基于OpenStack StarlingX项目，汇集了一流的开源技术，提供了有效部署和管理分布式网络所需的功能。Cloud Platform拥有高度灵活的基础设施，可以根据需要进行扩展。它已经进行了开箱即用的优化，集成了高性能和低延迟Linux内核。其中包括生产就绪的Kubernetes，并允许使用同类最佳的开源解决方案，以避免供应商锁定。它占用存储空间极小，而且是单节点，因此可以进行边缘部署，以支持新的使用场景，例如自主航空、自动驾驶、机器人以及新兴的eVTOL细分市场等领域充满想象的业务。
风河专业服务 ——从架构设计到开发与运营 风河专业服务提供全面的知识和专业技能，帮助客户充分挖掘风河产品的潜力，在创建和集成新技术的过程中大大降低风险、节省时间。风河专业服务提供见解、专业知识和资源，所有这些都是在嵌入式软件行业近四十年的领先地位基础上建立起来的。风河专业服务团队与客户开发团队合作，使他们能够专注于其核心竞争力，并提供市场领先的设备、系统和网络。风河专业服务帮助设计团队将安全、可靠、合规的任务关键型产品推向市场。此外，该团队还提供信息保障（IA）基础，为QorIQ PPC处理器系列中的安全设备提供API。
STAR LAB TITANIUM 安全套件 Star Lab是风河的子公司，提供强化的Linux安全产品，在严苛的环境中保护任务关键型嵌入式系统免受网络安全和防篡改漏洞的影响。Titanium Security Suite专注于局部虚拟化、操作系统强化、安全引导技术和静态数据加密，拥有丰富的专业知识，在为军事系统开发量身定制的安全解决方案方面取得了长期的成功。StarLab团队拥有良好的工程实践经验，在使用环境中从未出现差错，在认证、验证和验证测试中的成功率为100%。所有员工都是获得许可的美国公民，这给了客户对公司及其员工的信心和信任。
结 论 随着电动垂直起降飞行汽车的不断创新发展，eVTOL设计师将面临设计、开发、安全和安保方面的各种挑战。风河凭借其强大的软件产品集，期待与行业、政府和学术界合作，提供智能系统平台，使eVTOL飞行汽车能够可靠、安全、安全地投入运行。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks下Telnet客户端的C语言实现代码</title>
    <url>/post/app/c-code-to-implement-telnet-client-in-vxworks.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Telnet</tag>
    </tags>
    <content type="html"><![CDATA[本文主要分享了VxWorks系统下实现telnet client客户端的C语言代码
telnet client连接过程：  TCP连接telnet server 23端口 NVT扩展自动协商 用户名+密码登录 通过telnet server端命令行交互 退出登录  概述 Telnet 协议是 TCP/IP 协议族中应用最广泛的协议。
它允许用户(Telnet 客户端)通过一个协商过程来与一个远程设备进行通信。
Telnet 协议是基于网络虚拟终端 NVT(Network Virtual Termina1)的实现，NVT 是虚拟设备，连接双方(客户机和服务器)都必须把它们的物理终端和 NVT 进行相互转换。
操作协商 只要客户机或服务器要发送命令序列而不是数据流，它就在数据流中插入一个特殊的保留字符，该保留字符叫做“解释为命令”（IAC ，Interpret As Command) 字符。当接收方在一个入数据流中发现 IAC 字符时，它就把后继的字节处理为一个命令序列。
双方在进行Telnet连接时，要进行选项协商。
比如：使用字符方式、窗口的大小，终端的类型都要进行协商。而协商是通过TELNET所支持的命令来实现的。
协商完成，telnet server才返回登录信息，否则无法登录。
本文协商过程通过程序的一个函数实现自动化。
VxWorks下telnet client实现代码   #include &#34;string.h&#34;#include &#34;stdio.h&#34;#include &#34;vxWorks.h&#34;#include &#34;sockLib.h&#34;//#include &#34;telnetLib.h&#34; #include &#34;inetLib.h&#34;#include &#34;stdioLib.h&#34;#include &#34;strLib.h&#34;#include &#34;hostLib.h&#34;#include &#34;ioLib.h&#34; // telnet server 地址及端口 #define TELNET_SERVER_NAME &#34;172.18.101.193&#34; #define TELNET_SERVER_PORT 23  // telnet NVT扩展选项协商，常用命令定义，命令与数值的对应关系 #define DO &#39;\xFD&#39; #define WONT &#39;\xFC&#39; #define WILL &#39;\xFB&#39; #define DONT &#39;\xFE&#39; #define IAC &#39;\xFF&#39; #define SB &#39;\xFA&#39; #define SE &#39;\xF0&#39; #define CMD_WINDOW_SIZE 31  // 定义缓冲buffer长度，最大message长度，字符串最大长度 #define BUFFER_SIZE 20480 #define MAX_MSG_LENGTH 20480 #define STRING_MAX_SIZE 20480  // 全局变量 char go_string[STRING_MAX_SIZE]; char dealed_string[STRING_MAX_SIZE]; char back_string[STRING_MAX_SIZE]; // TCP client 主动连接：输入TCP服务端地址和端口，返回client_socket int tcp_client_conn(char *server_name, int port) { struct sockaddr_in server_addr; int client_socket; /*创建套接字*/ client_socket = socket(AF_INET, SOCK_STREAM, 0); if (client_socket &lt; 0) { printf(&#34;Create Socket Failed! \n&#34;); return -1; } // 填充server地址信息  bzero((char *)&amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; if (((server_addr.sin_addr.s_addr = inet_addr(server_name)) == ERROR) &amp;&amp; ((server_addr.sin_addr.s_addr = hostGetByName(server_name)) == ERROR)) { printf(&#34;Get Server Address Error! \n&#34;); return -1; } server_addr.sin_port = htons(port); server_addr.sin_len = sizeof(server_addr); /* connect to server */ if (connect(client_socket, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)) == ERROR) { printf(&#34;Connet to Server Error! \n&#34;); return -1; } return client_socket; } // 连接telnet server，自动协商过程 void negotiate(int client_socket) { char buffer[BUFFER_SIZE]; int count = 0; while (1) { bzero(buffer, BUFFER_SIZE); // 读一个字节  if (recv(client_socket, buffer, 1, 0) &lt; 0) { printf(&#34;Receive Data Failed! \n&#34;); return; } if (buffer[0] == IAC) { // read 2 more bytes  if (recv(client_socket, buffer + 1, 2, 0) &lt; 0) { printf(&#34;Receive Data Failed! \n&#34;); return; } // TAC协商窗口大小  if (buffer[1] == DO &amp;&amp; buffer[2] == CMD_WINDOW_SIZE) { char tmp1[10] = {IAC, WILL, CMD_WINDOW_SIZE}; if (send(client_socket, tmp1, 3, 0) &lt; 0) { printf(&#34;Send Data Failed! \n&#34;); return; } char tmp2[10] = {IAC, SB, CMD_WINDOW_SIZE, 0, 80, 0, 24, IAC, SE}; if (send(client_socket, tmp2, 9, 0) &lt; 0) { printf(&#34;Send Data Failed! \n&#34;); return; } continue; } // 处理一个IAC协商命令  int i; for (i = 0; i &lt; 3; i++) { if (buffer[i] == DO) { buffer[i] = WONT; } else if (buffer[i] == WILL) { buffer[i] = DO; } } if (send(client_socket, buffer, 3, 0) &lt; 0) { printf(&#34;Send Data Failed! \n&#34;); return; } } //结束循环条件，IAC协商结束  if (buffer[0] == &#39;\n&#39;) { count += 1; } if (count == 2) { break; } } } // TCP client 接收服务端返回的数据 void tcp_client_receive_data(int client_socket) { char receive_buffer[BUFFER_SIZE]; int length; // 接受服务器返回的状态信息  bzero(receive_buffer, BUFFER_SIZE); if ((length = recv(client_socket, receive_buffer, MAX_MSG_LENGTH, 0)) == ERROR) { printf(&#34;Client Recieve Data Failed! \n&#34;); return; } bzero(back_string, STRING_MAX_SIZE); strncpy(back_string, receive_buffer, (strlen(receive_buffer) &gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(receive_buffer))); printf(&#34;receive data from equipment: %s \n&#34;, back_string); } // TCP client 发送处理后的数据到目标TCP void tcp_client_send_data(int client_socket) { char send_buffer[BUFFER_SIZE]; /* send request to server */ bzero(send_buffer, BUFFER_SIZE); strncpy(send_buffer, dealed_string, strlen(dealed_string)); // buffer发送长度+1，目的带上&#39;\0&#39;结束符，strlen()函数读取到&#39;\0&#39;结束  int ret = send(client_socket, send_buffer, (strlen(send_buffer) + 1), 0); if (ret == ERROR) { printf(&#34;Send Data to Server Error! \n&#34;); return; } printf(&#34;send data to equipment: %s \n&#34;, send_buffer); } // telnet操作，命令数据处理 void telnet_deal_data(char *go_string, char *dealed_string) { bzero(dealed_string, STRING_MAX_SIZE); strncpy(dealed_string, go_string, (strlen(go_string) &gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(go_string))); // 命令结尾增加\n  dealed_string[strlen(dealed_string)] = &#39;\n&#39;; } // telnet登录，输入用户名，接收password void telnet_login_receive_password(int telnet_socket) { // recv当次接收的数据长度  int filled = 0; // recv接收的全部数据的长度  int length = 0; char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); // telnet登录：输入用户名后，接收全部返回数据  // 网络环境不同，执行情况不同，全部数据有可能一次接收到，也有可能两次才能全部接收到  while (1) { if ((filled = recv(telnet_socket, buffer + length, MAX_MSG_LENGTH, 0)) == ERROR) { printf(&#34;Accept Data Failed! \n&#34;); return; } length += filled; // 判断是否全部接收完返回数据  // 接收完全部数据，结束循环，即结束接收数据  if (buffer[length - 2 &lt; 0 ? 0 : length - 2] == &#39;:&#39;) { break; } } bzero(back_string, STRING_MAX_SIZE); strncpy(back_string, buffer, (strlen(buffer) &gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(buffer))); printf(&#34;receive data from equipment: %s \n&#34;, buffer); } // telnet 登录成功，接收telnet server返回数据 // 环境不同，执行情况也会不同，全部数据可能一次接收完，也可能两次接收完，或者三次接收完 int telnet_login_whether_success_receive_data(int telnet_socket) { // 登录成功接收三次数据，telnet server连续三次send  // recv单次接收字节流长度filled  int filled = 0; // recv接收的全部数据的长度length  int length = 0; // telnet server 是否登录成功  int whether; char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); while (1) { if ((filled = recv(telnet_socket, buffer + length, MAX_MSG_LENGTH, 0)) == ERROR) { printf(&#34;Accept Data Failed! \n&#34;); return -1; } length += filled; // 判断是否全部接收完返回数据  // 数据结尾部分：[xxxx@localhost ~]$  if (buffer[length - 3 &lt; 0 ? 0 : length - 3] == &#39;]&#39;) { // 接收完全部数据，结束接收  // 收到登录成功的全部数据，whether=1  whether = 1; break; } if (buffer[length - 2 &lt; 0 ? 0 : length - 2] == &#39;:&#39;) { // 接收完全部数据，结束接收  // 收到登录失败的全部数据，whether=0  whether = 0; break; } // 只接收最后一次send的全部数据  // bzero(buffer, BUFFER_SIZE);  } bzero(back_string, STRING_MAX_SIZE); strncpy(back_string, buffer, (strlen(buffer) &gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(buffer))); printf(&#34;receive data from equipment: %s \n&#34;, buffer); return whether; } // telnet发送命令到telnet server，命令结尾必须带&#39;\n&#39; void send_cmd(int telnet_socket, char *cmd) { char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); strncpy(buffer, cmd, (strlen(cmd) &gt; BUFFER_SIZE ? BUFFER_SIZE : strlen(cmd))); if (send(telnet_socket, buffer, (strlen(buffer) + 1), 0) &lt; 0) { printf(&#34;Send cmd Failed! \n&#34;); return; } } // telnet login 登录到server void telnet_login(int telnet_socket) { // 是否登录成功，用户名和密码是否正确  int whether; // localhost login:  tcp_client_receive_data(telnet_socket); while (1) { // 控制端的用户名  strcpy(go_string, &#34;username&#34;); telnet_deal_data(go_string, dealed_string); tcp_client_send_data(telnet_socket); // calos@Password:  telnet_login_receive_password(telnet_socket); // 控制端的密码  strcpy(go_string, &#34;password&#34;); telnet_deal_data(go_string, dealed_string); tcp_client_send_data(telnet_socket); // 判断是否登录成功  whether = telnet_login_whether_success_receive_data(telnet_socket); if (whether) { // 登录成功 [xxxx@localhost ~]$  break; } // 登录失败，继续登录  } } // telnet返回数据处理，telnet server有时候一次返回全部数据，有时候两次甚至多次返回全部数据 void telnet_receive_data_add_deal(int telnet_socket) { char receive_buffer[BUFFER_SIZE]; // 做数据处理的temp_buffer  char temp_buffer[BUFFER_SIZE]; // 第一次出现某字符的位置location=&amp;receive_buffer+字符的偏移地址  char *location; // 第一次出现某字符的偏移地址  int location_number; // 当次recv数据的长度  int filled = 0; // recv全部数据的长度  int length = 0; // 循环接收全部的返回数据  bzero(receive_buffer, BUFFER_SIZE); while (1) { // 接受telnet server返回数据  if ((filled = recv(telnet_socket, receive_buffer + length, MAX_MSG_LENGTH, 0)) == ERROR) { printf(&#34;Client Recieve Data Failed! \n&#34;); return; } length += filled; // 判断telnet server返回数据是否全部收到  if (receive_buffer[length - 3 &lt; 0 ? 0 : length - 3] == &#39;]&#39;) { break; } } // 只取第二次返回数据，针对一次性接收完数据的，需要去除第一次send的数据  // 第一次send的数据：xxxx\r\n  location = strchr(receive_buffer, &#39;\n&#39;); // 计算偏移地址  location_number = location - receive_buffer + 1; bzero(temp_buffer, BUFFER_SIZE); strncpy(temp_buffer, receive_buffer + location_number, BUFFER_SIZE); bzero(receive_buffer, BUFFER_SIZE); strncpy(receive_buffer, temp_buffer, BUFFER_SIZE); bzero(back_string, STRING_MAX_SIZE); strncpy(back_string, receive_buffer, (strlen(receive_buffer) &gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(receive_buffer))); printf(&#34;receive data from equipment: %s \n&#34;, back_string); } // 当前设备操作结束条件：控制端输入END，结束当前设备操作 int finish_equipment_operation(int sock) { char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); strncpy(buffer, go_string, (strlen(go_string) &gt; BUFFER_SIZE ? BUFFER_SIZE : strlen(go_string))); if (strcmp(buffer, &#34;END&#34;) == 0) { close(sock); return 1; } else { return 0; } } int main(void) { int telnet_socket = tcp_client_conn(TELNET_SERVER_NAME, TELNET_SERVER_PORT); if (telnet_socket &lt; 0) { return -1; } // telnet 自动协商  negotiate(telnet_socket); // 登录  telnet_login(telnet_socket); //命令回显  while (1) { // 输入需要执行的命令到go_string  strcpy(go_string, &#34;ll&#34;); telnet_deal_data(go_string, dealed_string); send_cmd(telnet_socket, dealed_string); telnet_receive_data_add_deal(telnet_socket); // 设备操作结束条件  if (finish_equipment_operation(telnet_socket)) { break; } } // 异常退出，关闭socket  close(telnet_socket); return 0; } ]]></content>
  </entry>
  
  <entry>
    <title>PCI总线在VxWorks中的实现</title>
    <url>/post/bsp/pci-bus-implementation-in-vxworks.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>pci</tag>
    </tags>
    <content type="html"><![CDATA[在最近发布的BSP中，风河公司基本上都提供了对PCI BUS的支持，本文主要探讨PCI BUS在VxWorks系统中的实现。
PCI Address Space and Memory Mapping PCI BUS有三种地址空间：IO Space、Memory Space and Configuration Space。每个PCI设备都通过Configuration Space中的Base Address Registers(BAR)映射到内存或者IO空间，这样就不用像ISA BUS那样，通过硬件Jumpers来设置板卡的Address。PCI BUS的所有配置基本上都是通过Configuration Space的寄存器来控制的。但是，每个PCI Device都必须先配置才能使用，这意味着PCI Device的基地址和中断都必须被系统分配到资源，并且PCI Device能够对正常的PCI配置操作做出回应。
WRS提供一个名为pciConfigLib.c的标准库给用户访问PCI配置空间，该标准库使用PCI规范中定义的访问机制1和机制2来支持Host-Bridge，风河本身提供的第三个访问机制，名为机制0是针对非标准PCI Bridge的，机制0主要是靠调用BSP包中的特定routine来实现PCI配置空间的read/write的，与此同时，这些特定的routine接口和前面的介绍的机制1和机制2是相同的。pciConfigLib.c提供访问PCI配置空间内任何寄存器的routine，该库同样提供一些用于扫描PCI BUS寻找特定PCI 设备实例的方法，另外该库也提供一些简单的配置接口用于配置简单的PCI设备。
PCI Interrupt Handling PCI 规范并没有详细说明PCI中断信号是如何路由到中断控制器的。每个PCI设备都有4个可用的中断PIN，分别命名为A,B,C和D。每个单功能的PCI设备都被要求使用中断PIN A来产生中断，而对于多功能PCI设备，每个功能使用一个中断PIN，但是根据PCI规范，每个PCI设备最多可提供8个功能，这样就必须两个功能共用一个中断PIN。当产生PCI中断时，PCI中断处理系统需要调用多个中断服务程序，那么最简单的方法就是每个ISR都调用一遍，ISR必须有能力判断该次中断源是否是自己产生的，如果不是，则立即返回，并接着会调用下一个中断服务程序。
pciIntLib.c提供一些routine来挂接多个ISR到一个中断LINE上，该库通过挂接一个特殊的ISR，该ISR会遍历一个中断链表，所有共用同一个中断的ISRs都被放在这个链表中。pciIntConnect()用于将设备的ISR挂接到中断链表上，而pciIntDisConnect()用于删除中断链表上的一个ISR。
例子：
pciInitConnect(Vector, ISR1, PARAM1); pciInitConnect(Vector, ISR2, PARAM2); pciInitConnect(Vector, ISR3, PARAM3);   上面3个语句把ISR1，ISR2,和ISR3分别挂接到中断向量为Vector的链表intList里面，那么当中断发生时，会执行下面一个函数：
void sISR(void) { while(intList-&gt;next !=NULL) { (*intList-&gt;INT_ISR)(PARAM);/*分别调用ISR1，ISR2，ISR3，没写很具体，只是个大概理解*/ } } VxWorks中的PCI 配置策略 在BSP中，必须定义宏INCLUDE_PCI来支持PCI BUS，宏PCI_CFG_TYPE必须定义为一下几种类型：
静态配置：PCI_CFG_FORCE 这种方式要求程序员必须手动通过数据表、配置宏或者其他方法来配置每个PCI设备，PCI设备的基地址和使用的中断号必须事先知道。
动态配置：PCI_CFG_AUTO 这种配置方法是最常用的，它通过扫描PCI总线并且给每一个found的设备赋予独立的内存或者IO地址，这也是典型的X86 BIOS的PCI初始化方式。程序员并不需要事先知道分配给PCI设备的系统资源，这个功能主要被实现在pciAutoConfigLib.c模块中。
未配置：PCI_CFG_NONE 这种方法主要是预留给那些不能使用上面的VxWorks配置方法的设备的。此时，所有的PCI设备都是在VxWorks内核启动之前配置好的，这种方法的困难在于VxWorks内核并没有在扫描过程中系统分配给PCI设备的资源信息，如果此时启用MMU，则在使用PCI设备之前，必须把PCI设备使用的地址动态映射到MMU。
PCI Initialization Sequences 当VxWorks内核起来之后，PCI设备的第一次使用都是必须在调用sysHwInit2()例程之后。但是由于MMU内存映射的初始化和激活是在例程sysHwInit()和sysHwInit2()之间的，所以推荐的PCI初始化顺序为：
 sysHwInit()	默认的MMU table entries相当于将本地事务映射为PCI事务的HOST-Bridge的访问侧 sysHwInit2()	在该例程中，程序员必须静态配置所有的PCI设备，或者调用动态配置routine pciAutoConfig()  设备驱动程序初始化 传统的VxWorks的设备驱动模型一般都会设备创建routine called xxxDevCreate()，一般该routine都以设备的基地址和中断号做为参数。对于PCI设备，这种方式只适合于PCI_CFG_FORCE 配置策略，对于其他两种的配置策略，在编译阶段并不知道设备的基地址和中断号，这种情况下，在系统配置PCI设备完毕后，必须首先访问PCI配置空间获取相关的信息并传递给Device Driver。如果Drivers是针对于某些PCI设备的，那么Drivers通过设备的配置地址而不是内存或者IO地址来指定设备也是合乎情理的，但是PCI设备的配置地址并不是绝对和永恒不变的。
如果程序员使用总线号、设备号和功能号来定位地址的话，是可能会出现问题的，因为BIOS在扫描PCI BUS的过程中，会自动给BUS编号。例如某个设备的编号为（2，5，0）可能会由于通过PCI-PCI桥来扩展或者移除PCI设备而变为（1，5，0）。
PCI Device Driver的初始化应该是通过访问设备的配置空间来获取地址和其他对控制设备来说是必须的信息。如果这些信息已成功获取，那么PCI Device Driver的初始化就和以往一样了。在正常的设备操作过程中，不应该去访问PCI的配置空间。现在大多数PCI设备都把配置空间和其他寄存器都映射到内存空间，一般说来，访问Memory or IO Space比配置空间更加高效。
Dynamic MMU Mapping 和VME总线的模型一样，PCI主从访问必须根据标准的宏来操作，这些宏定义了BUS之间的对应关系。一般使用3个宏定义来描述两个总线之间的对应关系。
PCI Master Access Windows 第一个为host side的地址，采用宏PCI_XXX_LOCAL来定义，第二个为remote side 的地址，采用宏PCI_XXX_BUS来定义，第三个为描述内存大小的宏，采用PCI_XXX_SIZE来定义。可以通过设定PCI_XXX_SIZE宏为0来禁止相关的映射。
针对普通的Host-Bridge，从内存映射的角度看，有三种常用的映射方式：第一种为把本地内存访问映射为PCI IO访问，第二种把本地的内存访问映射为PCI MEMIO访问，这种方式是不可以prefectchable的，第三种是把本地的内存访问映射为PCI MEM 访问，这种方式可以prefectchable。由于主桥没有完整的详细规范，因此映射方式还不止这些，也有使用PCI-IACK signaling这种映射方式的。
The following is a typical excerpt from config.h in a typical PCI capable BSP: /* Master window allows CPU to access PCI I/O addresses */ #define PCI_MSTR_IO_LOCAL 0xC0000000 #define PCI_MSTR_IO_BUS 0x00000000 #define PCI_MSTR_IO_SIZE 0x00010000  /* Master window allows CPU to access PCI Memory addresses (prefetch) */ #define PCI_MSTR_MEM_LOCAL 0x80000000 #define PCI_MSTR_MEM_BUS 0x00000000 #define PCI_MSTR_MEM_SIZE 0x01000000  /* Master window allows CPU to access PCI Memory (non-prefetch) */ #define PCI_MSTR_MEMIO_LOCAL 0x82000000 #define PCI_MSTR_MEMIO_BUS 0x00000000 #define PCI_MSTR_MEMIO_SIZE 0x01000000  /* Master window allows CPU to generate PCI_IACK cycles */ #define PCI_MSTR_IACK_LOCAL 0x8e000000 #define PCI_MSTR_IACK_BUS 0x0e000000  #define PCI_MSTR_IACK_SIZE 0x100 PCI中有三种地址空间：IO空间，配置空间，MEM空间。MEM和MEMIO并不是不同的地址空间，而是不同的总线操作，MEMIO是单纯的寄存器读写，而MEM访问会被翻译成该操作的CACHE类型，CACHE类型指明内存是否提前读取，写数据时是否采用CACHE的“write and invalidate”操作，其实这些都是考虑到CACHE数据完整性的问题。PCI规范并没有详细说明主桥如何把MEM访问映射为PCI总线事务，这是和特定主桥硬件相关的，需要参考主桥的相关手册。
为了访问特定的PCI内存位置，CPU必须该内存位置映射到本地的哪一个地址了，CPU操作都是使用本地地址，而不是设备的PCI地址。把PCI地址转换为本地地址的公式如下：
Local Addr = PCI addr + (PCI_MSTR_XXX_LOCAL - PCI_MSTR_XXX_BUS) For example:
#define PCI_MEM2LOCAL(x) \ ((int)(x) + PCI_MSTR_MEM_LOCAL - PCI_MSTR_MEM_BUS) #define PCI_MEMIO2LOCAL(x) \ ((int)(x) + PCI_MSTR_MEMIO_LOCAL - PCI_MSTR_MEMIO_BUS) #define PCI_IO2LOCAL(x) \ ((int)(x) + PCI_MSTR_IO_LOCAL - PCI_MSTR_IO_BUS) PCI Slave Window 上面描述的都是主设备侧的映射方式，使用这些映射方式的主控器都是CPU，Slave Window是被总线上其他设备发起总线事务的目标设备，Slave Window千差万别，但是几乎所有的设备都有至少一种Slave Window来使本地地址对其他PCI设备例如DMA总线主控器或者CPU是可访问的。
/* * Slave window that makes local memory visible to PCI * devices */ PCI_SLV_MEM_LOCAL /* Local address of window */ PCI_SLV_MEM_BUS /* PCI Bus address of window */ PCI_SLV_MEM_SIZE /* window size,0 means disabled */ /* * For X86 it is possible to have a slave window mapping * PCI IO to Local IO */ PCI_SLV_IO_LOCAL /* Local address of window */ PCI_SLV_IO_BUS /* PCI Bus address of window */ PCI_SLV_IO_SIZE /* window size,0 means disabled */ 对于X86机器，Slave Window将会把PCI IO事务映射为本地总线的IO请求。为了传递一个内存地址给Remote端设备，本地地址必须被翻译为相应的PCI地址，计算本地地址翻译为PCI地址的公式如下：
PCI addr = Local Addr + (PCI_SLV_XXX_BUS - PCI_SLV_XXX_LOCAL)
例如：
#define LOCAL2PCI_MEM(x) \ ((x) + PCI_SLV_MEM_BUS - PCI_SLV_MEM_LOCAL) ]]></content>
  </entry>
  
  <entry>
    <title>T1042/T2080 VxWorks7 开发笔记</title>
    <url>/post/bsp/vxworks-7-for-t1042-t2080-how-to.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks 7</tag>
      <tag>PowerPC</tag>
      <tag>T1042</tag>
      <tag>T2080</tag>
    </tags>
    <content type="html"><![CDATA[ VxWorks 7  是WindRiver推出的新一代版本，相比较VxWorks 6.9特别是驱动部分有很大的改变，VxWorks 7和Linux很像，有设备树的概念，所以从Linux移植驱动到VxWorks 7会方便很多。
 新建VSB工程 新建VIP工程，编译生成vxworks 使用库里的dts文件替换bsp里面的dts文件 网络加载vxworks，可以启动但是没有shell  为解决此问题，添加shell组件，rebuild 工程
VxWorks7 启动，有shell
不支持CMD命令
查看注册的设备驱动
-&gt; vxbDrvShow Driver [fslBookeTimer] class [vxbFdtBus] [freescale booke timer driver] (0x2934e4) (refs: 1) Driver [genericPhy] class [vxbMiiBus] [Generic 10/100/1000 PHY driver] (0x294090) (refs: 3) Driver [sgmiiPhy] class [vxbMiiBus] [Freescale SGMII PHY driver] (0x2940e8) (refs: 0) Driver [mmdPhy] class [vxbMiiBus] [Clause 45 MMD PHY driver] (0x29414c) (refs: 4) Driver [memacMdio] class [vxbFdtBus] [Freescale MEMAC MDIO driver] (0x2941c0) (refs: 8) Driver [memac] class [vxbFdtBus] [Freescale MEMAC END driver] (0x2942c0) (refs: 6) Driver [QorIQQman] class [vxbFdtBus] [Freescale QorIQQman driver] (0x294328) (refs: 1) Driver [fsl,qman-portal] class [vxbFdtBus] [Freescale QorIQQman Portal driver] (0x294378) (refs: 18) Driver [QorIQFman] class [vxbFdtBus] [Freescale QorIQFman driver] (0x294420) (refs: 1) Driver [QorIQBman] class [vxbFdtBus] [Freescale QorIQBman driver] (0x294450) (refs: 1) Driver [fsl,bman-portal] class [vxbFdtBus] [Freescale QorIQBman Portal driver] (0x2944a0) (refs: 18) Driver [qoriqClock] class [vxbFdtBus] [Freescale QorIQ clock driver] (0x294c98) (refs: 1) Driver [qoriqL3Cache] class [vxbFdtBus] [QorIQ L3 cache driver] (0x294cb8) (refs: 1) Driver [coreNetL2Cache] class [vxbFdtBus] [CORENET L2 cache driver] (0x294cf8) (refs: 1) Driver [qoriqFpga] class [vxbFdtBus] [Freescale QorIQ FPGA driver] (0x294d30) (refs: 1) Driver [qoriqLaw] class [vxbFdtBus] [Freescale Integrated LAW Controller] (0x294d98) (refs: 1) Driver [pcib] class [vxbPciBus] [PCI generic bridge driver] (0x295340) (refs: 0) Driver [mainbus] class [root] [Freescale T2080QDS] (0x295470) (refs: 1) Driver [mpic] class [vxbFdtBus] [interrupt controller driver] (0x295570) (refs: 1) Driver [fdtBus] class [vxbNexusBus] [FDT bus controller] (0x295590) (refs: 1) Driver [simpleBus] class [vxbFdtBus] [simple bus controller] (0x295644) (refs: 4) Driver [ns16550] class [vxbFdtBus] [ns16550 serial OF driver] (0x29568c) (refs: 2) value = 83 = 0x53 = &#39;S&#39; -&gt; vxbDevShow mainbus-0 at root nexus level(0) mainbus-0: &lt;Freescale T2080QDS&gt; fdtBus-0 (refs: 9) on mainbus0 (refs: 2) fdtBus-0: &lt;FDT bus controller&gt; (0x2008e4c0) level(1) fslBookeTimer-0 (refs: 0) on fdtBus0 (refs: 9) fslBookeTimer-0: &lt;freescale booke timer driver&gt; (0x2008e550) level(2) simpleBus-0 (refs: 18) on fdtBus0 (refs: 9) simpleBus-0: &lt;simple bus controller&gt; (0x2008e700) level(2) fsl,bman-portal-0 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-0: &lt;Freescale QorIQBman Portal driver&gt; (0x2008ea50) level(3) fsl,bman-portal-1 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-1: &lt;Freescale QorIQBman Portal driver&gt; (0x2008ece0) level(3) fsl,bman-portal-2 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-2: &lt;Freescale QorIQBman Portal driver&gt; (0x2008ef70) level(3) fsl,bman-portal-3 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-3: &lt;Freescale QorIQBman Portal driver&gt; (0x2008f200) level(3) fsl,bman-portal-4 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-4: &lt;Freescale QorIQBman Portal driver&gt; (0x2008f490) level(3) fsl,bman-portal-5 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-5: &lt;Freescale QorIQBman Portal driver&gt; (0x2008f720) level(3) fsl,bman-portal-6 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-6: &lt;Freescale QorIQBman Portal driver&gt; (0x2008f9b0) level(3) fsl,bman-portal-7 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-7: &lt;Freescale QorIQBman Portal driver&gt; (0x2008fc40) level(3) fsl,bman-portal-8 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-8: &lt;Freescale QorIQBman Portal driver&gt; (0x2008fed0) level(3) fsl,bman-portal-9 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-9: &lt;Freescale QorIQBman Portal driver&gt; (0x20090160) level(3) fsl,bman-portal-10 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-10: &lt;Freescale QorIQBman Portal driver&gt; (0x200903f0) level(3) fsl,bman-portal-11 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-11: &lt;Freescale QorIQBman Portal driver&gt; (0x20090680) level(3) fsl,bman-portal-12 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-12: &lt;Freescale QorIQBman Portal driver&gt; (0x20090910) level(3) fsl,bman-portal-13 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-13: &lt;Freescale QorIQBman Portal driver&gt; (0x20090ba0) level(3) fsl,bman-portal-14 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-14: &lt;Freescale QorIQBman Portal driver&gt; (0x20090e30) level(3) fsl,bman-portal-15 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-15: &lt;Freescale QorIQBman Portal driver&gt; (0x200910c0) level(3) fsl,bman-portal-16 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-16: &lt;Freescale QorIQBman Portal driver&gt; (0x20091350) level(3) fsl,bman-portal-17 (refs: 0) on simpleBus0 (refs: 18) fsl,bman-portal-17: &lt;Freescale QorIQBman Portal driver&gt; (0x200915e0) level(3) simpleBus-1 (refs: 18) on fdtBus0 (refs: 9) simpleBus-1: &lt;simple bus controller&gt; (0x20091670) level(2) fsl,qman-portal-0 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-0: &lt;Freescale QorIQQman Portal driver&gt; (0x200919c0) level(3) fsl,qman-portal-1 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-1: &lt;Freescale QorIQQman Portal driver&gt; (0x20091c80) level(3) fsl,qman-portal-2 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-2: &lt;Freescale QorIQQman Portal driver&gt; (0x20091f40) level(3) fsl,qman-portal-3 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-3: &lt;Freescale QorIQQman Portal driver&gt; (0x20092200) level(3) fsl,qman-portal-4 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-4: &lt;Freescale QorIQQman Portal driver&gt; (0x200924c0) level(3) fsl,qman-portal-5 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-5: &lt;Freescale QorIQQman Portal driver&gt; (0x20092780) level(3) fsl,qman-portal-6 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-6: &lt;Freescale QorIQQman Portal driver&gt; (0x20092a40) level(3) fsl,qman-portal-7 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-7: &lt;Freescale QorIQQman Portal driver&gt; (0x20092d00) level(3) fsl,qman-portal-8 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-8: &lt;Freescale QorIQQman Portal driver&gt; (0x20092fc0) level(3) fsl,qman-portal-9 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-9: &lt;Freescale QorIQQman Portal driver&gt; (0x20093280) level(3) fsl,qman-portal-10 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-10: &lt;Freescale QorIQQman Portal driver&gt; (0x20093540) level(3) fsl,qman-portal-11 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-11: &lt;Freescale QorIQQman Portal driver&gt; (0x20093800) level(3) fsl,qman-portal-12 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-12: &lt;Freescale QorIQQman Portal driver&gt; (0x20093ac0) level(3) fsl,qman-portal-13 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-13: &lt;Freescale QorIQQman Portal driver&gt; (0x20093d80) level(3) fsl,qman-portal-14 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-14: &lt;Freescale QorIQQman Portal driver&gt; (0x20094040) level(3) fsl,qman-portal-15 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-15: &lt;Freescale QorIQQman Portal driver&gt; (0x20094300) level(3) fsl,qman-portal-16 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-16: &lt;Freescale QorIQQman Portal driver&gt; (0x200945c0) level(3) fsl,qman-portal-17 (refs: 0) on simpleBus1 (refs: 18) fsl,qman-portal-17: &lt;Freescale QorIQQman Portal driver&gt; (0x20094880) level(3) simpleBus-2 (refs: 1) on fdtBus0 (refs: 9) simpleBus-2: &lt;simple bus controller&gt; (0x20094940) level(2) qoriqFpga-0 (refs: 0) on simpleBus2 (refs: 1) qoriqFpga-0: &lt;Freescale QorIQ FPGA driver&gt; (0x20094c10) level(3) simpleBus-3 (refs: 29) on fdtBus0 (refs: 9) simpleBus-3: &lt;simple bus controller&gt; (0x20094ca0) level(2) coreNetL2Cache-0 (refs: 0) on simpleBus3 (refs: 29) coreNetL2Cache-0: &lt;CORENET L2 cache driver&gt; (0x20094f10) level(3) qoriqL3Cache-0 (refs: 0) on simpleBus3 (refs: 29) qoriqL3Cache-0: &lt;QorIQ L3 cache driver&gt; (0x20095180) level(3) qoriqLaw-0 (refs: 0) on simpleBus3 (refs: 29) qoriqLaw-0: &lt;Freescale Integrated LAW Controller&gt; (0x20095370) level(3) qoriqClock-0 (refs: 0) on simpleBus3 (refs: 29) qoriqClock-0: &lt;Freescale QorIQ clock driver&gt; (0x200a14e0) level(3) i2c-0 (refs: 0) on simpleBus3 (refs: 29) i2c-0: &lt;(no driver attached)&gt; (0x200a2160) level(3) QorIQQman-0 (refs: 0) on simpleBus3 (refs: 29) QorIQQman-0: &lt;Freescale QorIQQman driver&gt; (0x200a2360) level(3) QorIQBman-0 (refs: 0) on simpleBus3 (refs: 29) QorIQBman-0: &lt;Freescale QorIQBman driver&gt; (0x200bd400) level(3) QorIQFman-0 (refs: 14) on simpleBus3 (refs: 29) QorIQFman-0: &lt;Freescale QorIQFman driver&gt; (0x200be640) level(3) memac-0 (refs: 0) on QorIQFman0 (refs: 14) memac-0: &lt;Freescale MEMAC END driver&gt; (0x200bfdc0) level(4) memac-1 (refs: 0) on QorIQFman0 (refs: 14) memac-1: &lt;Freescale MEMAC END driver&gt; (0x202ecb10) level(4) memacMdio-0 (refs: 3) on QorIQFman0 (refs: 14) memacMdio-0: &lt;Freescale MEMAC MDIO driver&gt; (0x20519790) level(4) genericPhy-0 (refs: 0) on memacMdio0 (refs: 3) genericPhy-0: &lt;Generic 10/100/1000 PHY driver&gt; (0x20519af0) level(5) genericPhy-1 (refs: 0) on memacMdio0 (refs: 3) genericPhy-1: &lt;Generic 10/100/1000 PHY driver&gt; (0x20519cf0) level(5) genericPhy-2 (refs: 0) on memacMdio0 (refs: 3) genericPhy-2: &lt;Generic 10/100/1000 PHY driver&gt; (0x20519e90) level(5) memac-2 (refs: 0) on QorIQFman0 (refs: 14) memac-2: &lt;Freescale MEMAC END driver&gt; (0x2051a030) level(4) memacMdio-1 (refs: 1) on QorIQFman0 (refs: 14) memacMdio-1: &lt;Freescale MEMAC MDIO driver&gt; (0x20f93010) level(4) mmdPhy-0 (refs: 0) on memacMdio1 (refs: 1) mmdPhy-0: &lt;Clause 45 MMD PHY driver&gt; (0x20f93370) level(5) memac-3 (refs: 0) on QorIQFman0 (refs: 14) memac-3: &lt;Freescale MEMAC END driver&gt; (0x20f934d0) level(4) memacMdio-2 (refs: 1) on QorIQFman0 (refs: 14) memacMdio-2: &lt;Freescale MEMAC MDIO driver&gt; (0x21a0c510) level(4) mmdPhy-1 (refs: 0) on memacMdio2 (refs: 1) mmdPhy-1: &lt;Clause 45 MMD PHY driver&gt; (0x21a0c830) level(5) memac-4 (refs: 0) on QorIQFman0 (refs: 14) memac-4: &lt;Freescale MEMAC END driver&gt; (0x21a0c990) level(4) memacMdio-3 (refs: 1) on QorIQFman0 (refs: 14) memacMdio-3: &lt;Freescale MEMAC MDIO driver&gt; (0x22b48490) level(4) mmdPhy-2 (refs: 0) on memacMdio3 (refs: 1) mmdPhy-2: &lt;Clause 45 MMD PHY driver&gt; (0x22b487b0) level(5) memac-5 (refs: 0) on QorIQFman0 (refs: 14) memac-5: &lt;Freescale MEMAC END driver&gt; (0x22b48910) level(4) memacMdio-4 (refs: 1) on QorIQFman0 (refs: 14) memacMdio-4: &lt;Freescale MEMAC MDIO driver&gt; (0x22b48d60) level(4) mmdPhy-3 (refs: 0) on memacMdio4 (refs: 1) mmdPhy-3: &lt;Clause 45 MMD PHY driver&gt; (0x2344d540) level(5) memacMdio-5 (refs: 0) on QorIQFman0 (refs: 14) memacMdio-5: &lt;Freescale MEMAC MDIO driver&gt; (0x2344d6a0) level(4) memacMdio-6 (refs: 0) on QorIQFman0 (refs: 14) memacMdio-6: &lt;Freescale MEMAC MDIO driver&gt; (0x2344d9a0) level(4) memacMdio-7 (refs: 0) on QorIQFman0 (refs: 14) memacMdio-7: &lt;Freescale MEMAC MDIO driver&gt; (0x2344dcd0) level(4) spi-0 (refs: 0) on simpleBus3 (refs: 29) spi-0: &lt;(no driver attached)&gt; (0x21cf9f40) level(3) usbphy-0 (refs: 0) on simpleBus3 (refs: 29) usbphy-0: &lt;(no driver attached)&gt; (0x21cfa0c0) level(3) usbphy-1 (refs: 0) on simpleBus3 (refs: 29) usbphy-1: &lt;(no driver attached)&gt; (0x21cfa240) level(3) usb0-0 (refs: 0) on simpleBus3 (refs: 29) usb0-0: &lt;(no driver attached)&gt; (0x21cfa420) level(3) usb1-0 (refs: 0) on simpleBus3 (refs: 29) usb1-0: &lt;(no driver attached)&gt; (0x21cfa600) level(3) sdhc-0 (refs: 0) on simpleBus3 (refs: 29) sdhc-0: &lt;(no driver attached)&gt; (0x21cfa7e0) level(3) mpic-0 (refs: 0) on simpleBus3 (refs: 29) mpic-0: &lt;interrupt controller driver&gt; (0x21cfa960) level(3) pic-timer-0 (refs: 0) on simpleBus3 (refs: 29) pic-timer-0: &lt;(no driver attached)&gt; (0x21cfad40) level(3) msi-0 (refs: 0) on simpleBus3 (refs: 29) msi-0: &lt;(no driver attached)&gt; (0x21cfb720) level(3) msi-1 (refs: 0) on simpleBus3 (refs: 29) msi-1: &lt;(no driver attached)&gt; (0x21cfc100) level(3) msi-2 (refs: 0) on simpleBus3 (refs: 29) msi-2: &lt;(no driver attached)&gt; (0x21cfcae0) level(3) msi-3 (refs: 0) on simpleBus3 (refs: 29) msi-3: &lt;(no driver attached)&gt; (0x21cfd4c0) level(3) pic-timer-1 (refs: 0) on simpleBus3 (refs: 29) pic-timer-1: &lt;(no driver attached)&gt; (0x21cfd840) level(3) global-utilities-0 (refs: 0) on simpleBus3 (refs: 29) global-utilities-0: &lt;(no driver attached)&gt; (0x21cfd9c0) level(3) rcpm-0 (refs: 0) on simpleBus3 (refs: 29) rcpm-0: &lt;(no driver attached)&gt; (0x21cfdb40) level(3) ns16550-0 (refs: 0) on simpleBus3 (refs: 29) ns16550-0: &lt;ns16550 serial OF driver&gt; (0x21cfdd40) level(3) ns16550-1 (refs: 0) on simpleBus3 (refs: 29) ns16550-1: &lt;ns16550 serial OF driver&gt; (0x21d01bf0) level(3) dma-0 (refs: 0) on simpleBus3 (refs: 29) dma-0: &lt;(no driver attached)&gt; (0x21d02580) level(3) dma-1 (refs: 0) on simpleBus3 (refs: 29) dma-1: &lt;(no driver attached)&gt; (0x21d02700) level(3) sata-0 (refs: 0) on simpleBus3 (refs: 29) sata-0: &lt;(no driver attached)&gt; (0x21d02900) level(3) sata-1 (refs: 0) on simpleBus3 (refs: 29) sata-1: &lt;(no driver attached)&gt; (0x21d02b00) level(3) pcie-0 (refs: 0) on fdtBus0 (refs: 9) pcie-0: &lt;(no driver attached)&gt; (0x21d02b60) level(2) pcie-1 (refs: 0) on fdtBus0 (refs: 9) pcie-1: &lt;(no driver attached)&gt; (0x21d02d60) level(2) pcie-2 (refs: 0) on fdtBus0 (refs: 9) pcie-2: &lt;(no driver attached)&gt; (0x21d02f60) level(2) pcie-3 (refs: 0) on fdtBus0 (refs: 9) pcie-3: &lt;(no driver attached)&gt; (0x21d03160) level(2) virtBus-0 (refs: 0) on mainbus0 (refs: 2) virtBus-0: &lt;(no driver attached)&gt; (0x21d03360) level(1) value = 567292768 = 0x21d03360 = &#39;&#39; 本章节主要讲解如何根据组件或根据设备树查找对应的驱动
网口驱动设备树
&amp;fman0 { ethernet@f0000 { compatible = &#34;fsl,fman-memac&#34;; reg = &lt;0xf0000 0x1000&gt;; }; mdio@f1000 { #address-cells = &lt;1&gt;;  #size-cells = &lt;0&gt;;  compatible = &#34;fsl,fman-memac-tbi&#34;; reg = &lt;0xf1000 0x1000&gt;; }; MAC名称为fman-memac，在内核组件查询memac
可以看到这里的phy ，mdio，mac驱动都找到了，点击获取更加详详细的信息
用search 查询具体的驱动文件
网口驱动目录所在路径
查看串口对应驱动
serial0: serial@11c500 { cell-index = &lt;0&gt;; device_type = &#34;serial&#34;; compatible = &#34;fsl,ns16550&#34;, &#34;ns16550&#34;; reg = &lt;0x11c500 0x100&gt;; clocks = &lt;&amp;platform 1&gt;; clock-names = &#34;platform-div2&#34;; interrupts = &lt;36 2 0 0&gt;; interrupt-parent = &lt;&amp;mpic&gt;; }; serial1: serial@11c600 { cell-index = &lt;1&gt;; device_type = &#34;serial&#34;; compatible = &#34;fsl,ns16550&#34;, &#34;ns16550&#34;; reg = &lt;0x11c600 0x100&gt;; clocks = &lt;&amp;platform 1&gt;; clock-names = &#34;platform-div2&#34;; interrupts = &lt;36 2 0 0&gt;; interrupt-parent = &lt;&amp;mpic&gt;; }; Component DRV_SIO_FDT_NS16550 { NAME UART support for ns16550-compatible FDT devices SYNOPSIS ns16550 SIO support for FDT device MODULES vxbNs16550Sio.o vxbFdtNs16550Sio.o LINK_SYMS vxbFdtNs16550Drv REQUIRES DRV_BUS_FDT_ROOT \  INCLUDE_ISR_DEFER \  INCLUDE_SIO _CHILDREN FOLDER_DRIVERS } shell中不同于以往版本的几个命令
vxbDevShowPaths Note: the &#34;original&#34; path uses the name of the device before a driver is bound. This is the path that must be used when blacklisting devices for the hypervisor mainbus-0 at root nexus mainbus-0: &lt;Freescale T2080QDS&gt; fdtBus0: current path: &#39;/mainbus0/fdtBus0&#39; fslBookeTimer0: current path: &#39;/mainbus0/fdtBus0/fslBookeTimer0&#39; original path: &#39;/mainbus0/fdtBus0/timer0&#39; simpleBus0: current path: &#39;/mainbus0/fdtBus0/simpleBus0&#39; original path: &#39;/mainbus0/fdtBus0/bman-portals0&#39; fsl,bman-portal0: current path: &#39;/mainbus0/fdtBus0/simpleBus0/fsl,bman-portal0&#39; original path: &#39;/mainbus0/fdtBus0/simpleBus0/bman-portal0&#39; fsl,bman-portal1: current path: &#39;/mainbus0/fdtBus0/simpleBus0/fsl,bman-portal1&#39; original path: &#39;/mainbus0/fdtBus0/simpleBus0/bman-portal0&#39; fsl,bman-portal2: current path: &#39;/mainbus0/fdtBus0/simpleBus0/fsl,bman-portal2&#39; original path: &#39;/mainbus0/fdtBus0/simpleBus0/bman-portal0&#39; fsl,bman-portal3: current path: &#39;/mainbus0/fdtBus0/simpleBus0/fsl,bman-portal3&#39; original path: &#39;/mainbus0/fdtBus0/simpleBus0/bman-portal0&#39; fsl,bman-portal4: vxbDrvShow Driver [eeprom] class [vxbFdtBus] [At24 eeprom] (0x2f815c) (refs: 0) Driver [i2c] class [vxbFdtBus] [Freescale Integrated I2C Controller] (0x2f8194) (refs: 1) Driver [rtc] class [vxbFdtBus] [Dallas rtc] (0x2f81f4) (refs: 1) Driver [fslBookeTimer] class [vxbFdtBus] [freescale booke timer driver] (0x2fdb04) (refs: 1) Driver [genericPhy] class [vxbMiiBus] [Generic 10/100/1000 PHY driver] (0x2fe778) (refs: 3) Driver [sgmiiPhy] class [vxbMiiBus] [Freescale SGMII PHY driver] (0x2fe7d0) (refs: 0) Driver [mmdPhy] class [vxbMiiBus] [Clause 45 MMD PHY driver] (0x2fe834) (refs: 4) Driver [memacMdio] class [vxbFdtBus] [Freescale MEMAC MDIO driver] (0x2fe8a8) (refs: 8) Driver [memac] class [vxbFdtBus] [Freescale MEMAC END driver] (0x2fe9a8) (refs: 6) Driver [QorIQQman] class [vxbFdtBus] [Freescale QorIQQman driver] (0x2fea10) (refs: 1) Driver [fsl,qman-portal] class [vxbFdtBus] [Freescale QorIQQman Portal driver] (0x2fea60) (refs: 18) Driver [QorIQFman] class [vxbFdtBus] [Freescale QorIQFman driver] (0x2feb08) (refs: 1) Driver [QorIQBman] class [vxbFdtBus] [Freescale QorIQBman driver] (0x2feb38) (refs: 1) Driver [fsl,bman-portal] class [vxbFdtBus] [Freescale QorIQBman Portal driver] (0x2feb88) (refs: 18) Driver [qoriqClock] class [vxbFdtBus] [Freescale QorIQ clock driver] (0x2ff384) (refs: 1) Driver [qoriqL3Cache] class [vxbFdtBus] [QorIQ L3 cache driver] (0x2ff3a4) (refs: 1) Driver [coreNetL2Cache] class [vxbFdtBus] [CORENET L2 cache driver] (0x2ff3e4) (refs: 1) Driver [qoriqFpga] class [vxbFdtBus] [Freescale QorIQ FPGwA driver] (0x2ff41c) (refs: 1) Driver [qoriqLaw] class [vxbFdtBus] [Freescale Integrated LAW Controller] (0x2ff484) (refs: 1) Driver [fslSdhc] class [vxbFdtBus] [freescale SDHC driver] (0x2ff52c) (refs: 1) Driver [usbRootHub] class [vxbUsbRootHub] [USB Root Hub Driver] (0x2ffb08) (refs: 0) Driver [usbDev] class [vxbUsbBus] [usb device driver] (0x2ffb50) (refs: 0) Driver [usbCompDev] class [vxbUsbBus] [usb composite device driver] (0x2ffb70) (refs: 0) Driver [ulpiViewPortPhy] class [vxbFdtBus] [USB ULPI ViewPort PHY FDT Driver] (0x2ffc9c) VxWorks7 的启动过程
]]></content>
  </entry>
  
  <entry>
    <title>IMX6Q 运行 VxWorks 7.0 系统</title>
    <url>/post/bsp/vxworks-7.0-on-IMX6Q.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks 7</tag>
      <tag>IMX6Q</tag>
    </tags>
    <content type="html"><![CDATA[本文简要概述了如何在IMX6Q上从uboot下载并启动VxWorks 7.0的过程。
U-Boot 2015.04 (Jan 01 2017 - 22:35:22) CPU: Freescale i.MX6Q rev1.5 at 792 MHz CPU: Temperature 51 C Reset cause: POR Board: LYS-IMX6Q I2C: ready DRAM: 1 GiB MMC: FSL_SDHC: 0, FSL_SDHC: 1, FSL_SDHC: 2 No panel detected: default to Hannstar-XGA Display: Hannstar-XGA (1024x768) In: serial Out: serial Err: serial switch to partitions #0, OK mmc2(part 0) is current device Net: FEC [PRIME] Normal Boot Hit any key to stop autoboot: 0 =&gt; =&gt; =&gt; tftp 10100000 vxworks.bin Using FEC device TFTP from server 192.168.0.106; our IP address is 192.168.0.3 Filename &#39;vxworks.bin&#39;. Load address: 0x10100000 Loading: T ################################################################# ################################################################# ################################################################# ################################################################# ################################################################# ################################################################# ################################################################# # 617.2 KiB/s done Bytes transferred = 6679780 (65ece4 hex) =&gt; go 10100000 ## Starting application at 0x10100000 ... Target Name: vxTarget _________ _________ \77777777\  /77777777/ \77777777\  /77777777/ \77777777\  /77777777/ \77777777\  /77777777/ \77777777\  \7777777/ \77777777\  \77777/ VxWorks 7 \77777777\  \777/ \77777777\  \7/ Core Kernel version: 1.2.0.1 \77777777\  - Build date: May 10 2018 23:37:28 \77777777\  \7777777/ Copyright Wind River Systems, Inc. \77777/ - 1984-2018 \777/ /7\  \7/ /777\  - ------- Board: LYS-IMX6Q i.MX6Q Processor - ARMv7 OS Memory Size: 2048MB ED&amp;R Policy Mode: Deployed Application Mode Agent: Not started Stop Mode Agent: Not started Adding 14023 symbols for standalone. -&gt; -&gt; devs drv name 0 /null 1 /tyCo/0 1 /tyCo/1 1 /tyCo/2 1 /tyCo/3 2 /vxbus 9 /input/event 12 host: 13 /dev/fb0 14 /dev/galcore 10 /audio/0 value = 25 = 0x19 -&gt; -&gt; Instantiating /sd1:2 as rawFs, device = 0x30001 -&gt; Instantiating /mmc2:2 as rawFs, device = 0xa0001 -&gt; -&gt; devs drv name 0 /null 1 /tyCo/0 1 /tyCo/1 1 /tyCo/2 1 /tyCo/3 2 /vxbus 9 /input/event 12 host: 13 /dev/fb0 14 /dev/galcore 10 /audio/0 4 /sd1:1 5 /sd1:2 4 /sd0:1 4 /mmc2:1 5 /mmc2:2 value = 25 = 0x19 -&gt; -&gt; -&gt; cd &#34;/sd0:1&#34; value = 0 = 0x0 -&gt; -&gt; ll drwxrwxrwx 1 0 0 4096 Mar 8 2018 System Volume Information/ -rwxrwxrwx 1 0 0 12514633 Nov 26 2012 RAMDISK.GZ -rwxrwxrwx 1 0 0 14811136 Nov 26 2012 UBI.IMG -rwxrwxrwx 1 0 0 234896 Dec 4 2012 U-BOOT.IMG -rwxrwxrwx 1 0 0 3245384 Dec 27 2012 uImage -rwxrwxrwx 1 0 0 36079 Dec 4 2012 MLO value = 0 = 0x0 -&gt; -&gt; -&gt; -&gt; ipAttach 0,&#34;gei&#34; value = 0 = 0x0 -&gt; -&gt; ifconfig lo0 Link type:Local loopback inet 127.0.0.1 mask 255.255.255.255 inet6 unicast fe80::1%lo0 prefixlen 64 automatic inet6 unicast ::1 prefixlen 128 UP RUNNING LOOPBACK MULTICAST NOARP ALLMULTI MTU:1500 metric:1 VR:0 ifindex:1 RX packets:0 mcast:0 errors:0 dropped:0 TX packets:0 mcast:0 errors:0 collisions:0 unsupported proto:0 RX bytes:0 TX bytes:0 enet0 Link type:Ethernet HWaddr 00:04:9f:b1:b2:b3 capabilities: VLAN_MTU inet 192.168.0.3 mask 255.255.255.0 broadcast 192.168.0.255 inet6 unicast fe80::204:9fff:feb1:b2b3%enet0 prefixlen 64 automatic UP RUNNING SIMPLEX BROADCAST MULTICAST MTU:1500 metric:1 VR:0 ifindex:2 RX packets:353 mcast:0 errors:0 dropped:4 TX packets:30 mcast:5 errors:0 collisions:0 unsupported proto:0 RX bytes:21366 (21 k) TX bytes:1920 gei0 Link type:Ethernet HWaddr 00:1b:21:75:26:d7 capabilities: TXCSUM TX6CSUM VLAN_MTU VLAN_TXHWTAG VLAN_RXHWTAG SIMPLEX BROADCAST MULTICAST MTU:1500 metric:1 VR:0 ifindex:3 RX packets:0 mcast:0 errors:0 dropped:0 TX packets:0 mcast:0 errors:0 collisions:0 unsupported proto:0 RX bytes:0 TX bytes:0 value = 0 = 0x0 -&gt; -&gt; ifconfig &#34;gei0 192.168.0.230 up&#34; value = 0 = 0x0 -&gt; -&gt; ifconfig lo0 Link type:Local loopback inet 127.0.0.1 mask 255.255.255.255 inet6 unicast fe80::1%lo0 prefixlen 64 automatic inet6 unicast ::1 prefixlen 128 UP RUNNING LOOPBACK MULTICAST NOARP ALLMULTI MTU:1500 metric:1 VR:0 ifindex:1 RX packets:0 mcast:0 errors:0 dropped:0 TX packets:0 mcast:0 errors:0 collisions:0 unsupported proto:0 RX bytes:0 TX bytes:0 enet0 Link type:Ethernet HWaddr 00:04:9f:b1:b2:b3 capabilities: VLAN_MTU inet 192.168.0.3 mask 255.255.255.0 broadcast 192.168.0.255 inet6 unicast fe80::204:9fff:feb1:b2b3%enet0 prefixlen 64 automatic UP RUNNING SIMPLEX BROADCAST MULTICAST MTU:1500 metric:1 VR:0 ifindex:2 RX packets:376 mcast:0 errors:0 dropped:4 TX packets:31 mcast:5 errors:0 collisions:0 unsupported proto:0 RX bytes:22746 (22 k) TX bytes:1980 gei0 Link type:Ethernet HWaddr 00:1b:21:75:26:d7 capabilities: TXCSUM TX6CSUM VLAN_MTU VLAN_TXHWTAG VLAN_RXHWTAG inet 192.168.0.230 mask 255.255.255.0 broadcast 192.168.0.255 inet6 unicast fe80::21b:21ff:fe75:26d7%gei0 prefixlen 64 tentative automatic UP RUNNING SIMPLEX BROADCAST MULTICAST MTU:1500 metric:1 VR:0 ifindex:3 RX packets:0 mcast:0 errors:0 dropped:0 TX packets:3 mcast:2 errors:0 collisions:0 unsupported proto:0 RX bytes:0 TX bytes:210 value = 0 = 0x0 -&gt; -&gt; ifconfig &#34;enet0 down&#34; value = 0 = 0x0 -&gt; -&gt; ifconfig lo0 Link type:Local loopback inet 127.0.0.1 mask 255.255.255.255 inet6 unicast fe80::1%lo0 prefixlen 64 automatic inet6 unicast ::1 prefixlen 128 UP RUNNING LOOPBACK MULTICAST NOARP ALLMULTI MTU:1500 metric:1 VR:0 ifindex:1 RX packets:0 mcast:0 errors:0 dropped:0 TX packets:0 mcast:0 errors:0 collisions:0 unsupported proto:0 RX bytes:0 TX bytes:0 enet0 Link type:Ethernet HWaddr 00:04:9f:b1:b2:b3 capabilities: VLAN_MTU inet 192.168.0.3 mask 255.255.255.0 broadcast 192.168.0.255 SIMPLEX BROADCAST MULTICAST MTU:1500 metric:1 VR:0 ifindex:2 RX packets:411 mcast:0 errors:0 dropped:25 TX packets:34 mcast:7 errors:0 collisions:0 unsupported proto:0 RX bytes:24868 (24 k) TX bytes:2220 gei0 Link type:Ethernet HWaddr 00:1b:21:75:26:d7 capabilities: TXCSUM TX6CSUM VLAN_MTU VLAN_TXHWTAG VLAN_RXHWTAG inet 192.168.0.230 mask 255.255.255.0 broadcast 192.168.0.255 inet6 unicast fe80::21b:21ff:fe75:26d7%gei0 prefixlen 64 tentative automatic UP SIMPLEX BROADCAST MULTICAST MTU:1500 metric:1 VR:0 ifindex:3 RX packets:0 mcast:0 errors:0 dropped:0 TX packets:12 mcast:11 errors:0 collisions:0 unsupported proto:0 RX bytes:0 TX bytes:900 value = 0 = 0x0 -&gt; -&gt; -&gt; ifconfig lo0 Link type:Local loopback inet 127.0.0.1 mask 255.255.255.255 inet6 unicast fe80::1%lo0 prefixlen 64 automatic inet6 unicast ::1 prefixlen 128 UP RUNNING LOOPBACK MULTICAST NOARP ALLMULTI MTU:1500 metric:1 VR:0 ifindex:1 RX packets:0 mcast:0 errors:0 dropped:0 TX packets:0 mcast:0 errors:0 collisions:0 unsupported proto:0 RX bytes:0 TX bytes:0 enet0 Link type:Ethernet HWaddr 00:04:9f:b1:b2:b3 capabilities: VLAN_MTU inet 192.168.0.3 mask 255.255.255.0 broadcast 192.168.0.255 SIMPLEX BROADCAST MULTICAST MTU:1500 metric:1 VR:0 ifindex:2 RX packets:536 mcast:0 errors:0 dropped:150 TX packets:34 mcast:7 errors:0 collisions:0 unsupported proto:0 RX bytes:32412 (32 k) TX bytes:2220 gei0 Link type:Ethernet HWaddr 00:1b:21:75:26:d7 capabilities: TXCSUM TX6CSUM VLAN_MTU VLAN_TXHWTAG VLAN_RXHWTAG inet 192.168.0.230 mask 255.255.255.0 broadcast 192.168.0.255 inet6 unicast fe80::21b:21ff:fe75:26d7%gei0 prefixlen 64 automatic UP RUNNING SIMPLEX BROADCAST MULTICAST MTU:1500 metric:1 VR:0 ifindex:3 RX packets:68 mcast:1 errors:0 dropped:61 TX packets:81 mcast:71 errors:0 collisions:0 unsupported proto:0 RX bytes:7687 TX bytes:6360 value = 0 = 0x0 -&gt; ]]></content>
  </entry>
  
  <entry>
    <title>风河携手Synopsys促安全性提升</title>
    <url>/post/news/wind-river-and-synopsys-cowork-to-enhance-security.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>WindRiver</tag>
      <tag>Synopsys</tag>
      <tag>5G</tag>
      <tag>AI</tag>
      <tag>ML</tag>
    </tags>
    <content type="html"><![CDATA[随着企业客户对于业务创新速度及敏捷性诉求的不断提升，云化、容器化应用大行其道。Gartner预测，到2023年，70%的企业将在生产中运行三个或更多的容器化应用软件。一个真正意义上的云原生时代已经到来。
日前，Synopsys（新思科技）基于风河最新版本 Wind River Studio  ，推出了Coverity静态分析解决方案，成为Wind River Studio生态系统首批主要合作伙伴的一员。那么，Coverity静态分析解决方案具备哪些能力特点？其为Wind River Studio云原生平台而言带来哪些价值？
促云原生安全性提升 Coverity作为一款与安全性相关的服务，主要致力于对应用进行代码级的分析，其本身是一款非常成熟的产品，至今已经拥有超过15年的分析引擎优化经验。
一个软件的质量及安全性怎样？功能是否完备？运行过程中会不会崩溃？对于客户来说，这是非常关键的问题。但其实软件的缺陷往往在开发的过程中就形成了。那么，在产品推向市场之前如何进行质量及安全性的检验？而Coverity的立足点就是通过测试确保软件质量及安全性，并且覆盖软件的全生命周期。
据官方资料介绍，Synopsys 推出的Coverity静态分析解决方案可以为Wind River Studio平台上的软件应用提供静态应用安全测试服务，它擅长深入的过程间分析、全程序分析，而且误报率非常低。具有分析全面、准确度高、速度快和具有良好的行业标准合规性等特点。
强化关键云原生平台定位 Wind River Studio是风河打造的云原生平台。一如风河软件以往面向关键基础设施，注重稳健性、高可靠性的特点风格，Wind River Studio主要面向于关键任务智能系统的开发、部署、运作和服务。
多年来风河的优势一直集中于软件层面，特别是在物联网操作系统领域一直都在承担着基础性的支撑作用。对于生态伙伴而言，Wind River Studio云原生平台的优势主要体现在两个方面。这两个方面也成为吸引生态伙伴入驻的关键。
一是Wind River Studio具有强大技术优势。借助风河多年来在基础设施及物联网操作系统领域积累的优势，Wind River Studio云原生平台定位于关键任务领域的智能系统开发、部署、运作和服务，并在该领域拥有领先优势。实时操作系统VxWorks如今已经成为Wind River Studio云原生平台的一部分。而Wind River Studio最新版本则可以提供颠覆性的自动化技术。
二是Wind River Studio可为生态伙伴提供全生命周期支持。Wind River Studio云原生平台作为一个稳健、可靠的基础性支撑平台，最新版本能够支持智能系统完整生命周期服务。
值得一提的是，Synopsys是Wind River Studio的首批主要合作伙伴之一。对于Wind River Studio云原生平台而言，Coverity加盟生态系统意味着能够极大地提高平台的生产率、灵活性和应用上市速度，同时实现了无缝技术集成，包括远端边缘云计算、数据分析、系统级安全、5G和AI/ML。同时，平台生态系统也将会逐步走向发展壮大。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks 7.0下基于VxBus的定时器子系统</title>
    <url>/post/app/timer-design-based-on-vxbus-in-vxworks-7-0.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks 7.0</tag>
      <tag>VxBus</tag>
    </tags>
    <content type="html"><![CDATA[最近研究了一下VxWorks 7.0下基于vxbus的定时器子系统，方便我们在需要使用定时器中断的时候引用，开发过程中的一点体会记录下来，如果由理解不对或者不全面的望批评指正，谢谢。
开发平台为zynq7Z020,该处理器由三个全局的定时器，分别是globaltimer，ttc_0，ttc_1，其中全局定时器用作系统的脉搏，是整个操作系统的ticks定时器，其可通过内核配置完成，具体如下：
而ttc_0会作为系统的AUX clock在初始化的时候完成匹配，系统使用SPY命令时启用定时器，所以，如果要使用TTC0作为应用，要考虑spy调试对其影响，TTC_1可以作为用户自定义定时器使用，挂接用户中断服务例程。其设备树配置如下：
globaltimer: globaltimer@f8f00200 { compatible = &#34;arm,cortex-a9-gtc&#34;; reg = ; clock-frequency = ; interrupts = ; interrupt-parent = &lt;&amp;intc&gt;; }; ttc_0: ps7-ttc@f8001000 { compatible = &#34;xlnx,zynq7k-ttc&#34;; reg = ; clock-frequency = ; interrupt-parent = &lt;&amp;intc&gt;; interrupts = ; }; ttc_1: ps7-ttc@f8002000 { compatible = &#34;xlnx,zynq7k-ttc&#34;; reg = ; clock-frequency = ; interrupt-parent = &lt;&amp;intc&gt;; interrupts = ; }; 系统在对vxbus子系统初始化时调用每个驱动的fdtZynqTimerAttach函数，在这个函数中对定时器进行初始化相关操作，同时挂接几个重要的回调函数
pTimerFunc-&gt;timerAllocate = zynqTimerAllocate; pTimerFunc-&gt;timerRelease = zynqTimerRelease; pTimerFunc-&gt;timerRolloverGet = zynqTimerRolloverGet; pTimerFunc-&gt;timerCountGet = zynqTimerCountGet; pTimerFunc-&gt;timerDisable = zynqTimerDisable; pTimerFunc-&gt;timerEnable = zynqTimerEnable; pTimerFunc-&gt;timerISRSet = zynqTimerISRSet; 最后调用 vxbTimerRegister (pTimerFunc);将定时器注册到定时器子系统，可以通过vxbTimerShow查看，针对此开发驱动，需要做一下工作：
第一：在定时器子系统中查找一个没有使用的，而且最适合自己的定时器使用，返回定时器的句柄。
LOCAL struct vxbTimerFunctionality * usrTimerInit(int timerNo) { struct vxbTimerFunctionality *pTimer = NULL; if(timerNo &gt;= TTC_TIMER_SUM) return NULL; pTimer = vxbTimerEval(usrTimer[timerNo].timerEvalFunc); //printf(&#34;timer( point = %08x %s:%d)\n&#34;,pTimer,pTimer-&gt;timerName,pTimer-&gt;timerNo); 	//pTimer1 = TIMERFUNC_TO_TIMERDATA (pTimer); 	//printf(&#34;pTimer1 = %08x allocated = %d\n&#34;,pTimer1,pTimer1-&gt;timerFunc.allocated); 	if(pTimer == NULL) return NULL; pTimer-&gt;timerRelease(pTimer); //printf(&#34;ptimer = %08x\n&#34;,pTimer); 	if ((pTimer-&gt;timerAllocate(pTimer,pTimer-&gt;features &amp; VXB_TIMER_AUTO_RELOAD)) != OK) { printf(&#34;####callocate timer failed\n&#34;, 0, 1, 2, 3, 4, 5); return NULL; } return pTimer; } 第二：根据找到的句柄，初始化定时器，挂接中断服务例程
LOCAL STATUS usrTimerIntConnect(struct vxbTimerFunctionality *pTimer,FUNCPTR routine,_Vx_usr_arg_t arg) { ZYNQ_TIMER * pTimer1; //printf(&#34;pTimer3 = %08x \n&#34;,pTimer); 	if (pTimer == NULL) return ERROR; //pTimer1 = TIMERFUNC_TO_TIMERDATA (pTimer); 	//printf(&#34;pTimer2 = %08x allocated = %d\n&#34;,pTimer1,pTimer1-&gt;timerFunc.allocated); 	if (pTimer-&gt;timerISRSet (pTimer, (void(*)(_Vx_usr_arg_t))routine,arg) != OK) return ERROR; return (OK); } 第三：设置定时器的中断周期
LOCAL STATUS usrTimerClkRateSet(struct vxbTimerFunctionality *pTimer,int ticksPerSecond) { if (pTimer == NULL) return ERROR; if ( ((UINT)ticksPerSecond &lt; usrTtc0MinFreq) || ((UINT)ticksPerSecond &gt; usrTtc0MaxFreq) ) return (ERROR); if (pTimer-&gt;ticksPerSecond != (UINT)ticksPerSecond) { pTimer-&gt;ticksPerSecond = ticksPerSecond; usrTimerDisable (pTimer); usrTimerEnable (pTimer); } return (OK); } 第四：使能定时器中断
LOCAL void usrTimerEnable(struct vxbTimerFunctionality *pTimer) { #ifndef	_WRS_CONFIG_SMP  int key; #endif	/* !_WRS_CONFIG_SMP */ /* check if timer is available */ if (pTimer == NULL) return; #ifndef	_WRS_CONFIG_SMP 	key = intCpuLock (); #endif	/* !_WRS_CONFIG_SMP */	if(!vxbSmpClkRuning) { if (pTimer-&gt;timerEnable (pTimer,(pTimer-&gt;clkFrequency /pTimer-&gt;ticksPerSecond)) != OK) { #ifndef	_WRS_CONFIG_SMP 	intCpuUnlock (key); #endif	/* !_WRS_CONFIG_SMP */	return; } vxbSmpClkRuning = TRUE; } #ifndef	_WRS_CONFIG_SMP 	intCpuUnlock (key); #endif	/* !_WRS_CONFIG_SMP */} 通过以上四步可以实现定时器的初始化及使用。
]]></content>
  </entry>
  
  <entry>
    <title>WindRiver WindML 5.3显示图片程序</title>
    <url>/post/app/how-to-display-photos-with-windml-5.3.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>WindML 5.3</tag>
    </tags>
    <content type="html"><![CDATA[WindRiver的 WindML5.3  里默认已经支持JPG和PNG的图片格式了
包含这两个option后，App里就可以直接打开相应的图片文件 - uglImageReadFile()
这个函数可以把输入的文件转换为DIB，然后就可以随意使用这个位图了。或者直接转换为DBD，更便于显示。闲言少续，上代码
#include &lt;stdio.h&gt;#include &lt;ugl/ugl.h&gt; void testUglImage(char *name, UINT32 x, UINT32 y) { UGL_REG_DATA *pRegData; UGL_GC_ID gc; UGL_DDB_ID myDdbId; UGL_IMAGE *pImage; if(NULL == name) return; uglDisplayOpen(NULL, NULL, NULL); pRegData = uglRegistryFind(UGL_DISPLAY_TYPE, NULL, NULL, NULL); gc = uglGcCreate((UGL_DEVICE_ID)pRegData-&gt;id); pImage = uglImageReadFile(name, IMAGE_OBJECT_DDB, UGL_NULL, (UGL_DEVICE_ID)pRegData-&gt;id, UGL_NULL); if(UGL_NULL != pImage) { myDdbId = (UGL_DDB_ID)(pImage-&gt;pObject); if(UGL_NULL != myDdbId) { uglBitmapBlt(gc, myDdbId, 0, 0, myDdbId-&gt;width-1, myDdbId-&gt;height-1, UGL_DISPLAY_ID, x, y); uglImageFree(pImage); } } #if 0/* 退出图形 */ uglGcDestroy(gc); uglDisplayClose(NULL); #endif  return; } 这段代码的作用就是把文件转换为DBD，然后贴到屏幕上，看效果
有些低版本WindML，还不支持PNG，那可以把高版本的这个libpng移植过去，毕竟WindRiver用的就是开源的
]]></content>
  </entry>
  
  <entry>
    <title>U-boot和VxWorks 7的集成</title>
    <url>/post/bsp/u-boot-on-vxworks-7.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks 7</tag>
      <tag>uboot</tag>
    </tags>
    <content type="html"><![CDATA[ VxWorks  是美国风河公司制作的一个实时操作系统， U-Boot  是一个广为人知的通用启动加载器，它是嵌入式系统加电后运行的最早的代码。U-Boot通常被用于嵌入式系统，比如PowerPC或者ARM设备，这些设备上没有X86的BIOS。
介绍 尽管VxWorks可以有它自己的bootloader(VxWorks Bootrom或者Bootapp)，U-Boot具有更多的功能，如果硬件板子已经提供了U-Boot的支持，那我们更有道理去直接使用它。
U-boot : http://www.denx.de/wiki/U-Boot/WebHome  
VxWorks : https://www.windriver.com/products/vxworks/  
现在最新的VxWorks版本(VxWorks 7)已经比过去的VxWorks版本(我在VxWorks 6.9上遇到了好多问题)更加简单地和U-Boot集成了。
这篇文章讲述了我们为最近的VxWorks 7 BSP进行设置的细节，我们选择使用一个独立于VxWorks镜像文件的DTB文件，而不是将DTB文件嵌入到VxWorks镜像里面。这将给我们带来更好的灵活性，让启动行能够从U-Boot上进行修改，而不需要重新编译DTB。
具体地，VxWorks镜像需要将U-Boot头编译进去，然后U-Boot需要配置传递命令行参数以及MAC地址给VxWorks。
编译VxWorks镜像文件 一个支持U-Boot的VxWorks镜像文件需要编译(将把U-Boot的头加入到VxWorks二进制中)
从Workbench或者命令行来编译uVxWorks的目标文件。
打开一个DOS命令行，配置编译环境，然后编译工程项目。
cd &lt;WIND_HOME&gt; // your installation directory wrenv -p vxworks-7 cd &lt;YOUR_VIP&gt; // your VxWorks Image Project vxprj vip build uVxWorks 这将创建两个文件，用tftp被U-Boot加载到内存：
   文件名 描述     uVxWorks VxWorks image with U-Boot header   [yourboard].dtb the device tree binary    为VxWorks配置U-Boot U-Boot需要设置一些环境变量来加载VxWorks，针对VxWorks的启动参数(bootline)：
=&gt; setenv bootargs memac(2,0)host:vxWorks h=192.168.1.101 e=192.168.1.50:ffffff00 g=192.168.1.254 u=vxworks pw=gaitpu f=0x0 =&gt; saveenv =&gt; printenv bootargs bootargs=memac(2,0)host:vxWorks h=192.168.1.101 e=192.168.1.50:ffffff00 g=192.168.1.254 u=vxworks pw=gaitpu f=0x0 还有你可以随意给网络设备改变MAC地址：
setenv ethaddr 00:00:13:3a:ad:00 setenv eth1add 00:00:13:3a:ad:01 setenv eth1add 00:00:13:3a:ad:02 setenv eth1add 00:00:13:3a:ad:03 saveenv 加载和执行VxWorks镜像文件 配置一个tftp服务器来加载VxWorks镜像文件和DTB文件。
你可以从下面下载一个非常好的Windows TFTP服务器：
http://tftpd32.jounin.net/ 加载VxWorks镜像文件 =&gt; tftp 0x100000 uVxWorks Using FM1@DTSEC3 device TFTP from server 192.168.1.101; our IP address is 192.168.1.50 Filename &#39;uVxWorks&#39;. Load address: 0x100000 Loading: ################################################################# ################################################################# ################################################################# 1.5 MiB/s done Bytes transferred = 2861632 (2baa40 hex) 加载dtb blob =&gt; tftp 0xe00000 t4240qds.dtb Using FM1@DTSEC3 device TFTP from server 192.168.1.101; our IP address is 192.168.1.50 Filename &#39;t4240qds.dtb&#39;. Load address: 0xe00000 Loading: ## 1.4 MiB/s 启动VxWorks镜像文件 =&gt; bootm 0x100000 - 0xe00000 WARNING: adjusting available memory to 30000000 ## Booting kernel from Legacy Image at 00100000 ... Image Name: vxWorks Image Type: PowerPC VxWorks Kernel Image (uncompressed) Data Size: 2861568 Bytes = 2.7 MiB 创建U-boot命令 用下面的步骤创建一个新的U-Boot命令
setenv vxboot &#39;tftp 0x100000 uVxWorks; tftp 0xe00000 t4240qds.dtb; bootm 0x100000 - 0xe00000&#39; saveenv 运行这个命令：
run vxboot 配置U-Boot来传递MAC地址 这对于硬件开发者来说是至关重要的，MAC地址通常是在工厂里面分配的，会被VxWorks镜像文件使用。否则每一块板子出厂前都需要编译和加载一个独立的VxWorks，这绝对是一个梦魇般的情况。
幸运地我们找到了一个方法，因为我们使用一个独立的dtb文件，而不是将dtb文件编译到VxWorks里面，U-Boot会用网络环境变量中的MAC地址覆盖dts文件中的MAC地址。
不仅仅U-Boot可以覆盖本地的MAC地址，如果你在U-Boot环境变量中存储额外的网络地址变量并在你的设备树中为网络接口添加别名的话，U-Boot可以通过设备树将这些MAC地址传递给VxWorks。所以理论上所有网络设备的MAC地址都可以被覆盖。
比如针对一块T4240的PowerPC板子：
/* * U-boot only fixes up MAC Adrress (ethernet0 - n) if * environment variable is set. * aliases simplyfies the path to the property i.e by using a * label &lt;&amp;enet0&gt; to assign a path to a particular node */ aliases{ ethernet0 = &amp;enet0; ethernet1 = &amp;enet1; ethernet2 = &amp;enet2; ethernet3 = &amp;enet3; }; .... fman0: fman@400000 { #address-cells = ;  #size-cells = ;  cell-index = ; compatible = &#34;fsl,fman&#34;; ranges = ; reg = ; interrupts = &lt; 96 2 0 0 16 2 1 1&gt;; clocks = &lt;&amp;hwac1&gt;; clock-names = &#34;fman0-clk&#34;; /* FDT dummyMdio driver : memac0*/ enet0: ethernet@e0000 { compatible = &#34;fsl,fman-memac&#34;; reg = ; phy-handle = &lt;&amp;dummy_phy0&gt;; phy-connection-type = &#34;sgmii&#34;; cell-index = ; local-mac-address = [ 00 04 9F 03 0A 5C ]; }; /* FDT dummyMdio driver : memac1*/ enet1: ethernet@e2000 { .... }; .... }; ]]></content>
  </entry>
  
  <entry>
    <title>利用Wind River VxWorks 7实现自动化软件测试</title>
    <url>/post/app/wind-river-vxworks-7-automatically-software-test-vectorCAST.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks 7</tag>
      <tag>VectorCAST</tag>
    </tags>
    <content type="html"><![CDATA[很多项目都会面临一个问题：怎么才能简单、快速地对实际硬件上的嵌入式应用进行测试 —— 无论是使用模拟器/评估板（处理器在环：PIL）还是生产硬件（硬件在环：HIL）。PIL和HIL测试对于诸如航空航天、汽车电子、医疗、轨道交通等行业内的高安全应用程序来说是尤其重要的，而且这些行业内的应用通常都需要通过资格认证。虽然有些项目并没有那么严格的测试要求，但是如果能尽量在与生产环境相似的环境下进行测试，一定有助于发现更多的问题。
引言 以硬件为基础的测试会遇到很多挑战，包括：处理有限的目标资源，尽量减少对执行时间的影响，让目标通信机制自动进行数据采集，培训团队成员去配置和调试目标执行。
Vector Software能提供一系列工具，通过自动化测试配置和执行的过程来解决这些问题，，从而让工程师可以集中精力创建并执行准确而高效的软件测试。VectorCAST™特别能够在两个关键方面帮助实现基于目标板的测试：
 软件的单元测试和集成测试，证明应用程序的正确性 测试过程中的覆盖率分析，证明测试的完整性  本白皮书将具体阐述这个测试能实现什么，并讨论如何使用Wind River的工具链（Toolchain）和Workbench IDE进行自动化测试。
单元测试和集成测试 软件的单元测试和集成测试主要是隔离应用程序中的一部分代码，尤其是一些C/C++源代码文件，然后全面测试那些代码子集，确保这些代码能够正常运行并且符合详细设计需求。
代码覆盖率分析可以度量哪部分代码已经经过了测试。利用代码覆盖率能够非常简单地量化测试的完整性。我们可以根据这些信息来决定测试应该进行到什么程度。
利用VectorCAST系列产品，可以轻松地为所有的嵌入式目标环境创建测试套件。这些套件可以像回归测试一样频繁地运行，所以总是能生成当前测试状态的仪表盘报告。
VectorCAST/C++通过/失败（pass/fail）结果和代码覆盖率查看器
系统测试过程中的代码覆盖率分析 对于系统测试而言，全面的测试是非常紧要的。只有通过代码覆盖率分析，才能合理地度量测试的完整性。
VectorCAST/Cover可以在项目构建过程中，自动对程序进行插装。插装后的测试程序能够在系统测试正常执行的过程中捕获代码覆盖率。VectorCAST/Cover插装已经得到了充分优化，能够支持嵌入式环境对大小和时间的一般性限制。
VectorCAST/Cover能与现有的开发工具无缝结合，比如：Wind River Workbench。我们可以通过很多途径将覆盖率发送回主机上，包括调试接口。每个单项测试所获取的结果都会独立保存在VectorCAST/Cover中，以便进行差异分析和总量分析。
VectorCAST 和Wind River 将VectorCAST/C++与VectorCAST/RSP结合起来用于Wind River，就能够实现Wind River工具链，开发板， VxWorks® 7实时操作系统  （RTOS）的完全自动化回归测试了。Wind River工具链可以支持多种芯片架构，JTAG 仿真器，以及开发板。利用这一技术，VectorCAST可以支持绝大多数复杂的无缝目标测试环境。
在开发过程中，如果测试失败了，可以使用Workbench Debugger手动执行 VectorCAST测试。 一套测试完成之后，就会被提交到回归测试环境中，这样不需要使用Workbench就可以自动执行这些测试了。
VectorCAST 工具可以与Wind River 支持的所有处理器架构集成，包括：PPC, ARM, MIPS, SBC, x86和68K。VectorCAST也支持在Windows/Linux/Solaris环境下进行本地编译和执行。凭借所使用的微处理器，VectorCAST也能够与RTOS相集成。
由于VectorCAST目标测试支持具备模块化的特性，因而可以轻松添加新处理器家族。
另外，因为VectorCAST的测试用例独立于编译器和目标配置，所以可以先在模拟器上执行测试，然后再转移到生产硬件上。而且只要创建一个新的编译器配置节点，无论在什么编译器版本和微处理器上都可以执行测试。
Wind River Workbench上的VectorCAST/RSP有3个主要功能：
 完全支持Wind River或GNU编译器定义的C和C++扩展语言 利用Wind River Probe或模拟器可以自动下载适用于目标环境的测试套件 在执行过程中自动获取测试结果  只要简单按一下按钮就可以利用VectorCAST执行测试了！
配置VectorCAST，使其适用于Wind River VxWorks 7 配置适用于Wind River的VectorCAST非常简单。对于大多数用户来说，丰富的内建模板列表提供了使用VxWorks目标板或vxSim模拟器进行测试所需要的一切。
VectorCAST内建了所有Wind River版本的内置配置文件
用户选择了合适的目标配置之后，VectorCAST会提供利用Wind River或GNU编译器编译和链接测试套件所需的所有信息。VectorCAST目标配置中也包含执行脚本，利用这些脚本可以自动连接Workbench debugger、加载测试套件、开始执行、收集测试结果和覆盖率。
用户可以轻松地修改VectorCAST编译器设置，使其与特定的构建设置相匹配，如：处理器变量和优化级别。VectorCAST可以通过直接配置所有的参数来简化修改的工作。
这个自动化程度对于VxWorks的5.x版本到最新的7.x来说是一样的。在VxWorks 7.x版本中，VectorCAST利用最新的目标通信框架（TCF）来下载测试并记录结果。
测试的执行和调试 对于回归测试而言，最理想的就是实现自动执行，与此同时，在开发测试用例的过程中利用调试器来解决测试故障并诊断程序中的bug也是至关重要的。
这也是为什么VectorCAST与Wind River集成时会有一个按钮来调用Workbench调试器。任何一个VectorCAST测试用例都可以在Workbench的控制下执行。
适用于在Workbench中调试的VectorCAST测试套件
结论 综上，将VectorCAST和Wind River工具结合起来使用，可以帮助机构或企业完美地解决在提高嵌入式应用软件质量的过程中遇到的问题。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks 7.0下SD卡驱动流程及文件系统格式化</title>
    <url>/post/bsp/SD-card-device-driver-in-vxworks-7.0.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks 7</tag>
      <tag>SD</tag>
    </tags>
    <content type="html"><![CDATA[今天和大家谈谈 VxWorks 7.0下SD卡  的 vxbus  挂接，及文件系统格式化流程， VxWorks 7  的vxbus是基于设备树的，首先必须增加设备树节点，如下：
sdhc0: sdhc@E0100000 { compatible = &#34;zynq,sdhc&#34;; reg = ; clock-frequency = ; interrupts = ; interrupt-parent = &lt;&amp;intc&gt;; embedded = ; bus-width = ; max-dev-clock-frequency = ; card-status-check = ; }; 了解清楚vxbus设备SD卡的挂接流程，对于我们设备驱动的开发至关重要，具体流程如下：
1、设备初始化时会自动加载并识别设备树的节点配置，并匹配相应的驱动程序，首先匹配到SDHC主控制器设备compatible = &ldquo;zynq,sdhc&rdquo;;在这个驱动中会调用attach去初始化相应的设备，具体代码如下：
LOCAL STATUS zynqSdhcCtrlAttach ( struct vxbDev * pDev /* Device information */ ) { ZYNQSDHC_CFG * pCfg; STATUS rc; SDHC_DEV_CTRL * pDrvCtrl; VXB_FDT_DEV * pFdtDev; const void * pValue; int len; rc = vxbClkEnableAll (pDev); if (rc == ERROR) { return ERROR; } rc = sdhcCtrlAttach (pDev); if (rc == ERROR) return (rc); pDrvCtrl = (SDHC_DEV_CTRL *)GET_DRVCTRL(pDev); if (pDrvCtrl == NULL) return ERROR; pFdtDev = vxbFdtDevGet(pDev); if (pFdtDev == NULL) return ERROR; (void)vxbPinMuxEnable(pDev); /* retrieve embedded information if provided */ pValue = vxFdtPropGet(pFdtDev-&gt;offset, &#34;embedded&#34;, &amp;len); if(pValue != NULL) { pDrvCtrl-&gt;embedded = vxFdt32ToCpu(*(UINT32 *)pValue); } /* retrieve max-dev-clock-frequency information if provided */ pValue = vxFdtPropGet(pFdtDev-&gt;offset, &#34;max-dev-clock-frequency&#34;, &amp;len); if(pValue != NULL) pDrvCtrl-&gt;maxDevClkFreq = vxFdt32ToCpu(*(UINT32 *)pValue); else pDrvCtrl-&gt;maxDevClkFreq = 0; /* retrieve user-set-clock-frequency information if provided */ pValue = vxFdtPropGet(pFdtDev-&gt;offset, &#34;user-set-clock-frequency&#34;, &amp;len); if(pValue != NULL) pDrvCtrl-&gt;userSetClkFreq = vxFdt32ToCpu(*(UINT32 *)pValue); else pDrvCtrl-&gt;userSetClkFreq = 0; pCfg = (ZYNQSDHC_CFG *)vxbDevDrvDataGet(pDev); pDrvCtrl-&gt;flags = pCfg-&gt;flag; pDrvCtrl-&gt;sdHostCtrl.sdHostOps.vxbSdHostCtrlInit = zynqSdhcInit; if (pDrvCtrl-&gt;embedded == FALSE) { pDrvCtrl-&gt;sdHostCtrl.sdHostOps.vxbSdVddSetup = zynqSdhcVddSetup; } else { pDrvCtrl-&gt;sdHostCtrl.sdHostOps.vxbSdVddSetup = NULL; } pDrvCtrl-&gt;flags |= SDHC_MANUAL_SDMA_ADDRESS; rc = zynqSdhcInstConnect (pDev); return (rc); } 2、在attach函数最后会调用 zynqSdhcInstConnect，在zynqSdhcInstConnect函数中会创建线程sdBusMonitor，此线程会自动识别卡的插入和拔出，在卡插入时在其父节点下创建新的子节点，并增加的vxbus上去
LOCAL STATUS zynqSdhcInstConnect ( VXB_DEV_HANDLE pDev ) { UINT32 val; STATUS rc; SDHC_DEV_CTRL * pDrvCtrl; SD_HOST_CTRL * pHostCtrl; VXB_FDT_DEV * pFdtDev; const void * pValue; int len; pDrvCtrl = (SDHC_DEV_CTRL *)GET_DRVCTRL(pDev); if (pDrvCtrl == NULL) return ERROR; pHostCtrl = (SD_HOST_CTRL *)pDrvCtrl; rc = sdhcCtrlInstConnect(pHostCtrl); if (rc == ERROR) return ERROR; pFdtDev = vxbFdtDevGet(pDev); if (pFdtDev == NULL) return ERROR; pValue = vxFdtPropGet(pFdtDev-&gt;offset, &#34;bus-width&#34;, &amp;len); if (pValue != NULL) { pHostCtrl-&gt;sdHostSpec.busWidth = vxFdt32ToCpu(*(UINT32 *)pValue); } else { pHostCtrl-&gt;sdHostSpec.busWidth = 4; } pValue = vxFdtPropGet(pFdtDev-&gt;offset, &#34;card-status-check&#34;, &amp;len); if (pValue != NULL) { pHostCtrl-&gt;sdHostSpec.cardCheck = vxFdt32ToCpu(*(UINT32 *)pValue); } else { pHostCtrl-&gt;sdHostSpec.cardCheck = 0; } pHostCtrl-&gt;sdHostSpec.vxbSdBusWidthSetup = pHostCtrl-&gt;sdHostOps.vxbSdBusWidthSetup; pHostCtrl-&gt;sdHostSpec.vxbSdCardWpCheck = pHostCtrl-&gt;sdHostOps.vxbSdCardWpCheck; pHostCtrl-&gt;sdHostSpec.vxbSdClkFreqSetup = pHostCtrl-&gt;sdHostOps.vxbSdClkFreqSetup; pHostCtrl-&gt;sdHostSpec.vxbSdResumeSet = pHostCtrl-&gt;sdHostOps.vxbSdResumeSet; pHostCtrl-&gt;sdHostSpec.vxbSdVddSetup = pHostCtrl-&gt;sdHostOps.vxbSdVddSetup; pHostCtrl-&gt;sdHostSpec.capbility = pHostCtrl-&gt;capbility; pHostCtrl-&gt;sdHostSpec.maxTranSpeed = pDrvCtrl-&gt;maxDevClkFreq; pHostCtrl-&gt;sdHostSpec.userSetTranSpeed = pDrvCtrl-&gt;userSetClkFreq; pHostCtrl-&gt;sdHostSpec.directBio = pHostCtrl-&gt;directBio; pDrvCtrl-&gt;monTaskId = taskSpawn (&#34;sdBusMonitor&#34;, 100, 0, 8192, (FUNCPTR)zynqSdhcCtrlMonitor, (_Vx_usr_arg_t)pDev, 0, 0, 0, 0, 0, 0, 0, 0, 0); if (pDrvCtrl-&gt;monTaskId == TASK_ID_ERROR) { ZYNQSDHC_DBG (ZYNQSDHC_DBG_ERR, &#34;Create monitor task fault\n&#34;, 0, 0, 0, 0, 0, 0); return ERROR; } /* setup the interrupt mask */ pDrvCtrl-&gt;intMask = (IRQ_DATA | IRQ_CMD); pDrvCtrl-&gt;intMask |= IRQ_AC12E; if (pDrvCtrl-&gt;sdHostCtrl.dmaMode == SDHC_DMA_MODE_PIO) pDrvCtrl-&gt;intMask |= (IRQ_BRR | IRQ_BWR); if (pDrvCtrl-&gt;embedded == FALSE) pDrvCtrl-&gt;intMask |= (IRQ_CINS | IRQ_DINT | IRQ_CRM); else pDrvCtrl-&gt;intMask |= IRQ_DINT; CSR_WRITE_4 (pDev, SDHC_IRQSTATEN, pDrvCtrl-&gt;intMask); /* enable SDHC interrupts */ if (pDrvCtrl-&gt;sdHostCtrl.polling == FALSE) { /* connect and enable interrupt */ if (pDrvCtrl-&gt;sdHostCtrl.sdHostOps.vxbSdIsr == NULL) { (void)taskDelete (pDrvCtrl-&gt;monTaskId); return ERROR; } rc = vxbIntConnect (pDev, pDrvCtrl-&gt;intRes, (VOIDFUNCPTR)pDrvCtrl-&gt;sdHostCtrl.sdHostOps.vxbSdIsr, pDev); if (rc == ERROR) { (void)taskDelete (pDrvCtrl-&gt;monTaskId); return ERROR; } rc = vxbIntEnable (pDev, pDrvCtrl-&gt;intRes); if (rc == ERROR) { (void)taskDelete (pDrvCtrl-&gt;monTaskId); return ERROR; } CSR_WRITE_4 (pDev, SDHC_IRQSIGEN, pDrvCtrl-&gt;intMask); } if (pDrvCtrl-&gt;embedded == FALSE) { /* don&#39;t miss an already inserted card */ val = CSR_READ_4(pDev, SDHC_PRSSTAT); if (val &amp; PRSSTAT_CINS) { (void)semGive(pDrvCtrl-&gt;sdHostCtrl.devChange); } } else { (void)semGive(pDrvCtrl-&gt;sdHostCtrl.devChange); } return OK; } 在这个线程 中会调用zynqSdhcDevAdd，增加子节点到vxbus上并设备名为vxbDevNameSet (pDev, MMC_CARD_NAME, TRUE);或者 vxbDevNameSet (pDev, SD_CARD_NAME, TRUE);
vxbDevAdd函数在增加设备节点时会根据devName查找匹配函数并调用相关初始化操作，此时会找到相应的SD卡驱动函数：
LOCAL void zynqSdhcCtrlMonitor ( VXB_DEV_HANDLE pDev ) { STATUS rc; SD_HOST_CTRL * pSdHostCtrl; SDHC_DEV_CTRL * pDrvCtrl; pDrvCtrl = (SDHC_DEV_CTRL *)GET_DRVCTRL(pDev); if (pDrvCtrl == NULL) return; else pSdHostCtrl = (SD_HOST_CTRL *)(&amp;(pDrvCtrl-&gt;sdHostCtrl)); while (erfLibInitialized == FALSE) (void)taskDelay (sysClkRateGet ()); while(1) { rc = pSdHostCtrl-&gt;sdHostOps.vxbSdCardInsertSts(pDev); if (rc &amp;&amp; (pSdHostCtrl-&gt;attached == FALSE)) { zynqSdhcDevAdd(pDev); } else if (rc) { zynqSdhcDevRemove(pDev); zynqSdhcDevAdd(pDev); } if (!rc &amp;&amp; (pSdHostCtrl-&gt;attached == TRUE)) { zynqSdhcDevRemove (pDev); } } } 相应代码如下：
STATUS sdDeviceCreate ( VXB_DEV_HANDLE pInst, void * pArg ) { VXB_DEV_ID pDev = NULL; SD_HARDWARE * pSdHardWare; SD_HOST_SPEC * pSdHostSpec; STATUS rc; /* initialize generic bus info */ rc = vxbDevCreate (&amp;pDev); if (rc != OK) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce() - vxbDevStructAlloc not success\n&#34;, 0, 0, 0, 0, 0, 0); return(ERROR); } /* initialize bus-specific info */ pSdHardWare = (SD_HARDWARE *) vxbMemAlloc(sizeof (SD_HARDWARE)); if (pSdHardWare == NULL) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - hwMemAlloc not success for pSdHardWare\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); return(ERROR); } rc = VXB_SDSPECINFO_GET(pInst, &amp;(pSdHardWare-&gt;pHostSpec), &amp;(pSdHardWare-&gt;vxbSdCmdIssue)); if (rc != OK) { SD_LIB_DBG(SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - VXB_SDSPECINFO_GET not success\n&#34;, 0, 0, 0, 0, 0 ,0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } vxbDevClassSet(pDev, VXB_BUSID_SDMMC); vxbDevIvarsSet(pDev,pSdHardWare); pSdHostSpec = (SD_HOST_SPEC *)(pSdHardWare-&gt;pHostSpec); if (pSdHostSpec == NULL) { SD_LIB_DBG(SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - pSdHostSpec null\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } pSdHostSpec-&gt;childDev = pDev; /* get host controller unit number */ pSdHostSpec-&gt;unitNumber = vxbDevUnitGet(pInst); pSdHardWare-&gt;pHostDev = pInst; if (pSdHostSpec-&gt;vxbSdGetHostCap) { (void)(pSdHostSpec-&gt;vxbSdGetHostCap)(pInst, &amp;(pSdHostSpec-&gt;hostCap)); } return sdDeviceInit(pDev,0); } STATUS sdDeviceInit ( VXB_DEV_HANDLE pDev, UINT32 reInit ) { VXB_DEV_HANDLE pInst; SD_HARDWARE * pSdHardWare; SD_HOST_SPEC * pSdHostSpec; STATUS rc; int i = 0; UINT32 capbility; UINT32 timeOut = 0; pSdHardWare = (SD_HARDWARE *)GET_HARDWAREINFO(pDev); if (pSdHardWare == NULL) return ERROR; pSdHostSpec = (SD_HOST_SPEC *)(pSdHardWare-&gt;pHostSpec); if (pSdHostSpec == NULL) return ERROR; capbility = pSdHostSpec-&gt;capbility; pInst = pSdHardWare-&gt;pHostDev; rc = sdCmdGoIdleState (pDev); if (rc == ERROR) { SD_LIB_DBG(SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - sdCmdGoIdleState not success\n\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } /* CMD8 is required to support SDHC or SDXC */ (void)sdCmdSendIfCond (pDev, 0); rc = sdioCmdIoSendOpCond(pDev, capbility &amp; OCR_VDD_VOL_MASK); if ((pSdHardWare-&gt;cmdErr &amp; SDMMC_CMD_ERR_TIMEOUT) != 0x0) { /* To conform to JEDEC specification */ rc = sdMmcCmdSendOpCond(pDev, 0); if ((rc == ERROR) || ((pSdHardWare-&gt;cmdErr &amp; SDMMC_CMD_ERR_TIMEOUT) != 0x0)) pSdHardWare-&gt;isMmc = FALSE; else pSdHardWare-&gt;isMmc = TRUE; if (pSdHardWare-&gt;isMmc) { sdCmdGoIdleState(pDev); while (timeOut++ &lt; SDMMC_COMMAND_TIMEOUT) { rc = sdMmcCmdSendOpCond(pDev, (pSdHardWare-&gt;ocrValue | OCR_CARD_CAP_STS)); if ((rc == OK) &amp;&amp; ((pSdHardWare-&gt;ocrValue &amp; (UINT32)OCR_CARD_PWRUP_STS) != 0x0)) { pSdHardWare-&gt;voltage = (pSdHardWare-&gt;ocrValue) &amp; OCR_VDD_VOL_MASK; break; } vxbMsDelay(1); } vxbDevNameSet (pDev, MMC_CARD_NAME, TRUE); } else { (void)sdCmdGoIdleState (pDev); (void)sdCmdSendIfCond (pDev, capbility); if (pSdHardWare-&gt;version == SD_VERSION_UNKNOWN) { SD_LIB_DBG(SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - sdCmdGoIdleState not success\n\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } while (timeOut++ &lt; SDMMC_COMMAND_TIMEOUT) { rc = sdACmdSendOpCond (pDev, capbility, pSdHardWare-&gt;version, reInit); if ((rc == OK) &amp;&amp; ((pSdHardWare-&gt;ocrValue &amp; (UINT32)OCR_CARD_PWRUP_STS) != 0x0)) { pSdHardWare-&gt;voltage = (pSdHardWare-&gt;ocrValue) &amp; OCR_VDD_VOL_MASK; break; } vxbMsDelay(1); } if (timeOut &gt;= SDMMC_COMMAND_TIMEOUT) { SD_LIB_DBG(SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - sdACmdSendOpCond not success\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } /* Use pSdHostSpec-&gt;capbility to record S18A */ if (pSdHardWare-&gt;ocrValue &amp; OCR_VDD_VOL_S18A) { pSdHostSpec-&gt;capbility |= OCR_VDD_VOL_S18A; } vxbDevNameSet (pDev, SD_CARD_NAME, TRUE); } pSdHardWare-&gt;isComboCard = FALSE; pSdHardWare-&gt;isSdio = FALSE; rc = vxbDevAdd (pInst, pDev); if (rc == ERROR) { SD_LIB_DBG(SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - vxbDevAdd not success\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } pSdHardWare-&gt;recover = TRUE; /* coverity[leaked_storage] */ /* * pDev and pSdHardWare are used with vxBus system, * so we can&#39;t free it. Set coverity keyword */ return OK; } if (rc == OK) { UINT8 funcNum = 0; funcNum = (pSdHardWare-&gt;ocrValue &gt;&gt; 28) &amp; 0x07; if (funcNum &gt; 0) { rc = sdioCmdIoSendOpCond(pDev, capbility &amp; 0x00FFFFFF); if (rc == ERROR) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - sdioCmdIoSendOpCond not success\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } do{ rc = sdCmdSendRelativeAddr (pDev); if (rc == ERROR) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - sdCmdSendRelativeAddr not success\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } } while (pSdHardWare-&gt;rcaValue == 0); rc = sdCmdSelectCard (pDev); if (rc == ERROR) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - sdCmdSelectCard not success\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } for (i = 0; i &lt; funcNum; i++) { if (pDev == NULL) { rc = vxbDevCreate (&amp;pDev); if (rc == ERROR) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - vxbDevCreate not success\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pSdHardWare); return(ERROR); } } if (pSdHardWare == NULL) { pSdHardWare = (SD_HARDWARE *) vxbMemAlloc(sizeof (SD_HARDWARE)); if (pSdHardWare == NULL) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - hwMemAlloc not success for pSdHardWare\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); return(ERROR); } rc = VXB_SDSPECINFO_GET(pInst, &amp;(pSdHardWare-&gt;pHostSpec), &amp;(pSdHardWare-&gt;vxbSdCmdIssue)); if (rc != OK) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - VXB_SDSPECINFO_GET not success\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } vxbDevClassSet(pDev, VXB_BUSID_SDMMC); vxbDevIvarsSet(pDev,pSdHardWare); pSdHostSpec = (SD_HOST_SPEC *)(pSdHardWare-&gt;pHostSpec); if (pSdHostSpec == NULL) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - pSdHostSpec null\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } capbility = pSdHostSpec-&gt;capbility; } pSdHardWare-&gt;isSdio = TRUE; pSdHardWare-&gt;isComboCard = FALSE; pSdHardWare-&gt;funcNum = i + 1; /* Need not check return status at here */ rc = vxbDevAdd (pInst, pDev); if (rc == ERROR) { SD_LIB_DBG (SD_LIB_DBG_ERR, &#34;sdDeviceAnnounce - vxbDevAdd not success\n&#34;, 0, 0, 0, 0, 0, 0); vxbMemFree(pDev); vxbMemFree(pSdHardWare); return(ERROR); } pDev = NULL; pSdHardWare = NULL; } } } return OK; } 在SD卡的ATTACH函数中会挂接相应的read，write，ioctl等函数并创建xbd包装器
LOCAL STATUS sdIdentify ( VXB_DEV_HANDLE pDev ) { STATUS rc; UINT32 csize, csizeMulti; UINT64 blkNum; SD_CARD_CTRL * pDrvCtrl; SD_HARDWARE * pSdHardware; SD_HOST_SPEC * pHostSpec; SD_INFO * pSdInfo; device_t xbdSts; BLK_XBD_PARAMS blkXbdParams; UINT32 workSpeed; UINT32 i; pDrvCtrl = (SD_CARD_CTRL *)GET_DRVCTRL (pDev); if (pDrvCtrl == NULL) return ERROR; pSdHardware = (SD_HARDWARE *)GET_HARDWAREINFO(pDev); if (pSdHardware == NULL) return ERROR; pHostSpec = (SD_HOST_SPEC *)(pSdHardware-&gt;pHostSpec); if (pHostSpec == NULL) return ERROR; #ifdef _WRS_CONFIG_VXBUS_LEGACY  pDrvCtrl-&gt;pInfo = malloc (sizeof(SD_INFO)); #else  pDrvCtrl-&gt;pInfo = vxbMemAlloc(sizeof(SD_INFO)); #endif /* _WRS_CONFIG_VXBUS_LEGACY */ if (pDrvCtrl-&gt;pInfo == NULL) goto err1; /* apply one card index to system */ rc = sdCardIdxAlloc (pDrvCtrl); if (rc != OK) { SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - sdCardIdxAlloc fault\n&#34;, 0, 0, 0, 0, 0, 0); goto err; } pSdInfo = (SD_INFO *)(pDrvCtrl-&gt;pInfo); bcopy((char *)(&amp;pSdHardware-&gt;cidValue[0]), (char *)(&amp;pSdInfo-&gt;cid), CID_SIZE); pDrvCtrl-&gt;highCapacity = (((pSdHardware-&gt;ocrValue) &amp; OCR_CARD_CAP_STS) != 0x0) ? TRUE : FALSE; SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - pDrvCtrl-&gt;highCapacity = 0x%x\n&#34;, pDrvCtrl-&gt;highCapacity, 0, 0, 0, 0, 0); if ((pHostSpec-&gt;capbility &amp; OCR_VDD_VOL_S18A) != 0x0) { if ((pSdHardware-&gt;ocrValue &amp; OCR_VDD_VOL_S18A) != 0x0) pSdInfo-&gt;uhsSupport = TRUE; else pSdInfo-&gt;uhsSupport = FALSE; } else pSdInfo-&gt;uhsSupport = FALSE; if (pSdInfo-&gt;uhsSupport) { if (pHostSpec-&gt;vxbSdSigVolSwitch != NULL) { rc = pHostSpec-&gt;vxbSdSigVolSwitch (pSdHardware-&gt;pHostDev, SD_VOLTAGE_S18); if (rc == ERROR) { SD_CARD_DBG(SD_CARD_DBG_ERR, &#34;sdIdentify() - vxbSdSigVolSwitch error\n&#34;, 0, 0, 0, 0, 0, 0); pSdInfo-&gt;uhsSupport = FALSE; pHostSpec-&gt;capbility &amp;= (~OCR_VDD_VOL_S18A); /* * If an error occurs during voltage switch procedure, stop providing * the power to the card. In this case, Host Driver should retry * initialization procedure by setting S18R to 0 at step (7) and (21) in * Figure 3-9. (Part A2) */ /* * AM572X idk board doesn&#39;t support power cycle. So retry initialization * is not validated. */ #ifndef _WRS_CONFIG_VXBUS_LEGACY  rc = sdPowerCycle(pDev); if (rc == OK) { vxbMemFree (pDrvCtrl-&gt;pInfo); vxbMemFree (pDrvCtrl); vxbDevSoftcSet(pDev, NULL); return sdDeviceInit(pDev, 1); } else #endif /* _WRS_CONFIG_VXBUS_LEGACY */ goto err; } } else { pSdInfo-&gt;uhsSupport = FALSE; pHostSpec-&gt;capbility &amp;= (~OCR_VDD_VOL_S18A); goto sendRca; } goto sendRca; } sendRca: /* Need not take care of return value */ (void)sdCmdAllSendCid(pDev, (void *) (&amp;pSdHardware-&gt;cidValue[0])); /* CMD3: request card to send RCA */ i = 0; do { (void)sdCmdSendRelativeAddr (pDev); } while ((pSdHardware-&gt;rcaValue == 0) &amp;&amp; (i++ &lt; CMD3_RETRY_NUM)); if (i &gt;= CMD3_RETRY_NUM) { SD_CARD_DBG(SD_CARD_DBG_ERR, &#34;sdIdentify() - failed to get valid RCA.\n&#34;, 0, 0, 0, 0, 0, 0); goto err; } else { SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - pSdHardware-&gt;rcaValue = 0x%x\n&#34;, pSdHardware-&gt;rcaValue, 0, 0, 0, 0, 0); } /* CMD9: request card to send CSD */ rc = sdCmdSendCsd (pDev, &amp;(pSdInfo-&gt;csd)); if (rc == ERROR) goto err; else { pSdInfo-&gt;csd.commClass = (UINT16)be16toh(pSdInfo-&gt;csd.commClass); pSdInfo-&gt;csd.eraseSize = (UINT16)be16toh(pSdInfo-&gt;csd.eraseSize); pSdInfo-&gt;csd.r2wFactor = (UINT16)be16toh(pSdInfo-&gt;csd.r2wFactor); pSdInfo-&gt;csd.fileFormat = (UINT16)be16toh(pSdInfo-&gt;csd.fileFormat); SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - pSdInfo-&gt;csd.commClass = 0x%x\n&#34; &#34;pSdInfo-&gt;csd.eraseSize = 0x%x\n&#34; &#34;pSdInfo-&gt;csd.r2wFactor = 0x%x\n&#34; &#34;pSdInfo-&gt;csd.fileFormat = 0x%x\n&#34;, pSdInfo-&gt;csd.commClass, pSdInfo-&gt;csd.eraseSize, pSdInfo-&gt;csd.r2wFactor, pSdInfo-&gt;csd.fileFormat, 0, 0); /* decode CSD fields */ pDrvCtrl-&gt;tranSpeed = sdCsdTranSpdfUnit[(pSdInfo-&gt;csd.tranSpeed &amp; 0x7)] * sdCsdTranSpdTime[((pSdInfo-&gt;csd.tranSpeed &gt;&gt; 3) &amp; 0x0f)]; SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - pDrvCtrl-&gt;tranSpeed = %d\n&#34;, pDrvCtrl-&gt;tranSpeed, 0, 0, 0, 0, 0); if (pDrvCtrl-&gt;tranSpeed == CSD_TRAN_SPD_50MHZ) pDrvCtrl-&gt;highSpeed = TRUE; /* maximum read block length */ pDrvCtrl-&gt;readBlkLen = 1 &lt;&lt; (pSdInfo-&gt;csd.commClass &amp; 0x0f); SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - pDrvCtrl-&gt;readBlkLen = %d\n&#34;, pDrvCtrl-&gt;readBlkLen, 0, 0, 0, 0, 0); /* per SD spec, the maximum write block length is equal to read block */ pDrvCtrl-&gt;writeBlkLen = pDrvCtrl-&gt;readBlkLen; pSdHardware-&gt;blockSize = SDMMC_BLOCK_SIZE; /* calculate user data capacity */ if (pDrvCtrl-&gt;highCapacity) { csize = ((pSdInfo-&gt;csd.resvData0[1] &amp; 0x3f) &lt;&lt; 16) | (pSdInfo-&gt;csd.resvData0[2] &lt;&lt; 8) | pSdInfo-&gt;csd.resvData0[3]; csizeMulti = 8; } else { csize = ((UINT32)(pSdInfo-&gt;csd.resvData0[0] &amp; 0x03) &lt;&lt; 10) | ((UINT32)(pSdInfo-&gt;csd.resvData0[1]) &lt;&lt; 2) | ((pSdInfo-&gt;csd.resvData0[2] &gt;&gt; 6) &amp; 0x03); csizeMulti = ((pSdInfo-&gt;csd.resvData0[3] &amp; 0x03) &lt;&lt; 1) | ((pSdInfo-&gt;csd.eraseSize &gt;&gt; 7) &amp; 0x01); } blkNum = ((UINT64)(csize + 1)) &lt;&lt; (csizeMulti + 2); pDrvCtrl-&gt;blkNum = blkNum; pDrvCtrl-&gt;capacity = blkNum * pDrvCtrl-&gt;readBlkLen; SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - pDrvCtrl-&gt;blkNum = %ld\n&#34; &#34;pDrvCtrl-&gt;capacity = %ld\n&#34;, pDrvCtrl-&gt;blkNum, pDrvCtrl-&gt;capacity, 0, 0, 0, 0); /* write protect model */ if ((pSdInfo-&gt;csd.fileFormat &gt;&gt; 12) &amp; 0x1) pDrvCtrl-&gt;tmpWp = TRUE; if ((pSdInfo-&gt;csd.fileFormat &gt;&gt; 13) &amp; 0x1) pDrvCtrl-&gt;permWp = TRUE; } /* After Card Identification, the station go into Data Transfer Mode */ if (pDrvCtrl-&gt;tranSpeed &gt; SDMMC_CLK_FREQ_400KHZ) { workSpeed = pDrvCtrl-&gt;tranSpeed &lt; SDMMC_CLK_FREQ_25MHZ ? pDrvCtrl-&gt;tranSpeed : SDMMC_CLK_FREQ_25MHZ; pHostSpec-&gt;vxbSdClkFreqSetup (pSdHardware-&gt;pHostDev, workSpeed); } pDrvCtrl-&gt;highSpeed = FALSE; /* CMD7: select one card and put it into transfer state */ rc = sdCmdSelectCard (pDev); if (rc == ERROR) goto err; /* AMD51: request card to send its SCR */ rc = sdACmdSendScr (pDev, &amp;(pSdInfo-&gt;scr)); if (rc == ERROR) goto err; else { pSdInfo-&gt;sdSpec = pSdInfo-&gt;scr.spec &amp; 0x0f; SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - pSdInfo-&gt;sdSpec = 0x%x\n&#34;, pSdInfo-&gt;sdSpec, 0, 0, 0, 0, 0); /* update the SD card version */ pSdHardware-&gt;version = (UINT8)(pSdInfo-&gt;sdSpec + 1); if ((pSdInfo-&gt;scr.expConfig &amp; SCR_SD_SPEC3_MASK) != 0x0) { if (pSdHardware-&gt;version == SD_VERSION_200) pSdHardware-&gt;version = SD_VERSION_300; } pSdInfo-&gt;sdSec = (pSdInfo-&gt;scr.config &gt;&gt; 4) &amp; 0x7; if (pSdInfo-&gt;scr.config &amp; SCR_SD_BUS_WIDTH_4BIT) pSdInfo-&gt;dat4Bit = TRUE; } /* switch to 4 bit mode if needed */ if (pSdInfo-&gt;dat4Bit) { rc = sdACmdSetBusWidth (pDev, SDMMC_BUS_WIDTH_4BIT); if (rc == ERROR) goto err; /* setup host to enable 4-bit bus width */ if (pHostSpec-&gt;vxbSdBusWidthSetup != NULL) { pHostSpec-&gt;vxbSdBusWidthSetup(pSdHardware-&gt;pHostDev, SDMMC_BUS_WIDTH_4BIT); } } /* ACMD42: clear card detect and set data3 as data line */ rc = sdACmdClrCardDetect(pDev, SD_ACMD42_ARG_CLR_CARD_DETECT); if (rc == ERROR) goto err; /* setup host to enable high speed clock (50 MHz) if needed */ if (pSdInfo-&gt;uhsSupport) { rc = sdInitUhsCard(pDev); if (rc == ERROR) goto err; goto createXbd; } /* setup host to enable high speed clock (50 MHz) if needed */ if (pSdHardware-&gt;version &gt;= SD_VERSION_110) { int rc; rc = sdACmdSetHighSpeed(pDev); if ((pHostSpec-&gt;vxbSdClkFreqSetup != NULL)) { if ((rc == OK) &amp;&amp; (pHostSpec-&gt;workFreq == SDMMC_CLK_FREQ_25MHZ)) pHostSpec-&gt;vxbSdClkFreqSetup(pSdHardware-&gt;pHostDev, SDMMC_CLK_FREQ_25MHZ); else if (rc == OK) { pHostSpec-&gt;vxbSdClkFreqSetup(pSdHardware-&gt;pHostDev, SDMMC_CLK_FREQ_50MHZ); pDrvCtrl-&gt;highSpeed = TRUE; SD_CARD_DBG(SD_CARD_DBG_INIT, &#34;sdIdentify() - change to 50MHZ success\n&#34;, 0, 0, 0, 0, 0, 0); } else if (rc == ENOTSUP) { pHostSpec-&gt;vxbSdClkFreqSetup(pSdHardware-&gt;pHostDev, SDMMC_CLK_FREQ_25MHZ); pDrvCtrl-&gt;highSpeed = FALSE; } else if (rc == ERROR) goto err; } } else { if (pHostSpec-&gt;vxbSdClkFreqSetup != NULL) { pHostSpec-&gt;vxbSdClkFreqSetup(pSdHardware-&gt;pHostDev, SDMMC_CLK_FREQ_25MHZ); } } /* check if card is write protected */ if (pHostSpec-&gt;vxbSdCardWpCheck != NULL) { pDrvCtrl-&gt;isWp = pHostSpec-&gt;vxbSdCardWpCheck(pSdHardware-&gt;pHostDev); } createXbd: /* set xbd params */ blkXbdParams.xbdOps.blkRead = sdStorageBlkRead; blkXbdParams.xbdOps.blkWrite = sdStorageBlkWrite; blkXbdParams.xbdOps.blkDump = NULL; blkXbdParams.xbdOps.blkIoctl = sdStorageIoctl; blkXbdParams.xbdOps.xferReq = NULL; blkXbdParams.maxActiveReqs = 1; blkXbdParams.maxBiosPerReq = 1; blkXbdParams.maxXferBlks = SDHC_MAX_RW_SECTORS; blkXbdParams.directModeFlag = pHostSpec-&gt;directBio; blkXbdParams.numBlks = (sector_t)(pDrvCtrl-&gt;capacity / pSdHardware-&gt;blockSize); blkXbdParams.blkSize = pSdHardware-&gt;blockSize; blkXbdParams.svcTskPri = SDMMC_XBD_SVC_TASK_PRI; blkXbdParams.pDev = (void *)pDev; (void)snprintf ((char *)&amp;(blkXbdParams.devName[0]), sizeof(blkXbdParams.devName), &#34;/sd%d&#34;, pHostSpec-&gt;unitNumber); pDrvCtrl-&gt;attached = TRUE; xbdSts = blkXbdDevCreate (&amp;(pDrvCtrl-&gt;xbdDev), &amp;blkXbdParams); if (xbdSts == NULLDEV) { pDrvCtrl-&gt;attached = FALSE; goto err; } return OK; /* * We need to free memories we allocated in this function when we return * ERROR. If we return OK, we don&#39;t free these memories and use them in * normal process, until sdStorageInstUnlink() is called to free these * memories from vxbDevRemove() in Monitor task when card removal is detected. */ err: #ifndef _WRS_CONFIG_VXBUS_LEGACY  vxbMemFree (pDrvCtrl-&gt;pInfo); #else  free (pDrvCtrl-&gt;pInfo); #endif /* _WRS_CONFIG_VXBUS_LEGACY */ err1: #ifndef _WRS_CONFIG_VXBUS_LEGACY  vxbMemFree (pDrvCtrl); vxbDevSoftcSet(pDev, NULL); #else  free (pDrvCtrl); #endif /* _WRS_CONFIG_VXBUS_LEGACY */ return ERROR; } 至此，设备驱动挂接完成，在shell里面输入devs 查看就可以看到设备/SD0:1,只需要调用文件系统格式化就可以了，dosFsVolFormat(“/sd0:1”，0，0);
]]></content>
  </entry>
  
  <entry>
    <title>实测VxWorks响应PCIe中断的最小时间间隔</title>
    <url>/post/app/mininum-time-for-vxworks-response-pcie-interrupt.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>VxWorks 6.8</tag>
      <tag>PCIe</tag>
      <tag>Interrupt</tag>
    </tags>
    <content type="html"><![CDATA[中断是外部事件通知操作系统的最常用手段。中断处理机制是计算机多任务环境运行的基础，是系统实时性的保证;VxWorks是美国Wind River公司于1983年设计开发的一种嵌入式实时操作系统。内核wind在任务调度、中断处理及网络处理等方面与其它嵌入式实时操作系统相比具有一定的优势。特别是其提供的微秒级的中断处理为VxWorks在嵌入式实时操作系统领域的旗舰地位奠定了基础。本文通过带有PCIe接口的FPGA开发板，在VxWorks6.8版本的操作系统环境下，实测一下VxWorks操作系统中断处理的最小时间间隔是否是传说中的微秒级。
准备工作 硬件平台环境如下图所示，采用两台带有以太网口的设备相连，一端是PC机插有PCIe的FPGA开发板，运行Windows操作系统；另一端是嵌入式设备，运行VxWorks操作系统。
嵌入式设备 母板为P2020开发板，PCIe板卡为黑金Xilinx Artix-7 PCIE AX7103 FPGA开发板，运行VxWorks操作系统。
PC端 电脑主机一台，拆开（机箱比较脏，见谅），通过PCIe连线连到黑金Xilinx Artix-7 PCIE AX7103 FPGA开发板上，运行Win7操作系统。
两台设备之间通过双冗余的网线连接。
中断处理流程 在上面的环境中，按照以太网帧传递过程中的需求，任何一端的中断处理都包含三个不同的主体，首先是CPU内核的中断响应机制，然后是加上操作系统之后对中断响应的处理又有操作系统的要求，之后是PCIe硬件设备也有一套向CPU操作系统发送中断的规范。任何一方的中断处理机制都可以写很长很长的文字去描述，本文在此不再赘述。
PCIe总线支持两种中断方式，传统的INTx中断和基于存储器写请求的中断请求机制即消息中断。本文的设计方案中使用的是传统的INTx中断。为了叙述上的方便，我们从FPGA的时序图的角度去描述中断的处理流程，具体分为主机（PCIe发给主机的中断信号）、PCIe硬核、驱动来配置的中断使能信号、FPGA侧的中断源。下图是具体的主机操作系统为VxWorks时FPGA开发板与主机的中断交互流程。
1）FPGA侧有三个中断源可以触发中断，分别是DMA写开始、DMA写完成和DMA读完成中断，其中，写开始中断源是FPGA告知主机此时有数据要通过DMA写操作进行上传；写完成中断是FPGA将所有的数据封装成DMA写请求包；读完成中断是FPGA收齐了所有来自主机的DMA读完成包。上图中“1”处是中断源mwr_start_interrupt拉高了。
2）任意一个中断源拉高，FPGA侧给PCIe IP核配置“置中断”时序，在cfg_interrupt和cfg_interrupt_rdy握手成功后，cfg_interrupt_assert为高则为置中断。（cfg_interrupt为PCIe硬核发给主机的中断请求，cfg_interrupt_rdy为主机接收到中断请求后的回应，此时需要看cfg_interrupt_assert的状态，cfg_interrupt_assert为高，则为置中断，如上图中“2”处所示；cfg_interrupt_assert为低电平，则为清中断请求，如上图中“5”处所示。）
3）“置中断”后一段时间（此处约为17个时钟），主机侧硬中断电平INTA拉高，此时才是FPGA板卡真正的向主机发出了一个中断。如上图中“3”。
4）驱动检测到中断电平拉高后，以PIO写操作的方式往PCIe的BAR空间中控制状态寄存器04H的第[31]位写1，关闭接收中断功能，此时中断使能信号线int_dis_o拉高，如上图中“4”位置。int_dis_o为高电平期间，CPU不再响应FPGA板卡的中断请求，此处非常重要。之后CPU则以PIO读的形式读FPGA的中断状态寄存器。
5）FPGA将中断状态寄存器的值以PIO读完成包形式发送给CPU，告知CPU该中断具体为何种中断，同时配置“清中断”时序。如上图中“5”处所示。
6）CPU驱动记录中断源后复位相应中断标志位，如上图中“6”处所示。（此处也可由FPGA自己完成）
7）FPGA拉低相应中断源信号，如上图中“7”处所示。
8）CPU驱动通过PIO写操作往控制状态寄存器04H第[31]位写0，重新开启接收中断功能。如上图中“8”处所示。
9）重复步骤1）启动下一次中断；10）下一次置中断时序；11）硬中断电平再次拉高。
下图为一次完整的DMA读操作时CPU与FPGA板卡之间的交互流程，最后会涉及到DMA读完成中断，详细过程的描述略。
VxWork响应PCIe中断的最小间隔 为了得到VxWorks响应PCIe中断的最小间隔，我们在FPGA侧对两次“置中断”间隔，即上图步骤2）与步骤10）进行了时钟计数，在“置中断”时序(cfg_interrupt_rdy &amp; cfg_interrupt_assert)下将间隔时间寄存器inter_intr_clk_cnt[31:0]计数复位，否则计数加一，直到下一次“置中断”进行计数复位，这样就能计算出中断信号两次拉高的时间间隔。
在测试的过程中，我们用Vivado抓取了实际数据传输时两种不同的中断场景。
1、场景1：写开始中断和读完成中断一起处理
有了上面中断处理流程的介绍，就可以很方便的分析具体工作状态下的波形图。从上图可以看到，读完成中断mrd_done_interrupt触发置中断时序，主机的硬中断电平拉高，驱动往控制与状态寄存器04H的最高位（图示int_dis_o信号） PIO操作写“1”，关闭中断功能，此时硬件这边不再产生置中断时序，直到驱动跳出中断复位程序，往04H的int_dis_o写“0”，使能中断；驱动PIO读中断状态寄存器（图示蓝线）“采样”到读完成（图示mrd_done_interrupt信号）和写开始（图示mwr_start_interrupt信号）两个中断标志位为高，此时，驱动会记录下来并同时对这两个中断标志位进行复位操作，然后驱动分别执行读完成中断和写开始中断状态机。
场景2：写开始中断和读完成中断先后处理
从上图可以看到，读完成中断mrd_done_interrupt触发置中断时序，主机的硬中断电平拉高，驱动往控制与状态寄存器04H的最高位（图示int_dis_o信号） PIO操作写“1”，关闭中断功能，此时硬件这边不在产生置中断时序，直到驱动跳出中断复位程序，往04H的int_dis_o写“0”，使能中断；驱动PIO读中断状态寄存器（图示蓝线1）采样到读完成（图示mrd_done_interrupt信号）中断标志位为1，硬件产生清中断时序，将主机侧的硬中断电平拉低，注意，此刻写开始中断（图示mwr_start_interrupt信号）刚好拉高，驱动只记录读完成中断并对读完成中断标志位进行复位操作（图示蓝线2），然后驱动执行读完成中断状态机，驱动跳出读完成中断状态机后重新使能中断（图示蓝线3），此时硬件侧因为写开始中断才被允许产生置中断时序，驱动再次检测到硬中断电平信号为高，驱动PIO读中断状态寄存器（图示蓝线4）采样到写开始中断标志位为1，硬件产生清中断时序，将主机侧的硬中断电平拉低，驱动记录写开始中断并对写开始中断标志位进行复位操作（图示蓝线5），然后驱动执行写开始中断状态机。
在第二个测试场景中，我们可以通过计数得知两个相邻中断的最小时间间隔，，硬件侧产生第一次中断段时序（图示蓝线1），在执行完第一次中断后，驱动侧将int_dis_o拉低，重新使能中断，硬件侧立即产生置中断时序进行第二次中断操作（图示蓝线2），如下图所示：
我们将图示蓝线2处进行放大得到下图：
通过相邻中断时钟计数信号inter_intr_clk_cnt[31:0]可以知道相邻两中断的最小间隔是365个钟，后边测试过多次，测试结果有368，364，，我们取365，时钟周期为16ns，由此可以计算得知VxWorks下最小中断间隔是365*16=5.84us。
结论：VxWorks操作系统中断处理的最小时间间隔确实是传说中的微秒级！
Windows操作系统下PCIe中断响应间隔测试 出于好奇，我们也尝试测了一下Windows 操作系统下PCIe中断响应的时间间隔。在Windows平台下的驱动暂未使用开/关中断使能的功能，所以只是测试在点播视频以及拷贝视频文件两种场景下的中断间隔。
1、场景1：点播视频，速率为10Mbps左右
从上图可以看到，上一次置中断时序复位后计数12417491个clk（16ns）再次产生置中断时序，此时中断间隔约为198.7ms，后面统计到一些计数值：19026416（304.4ms）,6486433（103.8ms）,9981793（159.7ms）。在点播视频时，带宽并未达到上限，驱动处理两个相邻中断的时间间隔＞100ms。为了在高带宽情况下测试，我们进行了场景2的测试。
场景2：拷贝视频，速率为几百兆bps
从上图可以看到，上一次置中断时序复位后计数4175个clk（16ns）再次产生置中断时序，此时中断间隔约为66.8us，后面统计到一些计数值：3595（57.5us）、7456（119.3us）、3582（57.3us）、4159（66.5us）。在带宽提升后，win32驱动处理中断的频率有了显著地提高。
遇到的问题 在刚开始的时候，中断处理流程中CPU操作时并没有开启或关闭接收中断的操作，结果，在Windows平台下，没有任何的问题，生成PCIe IP核时，设置传输带宽上限为2Gbps，在1G以太网口测试各种业务时都很稳定，没有出现操作系统崩溃的情况；但在VxWorks系统测试时，由于VxWorks系统实时性非常好，响应中断也比较及时，就会出现操作系统正在执行一个中断服务程序时，硬件又来了一个中断，直接导致VxWorks系统死掉，如下图所示。当然，这也是中断处理流程不规范造成的。后续会在Windows驱动中也添加上开关中断使能的步骤，测试一下Windows相应PCIe中断的最小间隔。不过从目前测试数据看，Windows相应PCIe中断的速度肯定会比VxWorks慢很多。
]]></content>
  </entry>
  
  <entry>
    <title>航空电子设备与智能边缘</title>
    <url>/post/news/avionics-and-intelligent-edge.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>WindRiver</tag>
      <tag>VxWorks</tag>
      <tag>ML</tag>
    </tags>
    <content type="html"><![CDATA[在最近的AFCEA Lexington-Concord New Horizons会议上，美国空军首席信息Lauren Knausenberger强调，美国空军的下一代机载平台需要采用特斯拉那样的方式，结合感知、自动自主操作和边缘云。她明确表示：“这是一个持续工作的网络。”那么，在航空航天和国防行业，我们应该如何实现航空电子系统数字化转型，使它像云原生的智能边缘平台一样运行呢？未来的理想状况将会是怎样的呢？
作者: Christine Stevens 先进技术的融合 航空电子系统在功能、可维护性和更新汰换等方面已经面临着重大挑战。未来的系统将在软件定义的体系结构、越来越严格的安全认证要求和遵循开放标准等方面提出更加苛刻的要求。航空电子设备的数字化转换将严重依赖于先进的软件，以便进行行动规划、轨迹预测以及与传感器融合集成的预测分析。这些系统将依据大量的数据分析来实现全新的功能，这将要求开发、部署和运行机器学习和数据分析等应用系统，由此使它们能够作为数字反馈循环的一部分，进行持续性的自我改进，获得无穷无尽的自适应能力。在CI/CD（持续集成/持续交付）以及DevSecOps合规性的要求下，目前评估软件技术就绪水平（Software Technology Readiness level,TRL）的方法可能需要重新定义。
一个典型的航空电子设备套件中可能会包含安全关键的 VxWorks  应用、嵌入式Linux应用和通用操作系统，如微软的Windows，以及其他第三方和传统的操作系统。因此，智能边缘的航空电子设备将需要具备混合临界性支持能力，其中包括：1）硬件强制隔离，由此允许安全和非安全的应用在各自独立的内核上并行运行，从而提高信息安全性、功能安全性；2）鲁棒性；3）虚拟化，用来支持多个客户操作系统。
连通新旧系统，提高成本效益 在New Horizons会议上也提到，尽管我们可能喜欢梦想未来，但现实是“我们必须运用现有的武器投入战斗”。仅仅能够连通既有的旧系统是不够的。不论是商业机构还是政府机构，各方面的客户都希望加快部署速度，降低总拥有成本，同时降低风险，还希望迁移到开源平台，整合多种硬件类型，能够适应混合级别的关键性需求，并在不同的操作环境中延续已经获得的认证。目前最新的技术是采用嵌入式虚拟化平台，从而在新一代可扩展平台上整合既有应用和以前开发的知识产权。
紧跟步伐，与时俱进 美国《2018年国防战略》发布了指令，要求“紧跟步伐，与时俱进”。对于软件开发人员来说，这意味着必须缩短开发时间，方法就是重复使用IP并准备好面对未来需求。其中的基本要求是采用满足DevSecOps合规性和CI/CD的快速开发环境，并支持“容器化即服务”(CaaS)策略。例如，风河公司采用了具备操作系统透明能力的虚拟化和隔离技术来简化既有应用的可移植性，并支持模块化体系结构，所支持的客户操作系统包括VxWorks、Linux、Windows等。我们的VxWorks容器化方法包括：智能边缘容器——既可部署在VxWorks本地环境，又可部署在VxWorks客户操作系统中。
适应网络威胁和复杂环境 为智能边缘构建的航空电子系统所需的计算环境要具备先进虚拟化功能，既有开放性又能应对恶意攻击，还要具备鲁棒性以便进行访问控制和资源分配，从而提高系统的整体完整性，这些能力在将实时性、开源和传统既有应用相融合时尤为重要。典型的虚拟化套件其设计目标是支持整个企业运作并且功能丰富（Feature Rich），这意味着受攻击层面的增加以及性能的降低。理想的航空电子虚拟化平台应包含更少的代码，从而使暴露给攻击者的弱点降至最少，还需要适应防篡改要求，以及分离性（Separation）和隔离性(Isolation)，并直接提供硬件资源以实现高确定性的性能。
风河智能边缘技术 风河公司在安全关键性、信息安全性、嵌入式Hypervisor和虚拟化解决方案等领域居于技术领先地位，有足够能力实现航空电子设备的智能边缘化——而且我们不断加快创新步伐！我们最新的Wind River Studio平台具备单一管理界面，便于加快部署，并可托管在用户自己的公共云环境中，可以确保隐私/安全/数据所有权。此外，Wind River Studio的功能还包括：
DevSecOps：采用机器学习（ML）驱动的依赖图(Dependency Graph)分析，以云规模更快地构建任何智能系统项目，实现了Build最优化 安全性：具备代码备份和用户专属安全访问机制、开源许可证合规性和安全漏洞检查性，实现了安全IP 关键任务支持：针对VxWorks和Linux提供基于云的智能系统关键任务开发环境 协作：在基于云的环境中共享项目、容器注册表、代码和工件存储库，支持跨团队协作 在支持国防系统最高层级任务方面，风河公司拥有40年的历史。我们的专长是支持客户构建智能人工智能边缘设备系统。风河公司的Helix Virtualization Platform基于市场领先的VxWorks开发而成，延续了在20多亿台设备中的软件创新成果，其中包括90多款民用和军用飞机。近25年来，NASA在每一台火星探测车中选用了VxWorks——包括最近的毅力号任务。我们期待着带您走向更远的地方！
]]></content>
  </entry>
  
  <entry>
    <title>如何在VxWorks 7下集成Python</title>
    <url>/post/app/how-to-integrate-python-into-vxworks-7.html</url>
    <categories><category>APP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Python</tag>
    </tags>
    <content type="html"><![CDATA[VxWorks是由Wind River提供的实时操作系统，而Python是由Python Software Foundation管理的开源解释型编程语言和运行时解释器。
简介 Python软件基金会：http://www.python.org
风河在PowerPC，ARM和Intel架构设备上支持Python。
这个VxWorks Python文章描述了如何将Python解释器编译和部署到VxWorks 7中。
前提 本文的说明假定你正在使用：
 Wind River VxWorks 7 SR0620 Intel target booting from UEFI BIOS A USB flash drive (4 GB minimum)  创建/编译VxWorks Source Build(VSB)项目 打开DOS shell，配置编译环境，然后编译项目。
cd &#34;WIND_HOME&#34; // your installation directory wrenv -p vxworks-7 cd // your workspace vxprj vsb create python_vsb -bsp itl_generic -smp -force -S cd python_vsb // your workspace vxprj vsb add PYTHON // add the python layer to the VSB make -j 32 // build the VSB VxWorks源代码编译(VSB)编译完成后，检查其是否包含Python运行时环境，验证以下目录是否存在：
&#34;YOUR_WORKSPACE&#34;/python_vsb/usr/3pp/deploy 创建/编译基本VxWorks Image Project(VIP) 像下面一样创建基本的VxWorks镜像工程
cd .. vxprj create -smp itl_generic python_vip -profile PROFILE_INTEL_GENERIC -vsb python_vsb cd python_vip vxprj vip component add INCLUDE_MULTI_STAGE_WARM_REBOOT vxprj vip bundle add BUNDLE_STANDALONE_SHELL vxprj parameter set DOSFS_COMPAT_NT TRUE vxprj build Note: 现在你还没有将Python解释器加进VIP
在目标机上启动VxWorks 部署uEFI的加载器以及VxWorks内核镜像 有关如何在USB闪存驱动器上编译和部署UEFI引导加载程序以及VxWorks镜像文件的说明，请参考itl_generic BSP的readme文件。在下面的路径找到此自述文件：
&#34;WIND_HOME&#34;/vxworks-7/pkgs_v2/os/board/intel/itl_generic-a.b.c.d/itl_generic_readme.md 根据下述的指令来部署uEFI启动加载器和VxWorks内核镜像后，你可以从USB闪存驱动器上找到如下文件:
 EFI BOOT bootapp.sys BOOTIA32.EFI BOOTX64.EFI  准备Intel的目标机 配置目标机的BIOS来从USB闪存驱动器启动该目标机，把该USB闪存驱动器接到目标机上。
启动目标机 给目标机上电，目标启动后，你将看到VxWorks的内核shell的提示符。
-&gt; 找到VxWorks Usb闪存驱动器的设备名称 在VxWorks内核shell上执行以下命令找出Usb闪存驱动器的设备名称。
-&gt; devs drv refs name 1 [ 3] / 7 [ 3] /bd0a 5 [ 3] /pcConsole/0 3 [ 3] /ttyS0 value = 2 = 0x2 -&gt; cd &#34;/bd0a&#34; value = 0 = 0x0 -&gt; ls EFI value = 0 = 0x0 在这个实例中，设备名称为/bd0a，记下目标机上的USB设备名称。关闭目标机，然后将USB闪存驱动器接回到工作站。
将Python运行时环境复制到Usb闪存驱动器 拷贝 “YOUR_WORKSPACE”/python_vsb/usr/3pp/deploy 到USB闪存驱动器的根目录。
更新基本的VIP以包含Python运行时环境 返回VIP的目录，并将Python运行时环境配置进VIP。
cd &#34;YOUR_WORKSPACE&#34;\\profile_vip vxprj component add INCLUDE_PYTHON_SUPPORT vxprj component add INCLUDE_FILESYSTEM_SYMLINK_CONFIG vxprj parameter setstring FILESYSTEM_SYMLINK_CONFIG_STR def=/bd0a/deploy;/bin=def/bin;/usr=def/usr;/etc=def/etc;/lib=def/lib;&#34; vxprj build 将更新的VxWorks镜像文件部署到Usb闪存驱动器 拷贝 “YOUR_WORKSPACE”/profile_vip/default/vxWorks到USB闪存驱动器，并改名为EFI/BOOT/bootapp.sys
在USB闪存驱动器的根目录中创建一个Hello World Python示例 打开文本编辑器，并在USB闪存驱动器的根目录下创建一个名为helloworld.py的文件。文件必须包含如下：
# helloworld.py import os import sys print(&#34;Hello World!&#34;) 在目标上运行Hello World Python示例程序 将USB闪存驱动器接回到目标机，然后将目标机引导到VxWorks的内核shell，在USB闪存驱动器根目录下找到helloworld.py文件，在shell上输入命令并运行此Python程序。
-&gt; cd &#34;/bd0a&#34; value = 0 = 0x0 -&gt; ls EFI helloworld.py value = 0 = 0x0 -&gt; cmd [vxWorks *]# python3 helloworld.py Launching process &#39;python3&#39; ... Process &#39;python3&#39; (process Id = 0x809aa340) launched. Hello World! [vxWorks *]# 注意：由于Python是一种解释型的语言，因此你还可以从VxWorks的内核shell上以交互的方式构建python程序。
[vxWorks *]# python3 Launching process &#39;python3&#39; ... Process &#39;python3&#39; (process ID = 0x809aa340) launched. Python 3.8.0 (default, Apr 27 2020, 17:49:25) [Clang 9.0.1.1 (ssh://diabuild@stash.wrs.com:7999/llvm/clang.git 67f1ee998a3a1d on vxWorks Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information. &gt;&gt;&gt; import os &gt;&gt;&gt; import sys &gt;&gt;&gt; print(&#34;Hello World!&#34;) Hello World! &gt;&gt;&gt; 引用 VxWorks 7 是新一代的嵌入式实时操作系统，全新的架构设计，灵活化的组件配置，高可靠性与安全性，丰富的第三方软件包，极大的方便用户的开发和使用。本文对VxWorks7 的功能做个简要的记录。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks配置多网口</title>
    <url>/post/bsp/vxworks-config-multi-network-adapter.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Network</tag>
    </tags>
    <content type="html"><![CDATA[本文提供在系统运行中对网口进行配置的方法。
概述 本文提供在系统运行中对网口进行配置的方法。
注意 开发环境：vxWorks6.9.4，workbench3.3.5。
 之前小编网上找相关资料时，有博主说使用新增网口不能与已存在的网口处于同一网段。不过经过小编的测试，两个网口ip可以处在同一网段。  使用命令行测试网络连接正常。
若网口没有连接，状态显示会缺少RUNNING字符。  验证 启动目标机，输入命令ifconfig，查看当前系统只有一个网口（gei2）。
打开datasheet，根据以太网的信息描述，实际目标机的网卡并不止一个。
打开bsp，可以看到网络驱动为GEI825XX_VXB_END，挂在VxBus下。
打开镜像工程，添加组件INCLUDE_VXBUS_SHOW。用于查看vxBus相关信息。
输入命令vxBusShow，查看当前vxBus相关信息。此时网络驱动已经注册到设备上了。
向下翻页，看到系统包含四个网口设备。
此时，我们需要配置其余的网口设备。
打开帮助文档，5.3.4章节提供了如何在运行时配置网络接口的方法。
按照提供的方法，执行命令：
ipAttach 3,&#34;gei&#34;和ifconfig &#34;gei3 10.0.0.2 netmask 255.255.255.0 up&#34;，配置gei3网口。 执行完成后，执行ifconfig，可以看到gei3已经成功配置。
使用任务管理器测试两个网口均能正常联通。
同样，我们可以为gei3网口添加ip “192.168.100.7”。
使用命令行测试网络连接正常。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks固件分析</title>
    <url>/post/bsp/vxworks-firmware-analysis.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Firmware</tag>
    </tags>
    <content type="html"><![CDATA[VxWorks 操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），是嵌入式开发环境的关键组成部分。
介绍 VxWorks 操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），是嵌入式开发环境的关键组成部分。
固件分析 固件提取的常用方式是使用binwalk工具进行分析和提取。
提取 Binwalk分析，该固件内嵌一个使用lzma压缩的二进制数据。
解压 可采用lzma命令或者binwalkh指令解压缩
 lzma   binwalk  该文件就是我们需要分析的VxWorks固件。
固件加载地址 首先需要查找VxWorks系统固件加载地址，否则系统将无法运行。加载地址将影响后面一些绝对地址的引用比如函数表及字符串的引用。
查看设备架构  ARM  IDA分析   选择ARM/little   基地址为0   VxWorks采用usrInit进行栈初始化，usrInit是VxWorks系统引导后运行的第一个函数。
LDR R0,=0x40205000 BIC R0,R0,#3 SUB RO,RO,#4 MOV SP,RO #栈执政赋值 R0=$sp+0  可知加载的基地址为0x40205000
利用符号表修复函数名 Bzero是VxWorks中一个函数，系统启动过程中会使用bzero函数对bss区的数据进行清零，因此可以利用”grep -r bzero”查找bzero函数。
$ grep -r bzero  memset  手动定位 符号表
00 05 1B 29 00 00 34 E4
文件大小和符号表大小
8字节之后就是符号表
00 00 34 E4 =&gt; 13540(10进制)
8 + 8 * 13540 = 108328(符号表偏移)-&gt;符号表位置
函数符号偏移
54 00 00 00 40 37 36 84
类型(函数) 54
符号表偏移 00 00 00 -&gt; 0
内存中的偏移 40 37 36 84
函数名称 AES_CMAC
VxHunter工具修复 自动修复函数名 该工具自动识别函数符号
项目地址:
 https://github.com/PAGalaxyLab/vxhunter.git  
总结 VxWorks固件分析，主要从内存加载地址及符号表入手，修改符号表与确定内存加载地址，对后续的漏洞挖掘起到至关重要的作用。
]]></content>
  </entry>
  
  <entry>
    <title>风河推VxWorks 7 到底与VxWorks 6.x的区别在哪里</title>
    <url>/post/news/difference-between-vxworks-6-and-vxworks7.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>WindRiver</tag>
      <tag>VxWorks 6</tag>
      <tag>VxWorks 7</tag>
    </tags>
    <content type="html"><![CDATA[随着计算机技术的迅速发展和芯片制造工艺的不断进步，嵌入式微处理器的应用日益广泛。从波音飞机到移动终端，都有嵌入式微处理器的存在。在嵌入式微处理器的应用开发中，嵌入式实时操作系统(RTOS)是核心软件。
目前市场上，风河公司VxWorks一直被认为是业界领先的RTOS，其长期持续在VxWorks方面的研发河投资，为各个行业市场提供了久经验证、值得信赖的嵌入式系统解决方案，特别是提供了多核设备的支持。在每个版本VxWorks的发布中，风河都持续不断地改进系统性能，扩展硬件支持，有力地支持了新一代设备软件的实现。
风河之所以在业内拥有独一无二的优势，一定程度上得益于市场领先的操作系统阵容。该操作系统阵容由包括VxWorks在内的运行时间技术、风河Linux和Android技术以及在多核架构和迁移策略方面拥有丰富经验、阵容强大的全球专业服务团队组成。
VxWorks新平台 确保三年稳定 物联网的突然闯入，改变了嵌入式行业的格局， ROTS  不仅必须具备传统的核心实时、确定性性能和可靠性，还必须提供高度互联、全面安全、远程管理等物联网环境所需要的全新能力。作为RTOS领域的领导者，风河公司在2010年推出了全新的 VxWorks 7  平台，再一次强化了市场地位，彰显了其对于帮助企业客服并且把握物联网所带来的全新挑战河机会的愿景。
笔者近期非常有幸的采访到了风河公司产品线经理Stephen Olsen，在谈到VxWorks升级后所带来的新功能时，他表示，VxWorks 7新的模块化架构，使用户能够对系统组件和协议实施高效且有针对性的升级，无需改变系统内核，从而最大限度地减少了测试和重新认证的工作量，确保客户系统始终能够采用最先进的技术。
Stephen Olsen强调，VxWorks 7中最主要的改变是这个平台是三年都是稳定的，风河公司三年都不会去动它整个的结构，不管是文件系统的管理还是网络，各个功能就类似于安装包一样上去的。如此一来，对风河公司的合作伙伴的好处是他们不需要跟着风河的改版本而去改他们的版本。通过稳定的平台，带给合作伙伴最大的便利。
不仅如此，VxWorks 7平台将微内核与标准内核融为一体，使用户能够在不同类别的设备上运用同一个RTOS基础，适用范围十分广泛，从小型消费者可穿戴设备到大型组网设备以及介于二者之间的各类设备，从而降低了开发和维护成本。
平滑演进 版本升级无忧虑 众所周知，风河公司VxWorks平台在过去的一段时间内，积累的了大量的用户，此次升级对于用户来说，怎么样去平滑演进到最新的版本成了首要问题。为此Stephen Olsen表示，为了方便用户从VxWorks的旧版本转移到新版本上来，VxWorks 7的内核支持VxWorks 6内核操作环境，大多数用于VxWorks 6的板级支持包、驱动程序和用户应用程序都可以在VxWorks 7内核运行，并且开发的一些API也是一样的。对于开发者用户在用的时候，变化并没有那么直接、那么大。这也是因为风河公司在后台做了很多的事情，扫除了用户在升级过程中的顾虑。
Kontron产品经理Hubert Hafner就曾表示，“VxWorks 7的模块化架构令我们深感兴奋，将使我们通过有效纠错和添加新功能的方式，无需返工或者重新测试系统即可让我们的嵌入式产品在整个寿命期内保持竞争力。由于其体积较小，我们认为VxWorks 7将能够完美匹配本公司对于降低产品体积、重量以及功耗要求极其严格的产品。我们对于VxWorks 7纳入基于Open VG的图形栈、蓝牙、Continua以及新的基于标准的Wind River Workbench 4开发套件表示欢迎。Kontron期待着将最新版的VxWorks 7用于我们现有以及未来的嵌入式产品，并且很方便地从之前版本过渡到VxWorks 7。”
同样，新平台的安全性依然是用户比较关注的问题。笔者了解到，VxWorks可信系统平台在特殊换下的安全性表现历来良好。作为一款高可靠性实时操作系统，VxWorks具有硬实时性与确定性，可满足最高安全标准。
值得一提的是，风河公司还为合作伙伴提供了专业的服务，可以帮助企业降低风险、提升竞争力。专业服务围绕VxWorks平台提供多种服务，除了安装、指导、设计及其他服务以外，还包括板级支持包的开发与定制、选定硬件的启动优化河安全启动服务。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks系统中vxbus机制总结</title>
    <url>/post/bsp/vxworks-vxbus-mechanism.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>vxbus</tag>
    </tags>
    <content type="html"><![CDATA[先介绍一下 VxWorks  的设备以及驱动的表示方法，以及总的关系：设备和驱动根本都抽象成一个结构体，设备结构体中包含了设备名字、ID号、功能函数指针等必备的信息，驱动结构体包含了初始化函数、名字、ID等信息。总的如图看一下重要的几个结构体的关系：
vxbus结构设计了几个链表：
/*放置驱动的链表*/ struct vxbDevRegInfo * pDriverListHead = NULL; /*放置注册的总线的链表*/ struct vxbBusTypeInfo * pBusListHead = NULL; /*匹配好的设备和驱动称为instlist，没有找到驱动的设备链表，*/ struct vxbBusPresent * pBusHead = NULL; 当一个设备注册进来之后，就会从pDriverListHead中查找驱动，如果找到了就会放到pBusHead链表中的instList链表中，没有找到驱动就会放置到pBusHead-&gt;devList中；而当一个新的总线注册进来后就会放置到pBusListHead链表中。
vxbus的初始化。 vxbus的初始化流程中的函数调用：
usrInit sysHwInit hardWareInterFaceInit hardWareInterFaceBusInit vxbLibInit (vxbInitPhase = 0) plbRegister vxbInit(vxbInitPhase = 1) plbInit1 usrRoot sysClkInit sysClkConnect sysHwInit2 vxbDevInit vxbDevInitInternal (vxbInitPhase = 2) vxbDevInit2Helper(对所有设备进行) vxbDevConnect vxbDevConnectInternal(vxbInitPhase = 3) vxbDevConnectHelper(对所有设备进行) vxbus的初始化分为按照vxbInitPhase=0,1,2,3分为4部分进行，接下来分别进行介绍。
vxbInitPhase=0时：函数vxbLibInit所做工作&quot;
STATUS vxbLibInit (void) { vxbInitPhase = 0; return(OK); } 只是声明了这是vxbInitPhase=0阶段，之后就是驱动函数的注册。也就是说0阶段只要是驱动函数的注册。
vxbInitPhase=1：
STATUS vxbInit (void) { vxbInitPhase = 1; plbInit1(pPlbDev); return(OK); } STATUS plbInit1 ( struct vxbDev * pCtlr ) { int i, j; char regBase[] = &#34;regBase0&#34;; struct vxbDev * pDev; HCF_DEVICE * pHcf; VXBPLB_DEBUG_MSG1(&#34;plbInit1() called\n&#34;, 1,2,3,4,5,6); #ifdef	VXB_LEGACY_ACCESS  /* call the function to initialize the access module of PLB */ plbAccessInit (); #endif	/* VXB_LEGACY_ACCESS */ /* * now populate the bus with devices from the table created by the * configuration tool */ for ( i = 0 ; i &lt; hcfDeviceNum ; i++ ) { if ( hcfDeviceList[i].busType != VXB_BUSID_PLB ) { VXBPLB_DEBUG_MSG1(&#34;plbInit1(): skipping non-PLB device %s\n&#34;, (int)hcfDeviceList[i].devName, 2,3,4,5,6); } else { VXBPLB_DEBUG_MSG1(&#34;plbInit1(): processing device %s\n&#34;, (int)hcfDeviceList[i].devName, 2,3,4,5,6); pHcf = &amp;hcfDeviceList[i]; /* allocate device structure */ pDev = vxbDevStructAlloc(WAIT_FOREVER); if ( pDev == NULL ) { return(ERROR); } /* bus subsystem overhead */ pDev-&gt;busID = VXB_BUSID_PLB; pDev-&gt;pNext = NULL; /* save resources with device */ pDev-&gt;pBusSpecificDevInfo = (void *)&amp;hcfDeviceList[i]; /* access functions */ #ifdef	VXB_LEGACY_ACCESS  pDev-&gt;pAccess = (pVXB_ACCESS_LIST)hwMemAlloc(sizeof(VXB_ACCESS_LIST)); if ( pDev-&gt;pAccess == NULL ) { /* hwMemFree((char *)pDev); */ vxbDevStructFree(pDev); return(ERROR); } /* copy the arch specific access function pointers */ vxbPlbAccessCopy (pDev-&gt;pAccess); #endif	/* VXB_LEGACY_ACCESS */ /* nothing needs to be done if the return value is not ok */ /* assign register base address */ for (j = 0; j &lt; VXB_MAXBARS; j++) { pDev-&gt;pRegBase[j] = 0; /* * Decode all BARs labeled &#34;regBase0&#34; to &#34;regBase9.&#34; For * backwards compatibility, &#34;regBase0&#34; and &#34;regBase&#34; are * equivalent. */ regBase[7] = &#39;0&#39;+j; /* Avoid use of sprintf()/strcat()/etc) */ /* * resourceDesc { * The regBaseN resources specify up to 10 * base addresses for device registers (N = [0-9]). } */ if (devResourceGet (pHcf, regBase, HCF_RES_INT, (void *)&amp;(pDev-&gt;pRegBase[j])) != OK &amp;&amp; j == 0) /* * resourceDesc { * The regBase resource is synonymous with regBase0. } */ devResourceGet (pHcf, &#34;regBase&#34;, HCF_RES_INT, (void *)&amp;(pDev-&gt;pRegBase[j])); /* * On x86, local bus devices are assumed to be * accessed using I/O space registers. Everywhere * else, registers are simply memory mapped. */ if (pDev-&gt;pRegBase[j] == NULL) pDev-&gt;regBaseFlags[j] = VXB_REG_NONE; else #if (CPU_FAMILY == I80X86)  pDev-&gt;regBaseFlags[j] = VXB_REG_IO; #else  pDev-&gt;regBaseFlags[j] = VXB_REG_MEM; #endif  } /* bus-specific info */ pDev-&gt;u.pSubordinateBus = NULL; /* device name */ pDev-&gt;pName = hcfDeviceList[i].devName; /* update the device unit number */ pDev-&gt;unitNumber = hcfDeviceList[i].devUnit; /* per-driver info -- filled in later */ pDev-&gt;pDrvCtrl = NULL; /* dev bus handle is controller&#39;s subordinate bus */ pDev-&gt;pParentBus = pCtlr-&gt;u.pSubordinateBus; /* interrupt information from the configuration */ devResourceIntrGet(pDev, pHcf); VXBPLB_DEBUG_MSG1(&#34;plbInit1(): announcing device %s\n&#34;, (int)pDev-&gt;pName, 2,3,4,5,6); /* we now have the device, so let the bus subsystem know */ (void) vxbDeviceAnnounce(pDev); VXBPLB_DEBUG_MSG1(&#34;plbInit1(): device %s OK\n&#34;, (int)pDev-&gt;pName, 2,3,4,5,6); } } return(OK); } 这个函数所做的主要工作就是对系统中所定义的设备进行结构体的构建，也就是为每个设备抽象一个结构体，并按照所定义的信息对结构体进行填充。
STATUS vxbDeviceAnnounce ( struct vxbDev * pDev /* device information */ ) { struct vxbBusTypeInfo * pBusEntry; struct vxbBusTypeInfo * busMatch = NULL; BOOL drvFound = FALSE; struct vxbDevRegInfo * pDrv; struct vxbBusPresent * pBus; FUNCPTR pMethod; if ( pPlbDev == NULL &amp;&amp; pDev-&gt;busID == VXB_BUSID_LOCAL ) { pPlbDev = pDev; return(OK); } VXB_DEBUG_MSG(1,&#34;vxbDeviceAnnounce(0x%08x(%s))\n&#34;, (int)pDev, (int)pDev-&gt;pName, 3,4,5,6); if (pPlbDev != NULL) { pMethod = vxbDevMethodGet(pPlbDev, DEVMETHOD_CALL(sysBspDevFilter)); if (pMethod != NULL) { if ((*pMethod)(pDev) != OK) { VXB_DEBUG_MSG(1, &#34;vxbDeviceAnnounce(0x%08x(%s)) excluded by BSP\n&#34;, (int)pDev, (int)pDev-&gt;pName, 3,4,5,6); return ERROR; } } } /* acquire global lock as reader */ vxbLockTake(&amp;vxbGlobalListsLock, VXB_LOCK_READER); for ( pBusEntry = pBusListHead ; pBusEntry != NULL ; pBusEntry = pBusEntry-&gt;pNext ) { /* check for matching bus type */ if ( pBusEntry-&gt;busID != pDev-&gt;busID ) continue; for ( pDrv = pDriverListHead ; pDrv != NULL ; pDrv = pDrv-&gt;pNext ) { VXB_DEBUG_MSG(1,&#34;vxbDeviceAnnounce(): checking 0x%08x (%s) &#34; &#34;against %s\n&#34;, (int)pDev, (int)pDev-&gt;pName, (int)&amp;pDrv-&gt;drvName[0], 4,5,6); if ( pDrv-&gt;busID != pDev-&gt;busID ) { VXB_DEBUG_MSG(1,&#34;vxbDeviceAnnounce(): &#34; &#34;%s@%p failed type check\n&#34;, (int)pDev-&gt;pName, (int)pDev, 3,4,5,6); continue; } /* check bus-specific match routine */ drvFound = (*(pBusEntry-&gt;vxbDevMatch))(pDrv, pDev); if ( ! drvFound ) { VXB_DEBUG_MSG(1,&#34;vxbDeviceAnnounce(): &#34; &#34;%s@%p failed bus match\n&#34;, (int)pDev-&gt;pName, (int)pDev, 3,4,5,6); continue; } busMatch = pBusEntry; /* check driver-supplied probe routine */ if ( pDrv-&gt;devProbe == NULL ) { VXB_DEBUG_MSG(1,&#34;vxbDeviceAnnounce(): &#34; &#34;no driver probe available\n&#34;, 1,2,3,4,5,6); drvFound = TRUE; } else { VXB_DEBUG_MSG(1, &#34;vxbDeviceAnnounce(): &#34; &#34;calling driver probe\n&#34;, 1,2,3,4,5,6); drvFound = (*(pDrv-&gt;devProbe))(pDev); if ( drvFound == FALSE ) { VXB_DEBUG_MSG(1, &#34;vxbDeviceAnnounce(): &#34; &#34;driver probe failed\n&#34;, 1,2,3,4,5,6); continue; } } VXB_DEBUG_MSG(1, &#34;vxbDeviceAnnounce(): &#34; &#34;found match, driver @ %p\n&#34;, (int)pDrv, 2,3,4,5,6); /* attach driver registration info */ pDev-&gt;pDriver = pDrv; /* adjust name */ pDev-&gt;pName = &amp;pDrv-&gt;drvName[0]; /* get parent bus */ pBus = (struct vxbBusPresent *)pDev-&gt;pParentBus; if ( pBus == NULL ) pBus = pPlbBus; /* acquire the lock */ vxbLockTake(&amp;pBus-&gt;listLock, VXB_LOCK_WRITER); /* add this instance to bus device list */ vxbInstInsert (&amp;pBus-&gt;instList, pDev); /* release the lock */ vxbLockGive(&amp;pBus-&gt;listLock, VXB_LOCK_WRITER); /* perform initialization */ vxbDevInitRun(pDev, pDrv); break; } } /* release global lock */ vxbLockGive(&amp;vxbGlobalListsLock, VXB_LOCK_READER); if ( drvFound == FALSE ) { /* get parent bus */ pBus = (struct vxbBusPresent *)pDev-&gt;pParentBus; /* if the parent bus is NULL, add to the global list of lost devices */ if ( pBus == NULL ) { #ifdef VXB_PERFORM_SANITY_CHECKS  /* acquire the lock */ vxbLockTake(&amp;vxbLostDevListLock, VXB_LOCK_WRITER); vxbInstInsert (&amp;pLostDevHead, pDev); /* release the lock */ vxbLockGive(&amp;vxbLostDevListLock, VXB_LOCK_WRITER); #endif /* VXB_PERFORM_SANITY_CHECKS */ return(ERROR); } /* insure pDriver is initialized */ pDev-&gt;pDriver = NULL; /* acquire the lock */ vxbLockTake(&amp;pBus-&gt;listLock, VXB_LOCK_WRITER); /* keep track of unattached device */ vxbInstInsert (&amp;pBus-&gt;devList, pDev); /* release the lock */ vxbLockGive(&amp;pBus-&gt;listLock, VXB_LOCK_WRITER); } return OK; } 每当一个设备的结构体初始化完成时，也就是一个设备构建完成，这时调用vxbDeviceAnnounce，告诉系统有新设备了。vxbDeviceAnnounce的功能就是在驱动链表中进行查找，看有没有与当前设备匹配的驱动，分别比对name,之后比对ID，如果相同就匹配完成，放到pBusHead-&gt;instList链表中，如果没有驱动就放到pBusHead-&gt;devlist中，之后调用函数vxbDevInitRun：
LOCAL void vxbDevInitRun ( VXB_DEVICE_ID devID, struct vxbDevRegInfo * pDrv ) { /* first pass */ if (!(devID-&gt;flags &amp; VXB_INST_INIT_DONE)) { if ( pDrv-&gt;pDrvBusFuncs-&gt;devInstanceInit != NULL ) (*(pDrv-&gt;pDrvBusFuncs-&gt;devInstanceInit))(devID); devID-&gt;flags |= VXB_INST_INIT_DONE; } /* second pass */ if (vxbInitPhase &gt;= 2 &amp;&amp; !(devID-&gt;flags &amp; VXB_INST_INIT2_DONE)) { if ( pDrv-&gt;pDrvBusFuncs-&gt;devInstanceInit2 != NULL ) (*(pDrv-&gt;pDrvBusFuncs-&gt;devInstanceInit2))(devID); devID-&gt;flags |= VXB_INST_INIT2_DONE; } /* third pass */ if (vxbInitPhase &gt;= 3 &amp;&amp; !(devID-&gt;flags &amp; VXB_INST_CONNECT_DONE)) { if ( pDrv-&gt;pDrvBusFuncs-&gt;devInstanceConnect != NULL ) (*(pDrv-&gt;pDrvBusFuncs-&gt;devInstanceConnect))(devID); devID-&gt;flags |= VXB_INST_CONNECT_DONE; } } vxbDevInitRun的作用就是分别调用设备的初始化函数，对设备进行初始化。 这时第一阶段的初始化就完成了，完成工作：大部分设备和驱动已经进行了匹配，并放入到相应的链表中，并且匹配好的设备进行了第一阶段的初始化。但是此时请注意了，因为部分设备没有匹配到驱动，放入到了pBusHead-&gt;devlist中，那这个设备也就没有进行初始化操作。所以之后的第二第三阶段的初始化操作，主要是对这些没有匹配成功的设备进行的。
vxbInitPhase=2时：
STATUS vxbDevInitInternal (void) { vxbInitPhase = 2; pVxbSpinLockTake = spinLockIsrTake; pVxbSpinLockGive = spinLockIsrGive; vxbLockInit(&amp;vxbGlobalListsLock); vxbLockInit(&amp;vxbBusListLock); #ifdef VXB_PERFORM_SANITY_CHECKS  vxbLockInit(&amp;vxbLostDevListLock); #endif /* VXB_PERFORM_SANITY_CHECKS */ vxbLockInit(&amp;vxbDevStructListLock); /* execute init phase 2 for all devices */ vxbDevIterate(vxbDevInit2Helper, NULL, VXB_ITERATE_INSTANCES); return(OK); } LOCAL STATUS vxbDevInit2Helper ( struct vxbDev * pInst, void * pArg ) { if ( pInst-&gt;pDriver == NULL ) return(OK); if ( pInst-&gt;pDriver-&gt;pDrvBusFuncs == NULL ) return(ERROR); if (pInst-&gt;flags &amp; VXB_INST_INIT2_DONE) return (ERROR); if ( pInst-&gt;pDriver-&gt;pDrvBusFuncs-&gt;devInstanceInit2 == NULL ) return(OK); (*pInst-&gt;pDriver-&gt;pDrvBusFuncs-&gt;devInstanceInit2)(pInst); pInst-&gt;flags |= VXB_INST_INIT2_DONE; return(OK); } 此时是对总线plb上所有的设备进行初始化操作，也就是会对那些没有初始化的也进行初始化。
vxbInitPhase=3时：
STATUS vxbDevConnectInternal (void) { vxbInitPhase = 3; vxbDevIterate(vxbDevConnectHelper, NULL, VXB_ITERATE_INSTANCES); if (_func_vxbUserHookDevInit != NULL) (*_func_vxbUserHookDevInit)(); return(OK); }	LOCAL STATUS vxbDevConnectHelper ( struct vxbDev * pInst, /* device information */ void * pArg ) { if ( pInst-&gt;pDriver == NULL ) return(OK); if ( pInst-&gt;pDriver-&gt;pDrvBusFuncs == NULL ) return(ERROR); if (pInst-&gt;flags &amp; VXB_INST_CONNECT_DONE) return (ERROR); if ( pInst-&gt;pDriver-&gt;pDrvBusFuncs-&gt;devInstanceConnect == NULL ) return(OK); (*pInst-&gt;pDriver-&gt;pDrvBusFuncs-&gt;devInstanceConnect)(pInst); pInst-&gt;flags |= VXB_INST_CONNECT_DONE; return(OK); } 第三阶段也是对所有的设备进行的。
这样经过三个阶段的初始化之后，所有的设备都进行了初始化。vxbus也就初始化完成了。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks内核解读-1</title>
    <url>/post/bsp/vxworks-wind-kernel-analysis-1.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Wind Kernel</tag>
    </tags>
    <content type="html"><![CDATA[本文首先从实时内核的定义出发，对实时操作系统进行了介绍，并对实时操作系统的特点进行了说明，接着从内核的功能和结构角度介绍了整体式内核，层次式内核，以及微内核。最后对具有微内核特性的VxWorks Wind内核进行了介绍。
前言：我曾经在做VxWorks培训期间跟身边的嵌入式工程师同行交流的时候，发现大家对嵌入式VxWorks系统的Wind内核不是特别了解，而网上对于VxWorks的Wind内核也没有系统性的解读与分析，因此我决定发表一系列的博文来系统性地解读Wind内核的设计思想。我选择的是VxWorks5.5系统的Wind 2.6版本内核（这个版本的代码网上都有分享O(∩_∩)O），在分析的过程中，大家有任何的疑问，都可以给我留言，以便我进一步的完善博文，使得后来者阅读起来更为流畅。
实时内核概述 “实时”表示控制系统能够及时处理系统中发生的要求控制的外部事件。从事件发生到系统产生响应的反应时间称为延迟(Latency)。对于实时系统，一个最重要的条件就是延迟有确定的上界(这样的系统属于确定性系统)。满足这个条件后，根据这个上界大小再区分不同实时系统的性能。这里的“系统”是从系统论的观点讲的一个功能完整的设计，能够独立和外部世界交互、实现预期功能。这包括实时硬件系统设计、实时操作系统设计、实时多任务设计3部分。后两者可以概括为实时软件系统设计。实现实时系统是这3部分有机结合的结果。
从另外一个角度，即实时程度看，可以把系统分为硬实时系统和软实时系统。硬实时系统是这样一种系统，它的时间要求有一个确定的截止期限(Deadline)，超出截止期限的响应，即使计算无误，也是无法容忍的错误结果，通常会引起严重的后果，这样的系统属于硬实时系统。对于软实时系统来说，“实时性”仅仅是“程度”概念，在提交诸如中断、计时和调度的操作系统服务时，系统定义一个时间范围内的延迟。在该范围内，越早给出响应越有价值，只要不超出范围，晚点给出的结果价值下降，但可以容忍。
因此一个RTOS内核必须满足许多特定的实时环境所提出的基本要求，这些包括：
 多任务：由于真实世界的事件的异步性，能够运行许多并发进程或任务是很重要的。多任务提供了一个较好的对真实世界的匹配，因为它允许对应于许多外部事件的多线程执行。系统内核分配CPU给这些任务来获得并发性。 抢占调度：真实世界的事件具有继承的优先级，在分配CPU的时候要注意到这些优先级。基于优先级的抢占调度，任务都被指定了优先级， 在能够执行的任务（没有被挂起或正在等待资源）中，优先级最高的任务被分配CPU资源。换句话说，当一个高优先级的任务变为可执行态(Wind内核中称为就绪态Ready State)，它会立即抢占当前正在运行的较低优先级的任务。 快速灵活的任务间的通信与同步：在一个实时系统中，可能有许多任务作为一个应用的一部分执行。系统必须提供这些任务间的快速且功能强大的通信机制。内核也要提供为了有效地共享不可抢占的资源或临界区所需的同步机制。 方便的任务与中断之间的通信：尽管真实世界的事件通常作为中断方式到来，但为了提供有效的排队、优先化和减少中断延时，我们通常希望在任务级处理相应的工作(uC/OS-III内核采用了这种策略)。所以需要任务级和中断级之间存在通信。 性能边界：一个实时内核必须提供最坏情况的性能优化，而非针对吞吐量的性能优化。我们更期望一个系统能够始终以50微妙(us)执行一个函数，而不期望系统平均以10微妙(us)执行该函数，但偶尔会以75微妙(us)执行它。 特殊考虑：由于对实时内核的要求的增加，必须考虑对内核支持不断增加的复杂功能的要求。这包括多进程处理(比如VxWorks RTP)，对更新的、功能更强的处理器结构(比如Multicore CPU)的支持。  实时硬件系统设计 实时硬件系统设计是其它两部分的基础。实时硬件系统设计要求在满足软件系统充分高效的前提下，必须提供足够的处理能力。例如，硬件系统提供的中断处理逻辑能同时响应的外部事件数量、硬件反应时间、内存大小、处理器计算能力、总线能力等，以保证最坏情况下所有计算仍然得以完成。多处理的硬件系统还包括内部通信速率设计。当硬件系统不能保证达到实时要求时，可以确信整个系统不是实时的。目前，各种硬件速度不断提高，先进技术大量涌现，硬件在大多数应用中已经不是实时系统的瓶颈。因而，实时系统的关键集中在实时软件系统设计，这方面也成了实时性研究的主要内容，也是最复杂的部分。许多场合甚至对实时硬件系统和实时操作系统不加区分。
实时操作系统设计 先来看实时操作系统性能评价的几个主要指标：
 中断延迟时间：对一个实时操作系统来说，最重要的指标就是中断关了多长时间，所有实时系统在进入临界区代码段之前都要关中断，执行完临界代码之后再开中断。关中断的时间越长，中断延迟就越长。因此中断延迟时间可以表述为关中断的最长时间与开始执行中断服务子程序第一条指令的时间之和，有时也表述为从系统接收中断信号到操作系统做出响应，进入中断服务程序的时间。 中断响应时间：中断响应时间定义为从中断发生到开始执行用户中断服务子程序代码来处理这个中断的时间。中断响应时间包括开始处理这个中断前的全部开销。中断响应时间包含了中断延迟时间，因此在考虑一个实时系统对外部中断的处理时间时，通常指考虑中断响应时间。典型地将执行用户代码之前保护现场，将CPU 的各寄存器推入堆栈的时间记为中断响应时间。 任务切换时间：多任务之间进行切换所花费的时间，即从前一个任务开始保存上下文的第一条指令开始，到后一个任务恢复上下文开始运行第一条指令为止的时间段。 从实时性角度看，操作系统经历了前后台系统、分时操作系统和实时操作系统3个阶段。  前后台系统(Foreground/Background System)其实没有操作系统，系统中只运行一个无限主循环，没有多任务的概念，但是通过中断服务程序响应外部事件。在前后台系统中，对外部事件的实时响应特性从两方面看。
 中断延迟时间：主循环一般保持中断开放状态，因此前后台系统中断响应非常快，并且通常允许嵌套； 中断响应时间：需要经历一次主循环才能对中断服务程序中采集的外部请求进行处理，因此系统响应时间决定于主循环周期。 分时操作系统(Time-sharing Operating System)将系统计算能力分成时间片，按照一定的策略分配给各个任务，通常在分配过程中追求某种意义上的公平，分时操作系统不保证实时性。  实时操作系统(RTOS)的目的是实现对外部事件的实时响应，即根据前面对实时性的定义，实时操作系统必须在确定的时间内给出响应。实时操作系统必须满足下面4个条件：
 可抢占式的优先级调度内核，当一个运行着的任务使一个比它优先级高的任务进入了就绪态，当前任务的CPU 使用权就被剥夺了，或者说被挂起了，那个高优先级的任务立刻得到了CPU的控制权，即始终保证优先级最高的任务拥有CPU使用权，如图1.1所示   中断具有优先级，且中断可嵌套，即高优先级的中断可以打断正在执行的低优先级中断处理程序，优先得到执行，等到其处理完毕再回到低优先级的任务继续执行， 防止优先级反转，系统服务的优先级由请求该服务的任务的优先级确定，具有优先级保护机制，以防止优先级翻转；优先级翻转式指当一个高优先级的任务被迫等待一个低优先级的任务不确定的完成时间的时候，优先级反转将会发生。考虑下面的情景：任务T1、T2、T3是三个优先级依次降低的任务。T3已经通过获取与保护资源相关的信号量，从而获取了这些资源。当T1抢占T3通过获取相同的信号量来竞争这些资源的时候，T3将会被阻塞。如果我们能够保证T1阻塞的时间不会长于T3正在执行后释放这些资源的时间，情况不会发生特别严重，毕竟T1占用的这个资源是不可抢占的。但是低优先级的任务是脆弱的，通常会被中等优先级的任务所抢占。例如此时的T2，这将会使T3无法释放T1需要的资源。这种情况将会一直存在，将会使得处于最高优先级的T1阻塞的时间不确定。示意图如1.2。  优先级反转示意图 上述问题的一种解决方法是使用优先级继承协议(Priority Inheritance Protocol)。当高优先级任务需要低优先级任务占用资源时，将低优先级任务的优先级别提高到和高优先级同样的级别，即相当于低优先级任务继承高优先级任务的优先级级别；防止优先级翻转的另外一种协议是优先级天花板（Priority Ceiling），其设计策略是对优先级翻转采取“预防”，而不是“补救”。也就是说：不论是否阻塞了高优先级任务，持有该协议的任务在执行期间都被赋予优先级天花板所占用的优先级，以使任务尽快完成操作，因此可以把任务优先级天花板看作是更“积极”的一种保护优先级的方式，我们在后面的博文中将会详细分析者两种方案的设计与实现。
 实时操作系统(RTOS)的性能评价指标(中断响应时间和任务切换时间)具有固定上界。 满足上面4个必要条件后，RTOS内核具体的实现机制就决定了其实时性的优劣。VxWorks的Wind内核是一个真正的实时微内核，满足上述条件。同时wind内核采取单一实时地址空间，任务切换开销非常低，相当于在UNIX这样的主机上切换到相同进程内的另一个线程，并且没有系统调用开销。高效的实时设计使Wind内核在从工业现场控制到国防、航空等众多领域中表现出优秀的实时性(严格的说用在航空领域的是VxWorks 653版本)。  微内核操作系统设计理念 传统上，一个操作系统分为核心态和用户态。内核在核心态运行，为用户态的应用程序提供服务。内核是操作系统的灵魂和中心，决定了操作系统的效率和应用领域。在设计操作系统时，内核包含哪些功能以及内核功能采取何种组织结构，都是由设计者决定的。从内核功能和结构特点看，操作系统具有单体式内核、层次式内核、微内核三种不同形式。
单体式内核以过程集合的方式编写，链接成一个大型可执行的二进制程序。使用这种技术，系统中的每一个过程可以自由调动其它过程，只有后者提供了前者需要的一些有用的计算工作。这些可以不受限制，彼此调用的成千个过程，常常导致出现一个笨拙且难以理解的系统。单体式内核结构的操作系统不进行任何的数据封装和隐藏，在具有较高效率的同时，存在着难以扩展和升级的缺点。
层次式内核结构的操作系统将模块功能划分为不同层次，下层模块封装内部细节，上层模块调用下层模块提供的接口。Unix，Linux，Multics等属于层次结构操作系统。层次化使操作系统结构简单，易于调试和扩展。单体式内核和层次式内核结构如图1.3所示。
整体式内核和层次式内核结构图 不管单体式结构，还是层次式结构，它们的操作系统都包括了许多将其用于各种可能领域时需要的功能，故被称为宏内核(Monolithic kernel)操作系统，整个核心程序都是以核心空间(Kernel Space)的身份及监管者(也称特权)模式(Supervisor Mode)来运行，以至于可以认为该内核本身便是一个完整的操作系统。以UNIX为例，其内核包括了进程管理、文件系统、设备管理、网络通信等功能，用户层仅仅提供一个操作系统外壳和一些实用工具程序。
用层次式方法设计操作系统，设计者需要确定在哪里划分内核-用户的边界。在传统上，所有的层都在内核中，但是这样做是没有必要的。事实上，尽可能减少内核态功能的做法更好，因为内核中的错误会快速拖累系统；相反可以把用户级任务设置位较小的权限，这样某一个错误的后果将不是致命的。微内核的设计思想是，为了实现其高可靠性，将操作系统划分为小的、定义良好的模块，只有其中一个模块(微内核模块)运行在内核态上，其余的模块由于功能相对较弱，则作为普通用户任务运行。特别的是地，由于把每个设备驱动和文件系统分别作为普通任务，这些模块中的错误虽然会使得这些模块崩溃，但不会使得整个系统死机。例如在音频驱动中的错误会使得声音断续或者停止，但是不会使这个计算机系统崩溃。相反在宏内核操作系统中，由于所有的设备驱动都在内核中，一个有故障的音频驱动很容易导致无效的地址引用，进而造成恼人的系统停机。
有许多微内核已经实现并投入应用。微内核在实时、工业、航空以及军事应用中特别流行，因为这些领域都是关键任务，需要有高度的可靠性。因此嵌入式操作系统大多采用微内核结构。微内核操作系统是近二十年新发展起来的技术，内核非常小但效率高，从数十KB到数百KB字节，适合于资源相对有限的嵌入式应用。微内核将很多通用操作的功能从内核中分离出来（如文件系统，设备驱动，网络协议栈等），只保留最基本的内容。知名的内核有Green Hills Software公司开发的INTEGRITY实时操作系统，windriver系统公司开发的vxWorks，黑莓手机(BlackBerry)制造商RIM(Research In Motion Ltd.，RIM)使用的QNX实时系统，以及L4、PikeOS、Minix3等。
备注：从微内核模块运行在CPU核心态上，其它模块运行在非核心态，这个角度来说，VxWorks的Wind内核并不能算是严格意义上的微内核系统。Wind内核通过全局变量kernelState模拟了Wind内核的特权态。Wind内核中以wind*开头的例程构成Wind内核的核心服务例程。当kernelState为FALSE时，意味着Wind内核此时没有程序访问，VxWorks的外围模块可以调试Wind内核的核心服务例程；当kernelState为TRUE时，意味着其它程序正在使用内核态例程，当前需要调用核心服务例程的程序必须放置到延迟队列中，直到处于核心态的程序退出内核态(即kernelState为FALSE)，延迟的内核态例程才会被执行，从这里我们可以看出，kernelState模拟的核心态是非抢占式的。VxWorks的wind内核采用全局变量模拟了核心态服务例程，在加上其高度的可配置型，也具有一般微内核操作系统所具有的的特性。
一般认为微内核操作系统具有如下优点：
 统一的接口，在用户态和核心态之间无需进行识别； 可伸缩性好，易于扩充，能适应硬件更新和应用变化； 可移植性好，操作系统要移植到不同的硬件平台上，只需修改微内核中极少代码即可； 实时性好，内核响应速度快，可以方便地支持实时处理； 安全可靠性高，微内核将安全性作为系统内部特性来进行设计，对外仅使用少量应用编程接口。 由于操作系统核心常驻内存，而微内核结构精简了操作系统的核心功能，内核规模比较小，一些功能都移到了外存上，所以微内核结构十分适合嵌入式的专用系统，如图1-4所示的VxWorks系统结构，大家可以直观的感受到Wind内核在VxWorks系统中的地位O(∩_∩)O。  图1-4 VxWorks系统结构
wind微内核设计 为了提高微内核效率，有两种实现模式：受保护的虚地址空间模式和无保护的单一实地址空间模式。前者在宏内核操作系统（如Unix）和某些微内核操作系统（如QNX，Minix3）中采用。这种模式的优点是显而易见的：任务独立运行、不受其他任务错误影响、系统可靠性高。
VxWorks的Wind内核采取单一实地址空间模式，所有任务在同一地址空间运行，不区分核心态和用户态。其优势在于：
 任务切换时不需要进行虚拟地址空间切换； 任务间可以直接共享变量，不需要通过内核在不同的地址空间复制数据； 系统调用时不需要在核心态和用户态之间切换，相当于直接的函数调用。  备注：系统调用需要从用户态切换到核心态，以执行用户态下不能执行的操作，在许多处理器上这是通过一条等价于系统调用的TRAP指令实现的，在执行该指令前要经过严格的参数检查。VxWorks中不存在这样的切换，因此系统调用和一般函数调用没有什么差别。但本系列博文中仍然沿用一般说法。
对于两种模式孰优孰劣，各自的支持者们进行了大量的争论。比较各有所长的东西往往非常困难。本文倾向于认为，对于嵌入式实时应用，单一实地址模式要合适一些。许多实践也证明，依靠虚地址保护来提高可靠性总存在局限性，毕竟程序运行出了错误，从某种程度上说虚地址保护只是使已经出现的错误经过一个延迟、积累和放大的过程，用过Windows就会有这种感触。而经过大量关键应用检验的VxWorks操作系统，则被充分证明是高度可靠的(当然了，可靠的系统必须由可靠的操作系统和可靠的应用系统组成)。
层次结构的Wind内核仅提供多任务环境、进程间通信和同步功能的服务例程。这些服务例程足够支持VxWorks在较高层次所提供的丰富性能的要求。VxWorks的Wind内核操作对于用户是不可见的。应用程序为了实现需要内核参与的任务管理和同步使用一些系统调用，但这些调用的处理对于调用任务是不可见的。应用程序仅链接恰当的VxWorks例程（通常使用VxWorks的动态链接功能），就象调用子程序一样发出系统调用。这种接口不象Linux内核需要一个跳转表接口，用户需要通过一个整数来指定一个内核功能调用。
Wind内核类设计思想 VxWorks采用类和对象的思想将Wind内核分成5个组成部分：任务管理模块、内存管理模块、消息队列管理模块、信号量管理模块、以及看门狗管理模块。
备注：除了上面的五个模块之后，还有虚拟内存管理接口(VxVMI)模块和TTY环形缓冲区管理模块也是Wind内核用类和对象思想管理的两个模块。虚拟内存接口模块(VxVMI)是VxWorks的一个功能模块，它利用用户片上或板上的内存管理单元(MMU)，为用户提供了对内存的高级管理功能；TTY环形缓冲区管理模块是ttyDrv设备的核心，ttyDrv设备称为虚拟设备，处在I/O系统和真正驱动程序之间形成了一个转换层，为VxWorks提供了一个标准的I/O接口，一个虚拟ttyDrv设备可以管理多个串行设备驱动程序。这两个模块严格意义上来说并不是一个RTOS内核理论上的组成部分，因此才不把它们列在Wind内核的组成部分上。
在wind内核中，所有的对象都是类的组成部分，类定义了操作对象的方法(Method)，同时维护着对所有对象的操作记录。Wind内核采用了c++的语义，但是采用c语言来实现。整个Wind内核通过显式编码实现，其编译过程并不依赖于具体的编译器。这意味着Wind内核不但可以在vxWorks自带的diab编译上编译，也可以使用开源的gnu/gcc编译器。VxWorks为Wind内核设计了一个元类(Meta-class)，所有的对象类(Obj-class)都是基于该元类。每个对象类只负责维护各自对象(Object)的操作方法(比如创建对象、初始化对象、注销对象等)、以及管理统计记录(比如一个创建对象的数据、销毁对象的数目等)。图1.5实现了元类、对象类、以及对象之间的逻辑关系。
图1-5 元类、对象类、对象间关系图
备注：每次画这种类和对象关系图的时候，我就异常的纠结。因为在wind内核的设计中，元类classClass有一个ID号classClassId，每个对象类X-objClass也有一个ID号X-objClassId。在C语言的实现中classClassId和X-objClassId都是指针变量，存放的是相应类的地址。在初始化对象类和对象时，对象类和对象的objCore域存放的该指针变量的值(即相应类的地址)，跟classClassId没有太大的关系。图1.5真实地反应了objCore存放的类地址这个真实的关系。
如果从逻辑上来看的话，图1.6看起来更舒服，虽然从C语言实现来说，classClassId和X-objClassId的作用是错误的，但是从逻辑上看图1.6能更清晰的描述问题(并且图也更美观O(∩_∩)O)，虽然图1.6上objCore存放的指向类地址的指针。正因为如此，在画类和对象关系图时，我采用图1-6所示的方式。
图1-6 元类、对象类、对象间关系图
正如图1-5，图1-6所示的那样每个对象类都指向元类classClass，每个对象类只负责管理各自的对象。Wind内核完整的元类、对象类、以及对象间逻辑关键，见图1-7。
图1-7 wind内核各个组成模块间对象类、对象和元类的关系
备注：类管理模式不是Wind内核的特性，从功能上来说它仅仅是Wind内核组织各个模块的手段，所有内核模块的对象类、类对象都依赖于它。VxWorks采用类及对象来组织操作系统的结构，一个最重要的优势是增加了代码的安全性，即在创建新的对象类和对象、以及删除对象类和对象都可以对对象类、对象进行验证。
Wind内核的特性 VxWorks的Wind内核自然具有1.2节所描述的所有RTOS所共有的四个特性，其所有特点可以概括如下：
 可裁剪的微内核设计； 多任务并发执行； 可抢占的优先级调度算法； 可选的时间片轮转算法； 任务间通信和同步机制； 快速的上下文切换时间； 低中断延时； 快速的中断响应时间； 可嵌套中断支持； 256个任务优先级； 任务删除保护； 优先级继承； 基于函数的调用，不采用陷阱指令和跳转表； VxWorks内核运行在处理器特权模式； VxWorks内核分层实现，VxWorks的核心库Wind内核处于核心态，由全局管理kernelState进行保护。 备注：本系列博文接下来的部分将详细分析wind内核如何进行设计，以具有这些特性。  再废话几句O(∩_∩)O：我在分析Wind内核时所秉持的宗旨是策略(Mechanism)和机制(Policy)相分离的原则，策略(Mechanism)和机制(Policy)相分离是微内核设计的指导思想，换句话说微内核操作系统设计的指导原则是提供机制而不是策略。为了更清楚地说明这一点，我们以任务调度为例。一个简单的调度算法是为每一个任务赋予一个优先级，并让内核执行具有最高优先级的就绪任务。在这个例子中，机制(Mechanism)是在内核中寻找最高优先级的就绪任务并运行之；而策略(Policy)则是赋予任务相应的优先级。换句话说机制负责提供什么样的功能，策略则负责如何使用这些功能。策略和机制相分离指导思想可以使操作系统内核变得更小，更稳定。正如一句话说的好“一个优美的内核不是还有什么样的功能还可以增加，而是还有什么样的功能还可以减少”(哥们忘记是谁说的了⊙﹏⊙b汗)。
本系列博文力求在分析研究Wind内核的同时，思考RTOS的内核设计思想源泉。VxWorks的Wind内核经历了近20年的发展完善，达到目前的稳定状态。采用目前的这种设计、一定有其内部的考量，我希望尽可能的从一个系统设计者的角度来分析Wind内核的设计思想、工作机制、以及具有的特性，为我们设计一个款优秀的RTOS内核提供借鉴！
]]></content>
  </entry>
  
  <entry>
    <title>开启重返月球之旅</title>
    <url>/post/news/our-journey-back-to-the-moon.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>WindRiver</tag>
      <tag>VxWorks</tag>
      <tag>Artemis I</tag>
      <tag>NASA</tag>
    </tags>
    <content type="html"><![CDATA[风河公司祝贺NASA（美国宇航局）成功推进 Artemis I 工程，由此开启了新的返回月球之旅。
近30年来，风河为NASA提供了非常成熟的软件平台，将数十套智能系统送入太空，其中包括许多载入人类史册的太空工程。我们非常自豪，Artemis I 工程再一次丰富了我们的航天工程成功榜单。  Artemis I工程的每个组成部分都离不开智能系统，包括提供一级发射和地月轨道转移控制的空间发射系统(Space Launch System，SLS)以及提供生命环境、通信和月球轨道控制系统的猎户座载人飞船，其中都采用了风河的VxWorks实时操作系统，还有很多功能在部署之前都已经在Wind River Simics全系统仿真环境中进行了测试。值得注意的是， VxWorks  和Simics都已经包含在了Wind River Studio之中。
Artemis 1工程彰显了猎户座飞船和SLS火箭的性能，并将在绕月飞行和返回地球的过程中展现其魅力。据美国宇航局公布的消息，这次飞行将为未来的进一步探月工程铺平道路，包括让第一位女性和第一位有色人种在月球表面着陆。
这项工程还创造了多项“首次”。例如，这是美国宇航局猎户座载人飞船第一次飞向月球，尽管其中还没有乘坐宇航员。再如，这也是新型太空发射系统的第一次实用测试，这套系统为本次任务提供了大约880万磅的推力，并将会为后续的宇航任务提供更强大的推力。还有一个“首次”是将多项创新科技实验任务合并起来作为火箭的有效载荷。
紧随其后的Artemis 2将从这次任务中收集的数据中学习，以便完成更多的载人登月任务。NASA的最终计划是建立一个月球基地，进行常规月球旅行，进而支持人们在月球上生活并从事科研工作。
NASA还会推进载人月球飞行和其他13项科研工作，探索多个不同的课题，例如辐射对生命体的影响和月球上的氢元素分布，以及太阳帆和拉格朗日点的相关控制技术。在飞向月球的旅途中，将会根据科研需求在许多不同的空间位置上部署CubeSat。
欢迎大家去NASA的Artemis I网站上查阅更多相关的科技资料！
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks的环形缓冲区设计</title>
    <url>/post/bsp/ring-buffer-design-in-vxworks.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>Ring Buffer</tag>
    </tags>
    <content type="html"><![CDATA[VxWorks环形缓冲模块主要定义在rngLib.c和rngLib.h中，对于数据结构比较了解的小伙伴应该知道，环形缓冲实际就是一个双向循环队列。
概述 关于循环队列，小编之前在《也没想象中那么神秘的数据结构-先来后到的&quot;队列&quot;（循环队列）》一文中有过详细阐述，这里就不在过多的赘述了。
开发环境: vxWorks6.9.4，workbench3.3.5 开发板: TLZ7x-EasyEVM-A3
另外，小编所有文章均是自己亲手编写验证，若需要小编的工程代码，访问地址 实时系统vxWorks - 环形缓冲工程文件  获取。
文件内容如下：
  obj: 存放目标文件，包含vxWorks镜像，应用程序目标文件。
  rng_test: vxWorks应用工程。
  接口 官方接口 官方环形缓冲接口定义主要包含在rngLib.h头文件中。
环形缓冲接口定义 typedef struct	/* RING - ring buffer */ { size_t pToBuf;	/* 写指针 */ size_t pFromBuf;	/* 读指针 */ size_t bufSize;	/* 数据长度 */ char *buf;	/* 存放数据 */ } RING; /* END_HIDDEN */ typedef RING *RING_ID; 创建/删除环形缓冲 /** * @创建环形缓冲 * @nbytes: 缓冲尺寸 * @成功返回环形缓冲ID，失败返回NULL。 */ extern RING_ID rngCreate (size_t nbytes); /** * @删除环形缓冲 * @ringId: 环形缓冲ID */ extern void rngDelete (RING_ID ringId); 判断缓冲是否空/满 /** * @判断环形缓冲是否为空 * @ringId: 环形缓冲ID * @不为空返回0，否则返回其它。 */ extern BOOL rngIsEmpty (RING_ID ringId); /** * @判断环形缓冲是否为满 * @ringId: 环形缓冲ID * @不为满返回0，否则返回其它。 */ extern BOOL rngIsFull (RING_ID ringId); 读写数据 /** * @从环形缓冲中读取数据 * @ringId: 环形缓冲ID buffer：数据 maxbytes：长度 * @返回实际读取到的数据长度。 */ extern size_t rngBufGet (RING_ID rngId, char *buffer, size_t maxbytes); /** * @写数据到环形缓冲 * @ringId: 环形缓冲ID buffer：数据 nbytes：长度 * @返回实际写入数据长度 */ extern size_t rngBufPut (RING_ID rngId, char *buffer, size_t nbytes); 获取缓冲区剩余空间/已占空间 /** * @获取环形缓冲剩余空间长度 * @ringId: 环形缓冲ID * @返回剩余空间长度。 */ extern size_t rngFreeBytes (RING_ID ringId); /** * @获取环形缓冲已占空间长度 * @ringId: 环形缓冲ID * @返回已占空间长度。 */ extern size_t rngNBytes (RING_ID ringId); 清空缓冲 /** * @清空环形缓冲 * @ringId: 环形缓冲ID */ extern void rngFlush (RING_ID ringId); 环形缓冲对象接口 属性定义 /* 环形缓冲类 */ struct t_rng { u8_t flag; /* 创建标志，=1已创建，=0未创建 */ RING_ID id; /* 环形缓冲 */ struct t_sem msem; /* 环形缓冲互斥信号量 */ }; 保存数据到环形缓冲 /** * @保存数据到环形缓冲 * @p_rng：环形缓冲类 buf: 数据 len：长度 **/ void put_rng(struct t_rng *p_rng, s8_t *buf, s32_t len); 获取环形缓冲数据 /** * @获取环形缓冲数据 * @p_rng：环形缓冲类 buf装载数据, len数据长度 * 成功返回实际数据长度，失败返回ERROR **/ s32_t get_rng(struct t_rng *p_rng, s8_t *buf, s32_t len); 创建环形缓冲 /** * @创建环形缓冲 * @p_rng：环形缓冲类 nbyte申请缓冲大小, name互斥信号名 **/ void create_rng(struct t_rng *p_rng, size_t nbytes, s8_t *name); 示例   示例创建两个任务（生产者/消费者），生产者向缓冲写入数据，消费者从缓冲读取数据，缓冲访问时使用互斥信号量进行互斥。
  关于信号量和任务部分可参加小编的《实时系统vxWorks - 信号量（重要）》和《实时系统vxWorks - 任务（重要）》文章。
  包含环形缓冲类rng.c/rng.h和演示程序main.c（已验证通过）。
  rng.h /** * @Filename : rng.h * @Revision : $Revision: 1.00 $ * @Author : Feng * @Description : 环形缓冲类，在系统自带环形缓冲基础上封装互斥信号量 **/ #ifndef __RNG_CLASS_H__  #define __RNG_CLASS_H__  #include #include  #include #include  #include #include &#34;sem.h&#34; extern struct sem sem; /* 保存系统信号量信息 */ /* 环形缓冲类 */ struct t_rng { u8_t flag; /* 创建标志，=1已创建，=0未创建 */ RING_ID id; /* 环形缓冲 */ struct t_sem msem; /* 环形缓冲互斥信号量 */ }; /** * @保存数据到环形缓冲 * @p_rng：环形缓冲类 buf: 数据 len：长度 **/ void put_rng(struct t_rng *p_rng, s8_t *buf, s32_t len); /** * @获取环形缓冲数据 * @p_rng：环形缓冲类 buf装载数据, len数据长度 * 成功返回实际数据长度，失败返回ERROR **/ s32_t get_rng(struct t_rng *p_rng, s8_t *buf, s32_t len); /** * @创建环形缓冲 * @p_rng：环形缓冲类 nbyte申请缓冲大小, name互斥信号名 **/ void create_rng(struct t_rng *p_rng, size_t nbytes, s8_t *name); #endif rng.c /** * @Filename : rng.c * @Revision : $Revision: 1.00 $ * @Author : Feng * @Description : 环形缓冲类，在系统自带环形缓冲基础上封装互斥信号量 **/ #include &#34;rng.h&#34; /** * @保存数据到环形缓冲 * @p_rng：环形缓冲类 buf: 数据 len：长度 **/ void put_rng(struct t_rng *p_rng, s8_t *buf, s32_t len) { if (p_rng-&gt;flag == 0) return; get_sem(&amp;p_rng-&gt;msem); if (!(rngIsFull(p_rng-&gt;id))) rngBufPut(p_rng-&gt;id, buf, len); lose_sem(&amp;p_rng-&gt;msem); } /** * @获取环形缓冲数据 * buf装载数据, len数据长度 * 成功返回实际数据长度，失败返回ERROR **/ s32_t get_rng(struct t_rng *p_rng, s8_t *buf, s32_t len) { s32_t rLen = ERROR; if (p_rng-&gt;flag == 0) return ERROR; get_sem(&amp;p_rng-&gt;msem); if (!(rngIsEmpty(p_rng-&gt;id))) rLen = rngBufGet(p_rng-&gt;id, buf, len); lose_sem(&amp;p_rng-&gt;msem); return (rLen); } /** * @创建环形缓冲 * nbyte申请缓冲大小, name互斥信号名 **/ void create_rng(struct t_rng *p_rng, size_t nbytes, s8_t *name) { if (p_rng-&gt;flag == 1) return; p_rng-&gt;id = rngCreate(nbytes); p_rng-&gt;msem.sem = NULL; p_rng-&gt;msem.type = SEM_MUTEX; strcpy(p_rng-&gt;msem.name, name); resgister_sem(&amp;sem, &amp;p_rng-&gt;msem); p_rng-&gt;flag = 1; } main.c /** * @Filename : main.c * @Revision : $Revision: 1.00 $ * @Author : Feng * @Description : 环形缓冲类使用示例 **/ #include #include  #include &#34;stdioLib.h&#34;  #include &#34;strLib.h&#34;  #include &#34;task.h&#34; #include &#34;sem.h&#34; #include &#34;rng.h&#34; #include &#34;feng_type.h&#34; #define RNG_SIZE 100 /* 缓冲大小 */ struct sem sem; /* 保存系统信号量信息 */ struct t_task s_task, s_task1; struct t_sem s_sem, s_sem1; struct t_rng rng; /** * @生产者：定时存储数据到环形缓冲 **/ static void _thread(void) { static int cnt = 77; while (1) { get_sem(&amp;s_sem); put_rng(&amp;rng, &amp;cnt, sizeof(int)); printf(&#34;put data : %d...\n&#34;, cnt++); } } /** * @消费者：定时从环形缓冲中取出数据 **/ static void _thread1(void) { int cnt1 = 0; while (1) { get_sem(&amp;s_sem1); if (get_rng(&amp;rng, &amp;cnt1, sizeof(int)) &gt; 0) printf(&#34;get data : %d...\n&#34;, cnt1); } } /** * @创建任务 * @p_task：任务类 name：任务名 thread：函数 **/ void _create_task(struct t_task *p_task, char *name, FUNCPTR thread) { strcpy(p_task-&gt;name, name); p_task-&gt;options = VX_FP_TASK; p_task-&gt;stackSize = 50 * 1024; p_task-&gt;pFunc = thread; p_task-&gt;tid = NULL; p_task-&gt;core = 0; p_task-&gt;priority = 102; create_task(p_task); start_task(p_task); } /** * @创建信号量 * @p_sem：信号量类 name：信号量名 type：类型 **/ void _create_sem(struct t_sem *p_sem, char *name, E_SEM_TYPE type) { strcpy(p_sem-&gt;name, name); p_sem-&gt;period = 100; p_sem-&gt;type = type; p_sem-&gt;sem = SEM_ID_NULL; resgister_sem(&amp;sem, p_sem); } int main(void) { sysClkRateSet(100); /* 时间片设置 */ create_rng(&amp;rng, RNG_SIZE, &#34;my_rng&#34;); _create_sem(&amp;s_sem, &#34;my_sem&#34;, SEM_BIN); _create_sem(&amp;s_sem1, &#34;my_sem1&#34;, SEM_BIN); _create_task(&amp;s_task, &#34;my_task&#34;, (FUNCPTR)_thread); _create_task(&amp;s_task1, &#34;my_task1&#34;, (FUNCPTR)_thread1); while (1) { taskDelay(500); /* 5s */ lose_sem_by_name(&amp;sem, &#34;my_sem&#34;); lose_sem_by_name(&amp;sem, &#34;my_sem1&#34;); } return 0; } 验证 使用环形缓冲之前需要先添加INCLUDE_RNG_BUF组件。
打开镜像工程，选择kernel Configuration。按住Ctrl+F，输入rng，找到ring buffers，添加组件。
添加完组件后，编译镜像，将镜像拷贝到目标机加载指定目录。
创建应用工程rng_test，输入相关测试代码，运行后如下图所示。
注意：若不知道工程如何创建以及运行，可参见小编文章《实时系统vxWorks - 任务（重要）》和《实时系统vxWorks - 加载应用程序的方法》。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks 7的启动顺序</title>
    <url>/post/bsp/vxworks-7-boot-sequence.html</url>
    <categories><category>BSP</category>
    </categories>
    <tags>
      <tag>VxWorks 7</tag>
      <tag>Boot</tag>
    </tags>
    <content type="html"><![CDATA[之前遍历过使用WorkBench的VIP编译的VxWorks6.9镜像文件VxWorks，今天以32位SMP模式下的Intel处理器为例，看看VxWorks 7的VxWorks执行顺序。通过对比可以看到，VxWorks 6.9和VxWorks 7的执行顺序基本一致
 sysInit() - $(BSP)/sysALib.s，这是VxWorks的启动地址，也就是说sysInit()就存放在RAM_LOW_ADRS，它的主要工作：关中断、设置usrInit()的栈、调用usrInit() usrInit() - $(Prj)/prjConfig.c，这是VxWorks的第一条C指令，主要负责pre-kernel的初始化，因此它的内部会调用大量的初始化函数 sysStart() - os\core\kernel\configlette\usrStartup.c，清除BSS、设置中断向量表基址 cacheLibInit() - os\core\kernel\src\aim\cacheLib.c初始化指令Cache和数据Cache usrFdtInit() - os\firmware\fdt\cfg\usrFdt.c,初始化FDT库 usrBoardLibInit() - os\utils\boardlib\cfg\usrBoardLibInit.c,初始化板级子系统， sysHwInit() - os\psl\intel\itl_x86_common\cfg\usrItlCommon.c，初始化系统硬件 usrAimCpuInit() - os\core\kernel\configlette\usrAimCpu.c,初始化主CPU，其实啥也没干 excShowInit() - os\arch\ia\kernel\src\cpu\excArchShow.c,映射exception的几个show函数 excVecInit() - os\arch\ia\kernel\src\cpu\excArchLib.c,初始化exception向量 vxCpuLibInit() - os\core\kernel\src\multicore\vxCpuLib.c,初始化CPU标识函数，例如vxCpuIdGet() usrCacheEnable() - os\core\kernel\configlette\usrCache.c，使能Cache objOwnershipInit() - os\core\kernel\src\wind\obj\objOwnerLib.c,设置object ownership的几个函数 objLibInit() - os\core\kernel\src\wind\obj\objLib.c，初始化对象管理库 vxMemProbeInit() - os\core\kernel\src\services\vxMemProbeLib.c,添加vxMemProbe()的异常处理 classListLibInit() - os\core\kernel\src\wind\obj\classListLib.c，初始化Class的列表库 semLibInit() - os\core\kernel\src\wind\semLib.c，初始化信号量机制 condVarLibInit() - os\core\kernel\src\wind\condVarLib.c,初始化condition variables库 classLibInit() - os\core\kernel\src\wind\obj\classLib.c，初始化Class库 kernelBaseInit() - os\core\kernel\src\services\kernelBaseLib.c，初始化内核使用的对象 taskCreateHookInit() - os\core\kernel\src\wind\taskCreateHookLib.c,初始化task hook机制 sysDebugModeInit() - os\core\kernel\src\edr\sysDbgLib.c,设置debug mode的flag usrKernelInit() - os\core\kernel\configlette\usrKernel.c，配置内核使用的数据结构，包括初始化ISR对象、初始化内核的Task库、配置调度策略、初始化Tick队列、初始化中断级deferred work队列、记录系统内存池尺寸、调用kernelInit()初始化内核 kernelInit() - os\core\kernel\src\wind\kernelLib.c，初始化并启动内核，包括设置中断栈尺寸、设置内存池位置、初始化中断lock-out等级、关闭时间片轮转策略、将系统Tick清零、初始化中断栈、初始化并启动系统的第一个任务tRootTask usrRoot() - $(Prj)/prjConfig.c，这就是系统第一个任务的入口地址，主要负责post-kernel的初始化，逐步加载系统服务，它内部同样由大量初始化函数组成 usrKernelCoreInit() - 初始化内核的一些机制，包括Event、信号量的open机制、condition variables的open机制、消息队列及其open机制、看门狗、任务的open机制等 poolLibInit() - os\core\kernel\src\mm\poolLib.c,初始化Memory Pool库 memInit() - os\core\kernel\src\mm\memLib.c，初始化系统内存分区 memPartLibInit() - os\core\kernel\src\mm\memPartLib.c，初始化系统内存分区的class Id kProxHeapInit() - 创建kernel proximity heap，这个heap可以用于存储downloaded kernel models、 ISR handlers等，以及kernel common heap创建之前的内存分配 pgPoolLibInit() - os\core\kernel\src\mm\pgPoolLib.c,初始化page pool库 usrMmuInit() - os\core\kernel\configlette\usrMmuInit.c，初始化MMU pmapInit() - 提供物理地址映射机制 kCommonHeapInit() - os\core\kernel\src\mm\kCommonHeapLib.c,创建kernel Common Heap usrKernelCreateInit() - $(Prj)/prjConfig.c，初始化内核对象的creation机制，例如任务、消息队列、看门狗 usrDebugAgentBannerInit() - os\debug_analysis\rttools\agent\src\osconfig\vxworks\cfg\usrDebugAgent.c,注册debug agent banner usrShellBannerInit() - 注册shell banner intVecTableWriteProtect() - os\arch\ia\kernel\src\cpu\x86\intArchLib.c, 写保护exception向量表 cacheDma32PartInit() - os\core\kernel\src\services\cacheDma32Lib.c,初始化DMA buffers分区 miiBusLibInit() - os\net\end\drv\src\mii\vxbMiiLib.c,初始化mii总线库 vxbParamLibInit() - os\drv\vxbus\core\src\util\vxbParamLib.c,初始化driver parameter机制 usrIaPciUtilsInit() - os\psl\intel\itl_x86_common\cfg\usrIaPciUtils.c, Intel PCI机制的早期初始化 sysHwInit1() - os\psl\intel\itl_x86_common\cfg\usrItlCommon.c,额外的系统初始化，例如初始化PIC、IPI向量等 boardInit() - os\utils\boardlib\src\boardLib.c,板级初始化 sysHwInit2() - os\psl\intel\itl_x86_common\cfg\usrItlCommon.c, usrTextProtect() - os\core\kernel\configlette\usrTextProtect.c, 写保护文本段 excOsmInit() - os\arch\ia\kernel\src\cpu\x86\sysOsmLib.c, Handler for exception stack overflow usrKernelIntStkProtect() - os\core\kernel\configlette\usrKernelStack.c,中断栈保护 taskStackGuardPageEnable() - os\core\kernel\src\mm\taskMemLib.c,任务栈保护 usrNetApplUtilInit() - os\core\kernel\configlette\usrNetApplUtil.c,初始化Networks的application/stack logging机制 envLibInit() - os\core\kernel\src\services\envLib.c,初始化环境变量机制 edrStubInit() - os\core\kernel\configlette\edrStub.c,在ED&amp;R中记录boot类型 usrSysctlInit() - os\core\kernel\configlette\usrSysctl.c,提供SYSCTL机制 kernelIdleTaskActivate() - os\core\kernel\src\wind\kernelLib.c,激活idle任务 randomInit() - $(Prj)/prjConfig.c, 随机数生成器 usrIosCoreInit () - $(Prj)/prjConfig.c，初始化IO系统 usrNetworkInit0() - $(Prj)/prjConfig.c，初始化网络子系统 usrHwSysctlInit() - os\core\kernel\configlette\usrHwSysctl.c,初始化硬件的sysctl vxbDmaLibInit() - os\drv\vxbus\subsystem\src\dma\vxbDmaLib.c,初始化DMA库 vxbIsrHandlerInit() - os\drv\vxbus\subsystem\src\int\vxbIsrHandler.c,初始化VxBus ISR handler vxbIntLibInit() - os\drv\vxbus\subsystem\src\int\vxbIntLib.c,初始化vxbIntLib库 vxDyncIntLibInit() - os\drv\vxbus\subsystem\src\int\vxbDyncIntLib.c,初始化MSI支持库 vxIpiLibInit() - os\drv\vxbus\subsystem\src\int\vxIpiLib.c, 初始化IPI vxbLibInit() - os\drv\vxbus\core\src\vxbLib.c, 初始化VxBus子系统 intStartupUnlock() - os\arch\ia\kernel\src\cpu\x86\intArchLib.c, 打开中断 sysIntEnableFlagSet() - os\drv\vxbus\subsystem\src\int\vxbIntLib.c, 标记中断已使能 usrSerialInit() - os\core\kernel\configlette\usrSerial.c, 设置标准输入、输出设备 usrClkInit() - $(Prj)/prjConfig.c, 初始化时钟、Aux、Timestamp cpcInit() - os\core\kernel\src\multicore\cpcLib.c, 使能IPI vxdbgCpuLibInit() - os\debug_analysis\debug\vxdbg\src\vxdbgCpuLib.c, 初始化debug IPI库 miiBusMonitorTaskInit() - os\net\end\drv\src\mii\vxbMiiLib.c, 启动MII总线监测任务 kbdDelayStart() - os\psl\intel\itl_x86_common\src\vxbI8042Kbd.c, 启动Intel 8042 Keyboard pgMgrBaseLibInit() - os\core\kernel\src\mm\pgMgrBaseLib.c, 初始化Basic Page Manager库 pgMgrLibInit() - os\core\kernel\src\mm\pgMgrLib.c, 初始化Page Manager库 usrRtpInit() - $(Prj)/prjConfig.c, 初始化RTP机制 mmanLibInit() - os\core\kernel\src\posix\mm\mmanLib.c, 初始化POSIX内存管理机制 usrKernelExtraInit() - $(Prj)/prjConfig.c，初始化内核其它机制，例如Signal、POSIX Clock等 usrPcConsoleInit() - os\arch\ia\kernel\configlette\usrPcConsole.c, 初始化PC console usrIosExtraInit() - $(Prj)/prjConfig.c，初始化IO系统其它机制，例如任务级job机制、message logging库、管道驱动、标准IO库、设备管理、文件系统相关机制、pty(pseudo-terminal)驱动、Boot Line解析等 usrHostnameSetup() - os\core\kernel\configlette\usrHostnameSetup.c, 给Target分配名字TARGET_HOSTNAME_DEFAULT sockLibInit() - os\service\socket\src\sockLib.c, 初始化Socket API selTaskDeleteHookAdd() - os\core\io\src\ios\selectLib.c, 完成select机制的初始化 cpuPwrMgrEnable() - os\drv\vxbus\core\src\util\cpuPwrLightLib.c, 使能CPU电源管理 cplusCtorsLink() - os\lang_lib\libcplus\cplus_kernel\src\rts\cplusXtors.c, 加载静态对象的构造函数 usrScInit() - $(Prj)/prjConfig.c，初始化系统调用机制 usrKernelIntStkProtectNonCore0() - os\core\kernel\configlette\usrKernelStack.c, 保护非引导核的中断栈 usrSmpInit() - os\core\kernel\configlette\usrSmp.c, 使能SMP usrBanner() - os\core\kernel\configlette\usrBanner.c, 打印Shell的Banner usrNetworkInit() - $(Prj)/prjConfig.c，完成网络系统初始化 usrToolsInit() - $(Prj)/prjConfig.c，软件开发工具，例如spy()、timex()、target loader、符号表、debug库、kernel shell等 usrMmuOptimize() - os\core\kernel\configlette\usrMmuOptimize.c, 优化MMU的page sizing usrAppInit() - $(Prj)/usrAppInit.c，VxWorks系统启动过程中调用的最后一个函数，因此一般把应用程序的入口放在这里 ]]></content>
  </entry>
  
  <entry>
    <title>Linux编程之经典多级时间轮定时器</title>
    <url>/post/linux/linux-programming-multiple-time-wheel-timer.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>linux</tag>
      <tag>timer</tag>
    </tags>
    <content type="html"><![CDATA[mmap用于把文件映射到内存空间中，简单说mmap就是把一个文件的内容在内存里面做一个映像。
多级时间轮实现框架 上图是5个时间轮级联的效果图。中间的大轮是工作轮，只有在它上的任务才会被执行；其他轮上的任务时间到后迁移到下一级轮上，他们最终都会迁移到工作轮上而被调度执行。
多级时间轮的原理也容易理解：就拿时钟做说明，秒针转动一圈分针转动一格；分针转动一圈时针转动一格；同理时间轮也是如此：当低级轮转动一圈时，高一级轮转动一格，同时会将高一级轮上的任务重新分配到低级轮上。从而实现了多级轮级联的效果。
多级时间轮对象 多级时间轮应该至少包括以下内容：
 每一级时间轮对象 轮子上指针的位置 关于轮子上指针的位置有一个比较巧妙的办法：那就是位运算。比如定义一个无符号整型的数：  通过获取当前的系统时间便可以通过位操作转换为时间轮上的时间，通过与实际时间轮上的时间作比较，从而确定时间轮要前进调度的时间，进而操作对应时间轮槽位对应的任务。
为什么至少需要这两个成员呢？
 定义多级时间轮，首先需要明确的便是级联的层数，也就是说需要确定有几个时间轮。 轮子上指针位置，就是当前时间轮运行到的位置，它与真实时间的差便是后续时间轮需要调度执行，它们的差值是时间轮运作起来的驱动力。  多级时间轮对象的定义
//实现5级时间轮 范围为0~ (2^8 * 2^6 * 2^6 * 2^6 *2^6)=2^32 struct tvec_base { unsigned long current_index; pthread_t thincrejiffies; pthread_t threadID; struct tvec_root tv1; /*第一个轮*/ struct tvec tv2; /*第二个轮*/ struct tvec tv3; /*第三个轮*/ struct tvec tv4; /*第四个轮*/ struct tvec tv5; /*第五个轮*/ }; 时间轮对象 我们知道每一个轮子实际上都是一个哈希表，上面我们只是实例化了五个轮子的对象，但是五个轮子具体包含什么，有几个槽位等等没有明确(即struct tvec和struct tvec_root)。
#define TVN_BITS 6 #define TVR_BITS 8 #define TVN_SIZE (1&lt;&lt;TVN_BITS) #define TVR_SIZE (1&lt;&lt;TVR_BITS) struct tvec { struct list_head vec[TVN_SIZE];/*64个格子*/ }; struct tvec_root{ struct list_head vec[TVR_SIZE];/*256个格子*/ }; 此外，每一个时间轮都是哈希表，因此它的类型应该至少包含两个指针域来实现双向链表的功能。这里我们为了方便使用通用的struct list_head的双向链表结构。
定时任务对象 定时器的主要工作是为了在未来的特定时间完成某项任务，而这个任务经常包含以下内容：
 任务的处理逻辑(回调函数) 任务的参数 双向链表节点 到时时间  定时任务对象的定义
typedef void (*timeouthandle)(unsigned long ); struct timer_list{ struct list_head entry; //将时间连接成链表  unsigned long expires; //超时时间  void (*function)(unsigned long); //超时后的处理函数  unsigned long data; //处理函数的参数  struct tvec_base *base; //指向时间轮 }; 在时间轮上的效果图：
双向链表 在时间轮上我们采用双向链表的数据类型。采用双向链表的除了操作上比单链表复杂，多占一个指针域外没有其他不可接收的问题。而多占一个指针域在今天大内存的时代明显不是什么问题。至于双向链表操作的复杂性，我们可以通过使用通用的struct list结构来解决，因为双向链表有众多的标准操作函数，我们可以通过直接引用list.h头文件来使用他们提供的接口。
struct list可以说是一个万能的双向链表操作框架，我们只需要在自定义的结构中定义一个struct list对象即可使用它的标准操作接口。同时它还提供了一个类似container_of的接口，在应用层一般叫做list_entry，因此我们可以很方便的通过struct list成员找到自定义的结构体的起始地址。
关于应用层的log.h, 我将在下面的代码中附上该文件。如果需要内核层的实现，可以直接从linux源码中获取。
联结方式 多级时间轮效果图：
多级时间轮C语言实现 双向链表头文件: list.h 提到双向链表，很多的源码工程中都会实现一系列的统一的双向链表操作函数。它们为双向链表封装了统计的接口，使用者只需要在自定义的结构中添加一个struct list_head结构，然后调用它们提供的接口，便可以完成双向链表的所有操作。这些操作一般都在list.h的头文件中实现。Linux源码中也有实现（内核态的实现）。他们实现的方式基本完全一样，只是实现的接口数量和功能上稍有差别。可以说这个list.h文件是学习操作双向链表的不二选择，它几乎实现了所有的操作：增、删、改、查、遍历、替换、清空等等。这里我拼凑了一个源码中的log.h函数，终于凑够了多级时间轮中使用到的接口。
#if !defined(_BLKID_LIST_H) &amp;&amp; !defined(LIST_HEAD) #define _BLKID_LIST_H #ifdef __cplusplus extern &#34;C&#34; { #endif /* * Simple doubly linked list implementation. * * Some of the internal functions (&#34;__xxx&#34;) are useful when * manipulating whole lists rather than single entries, as * sometimes we already know the next/prev entries and we can * generate better code by using them directly rather than * using the generic single-entry routines. */ struct list_head { struct list_head *next, *prev; }; #define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) } #define LIST_HEAD(name) \ struct list_head name = LIST_HEAD_INIT(name) #define INIT_LIST_HEAD(ptr) do { \ (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \ } while (0) static inline void __list_add(struct list_head *entry, struct list_head *prev, struct list_head *next) { next-&gt;prev = entry; entry-&gt;next = next; entry-&gt;prev = prev; prev-&gt;next = entry; } /** * Insert a new element after the given list head. The new element does not * need to be initialised as empty list. * The list changes from: * head → some element → ... * to * head → new element → older element → ... * * Example: * struct foo *newfoo = malloc(...); * list_add(&amp;newfoo-&gt;entry, &amp;bar-&gt;list_of_foos); * * @param entry The new element to prepend to the list. * @param head The existing list. */ static inline void list_add(struct list_head *entry, struct list_head *head) { __list_add(entry, head, head-&gt;next); } /** * Append a new element to the end of the list given with this list head. * * The list changes from: * head → some element → ... → lastelement * to * head → some element → ... → lastelement → new element * * Example: * struct foo *newfoo = malloc(...); * list_add_tail(&amp;newfoo-&gt;entry, &amp;bar-&gt;list_of_foos); * * @param entry The new element to prepend to the list. * @param head The existing list. */ static inline void list_add_tail(struct list_head *entry, struct list_head *head) { __list_add(entry, head-&gt;prev, head); } static inline void __list_del(struct list_head *prev, struct list_head *next) { next-&gt;prev = prev; prev-&gt;next = next; } /** * Remove the element from the list it is in. Using this function will reset * the pointers to/from this element so it is removed from the list. It does * NOT free the element itself or manipulate it otherwise. * * Using list_del on a pure list head (like in the example at the top of * this file) will NOT remove the first element from * the list but rather reset the list as empty list. * * Example: * list_del(&amp;foo-&gt;entry); * * @param entry The element to remove. */ static inline void list_del(struct list_head *entry) { __list_del(entry-&gt;prev, entry-&gt;next); } static inline void list_del_init(struct list_head *entry) { __list_del(entry-&gt;prev, entry-&gt;next); INIT_LIST_HEAD(entry); } static inline void list_move_tail(struct list_head *list, struct list_head *head) { __list_del(list-&gt;prev, list-&gt;next); list_add_tail(list, head); } /** * Check if the list is empty. * * Example: * list_empty(&amp;bar-&gt;list_of_foos); * * @return True if the list contains one or more elements or False otherwise. */ static inline int list_empty(struct list_head *head) { return head-&gt;next == head; } /** * list_replace - replace old entry by new one * @old : the element to be replaced * @new : the new element to insert * * If @old was empty, it will be overwritten. */ static inline void list_replace(struct list_head *old, struct list_head *new) { new-&gt;next = old-&gt;next; new-&gt;next-&gt;prev = new; new-&gt;prev = old-&gt;prev; new-&gt;prev-&gt;next = new; } /** * Retrieve the first list entry for the given list pointer. * * Example: * struct foo *first; * first = list_first_entry(&amp;bar-&gt;list_of_foos, struct foo, list_of_foos); * * @param ptr The list head * @param type Data type of the list element to retrieve * @param member Member name of the struct list_head field in the list element. * @return A pointer to the first list element. */ #define list_first_entry(ptr, type, member) \ list_entry((ptr)-&gt;next, type, member) static inline void list_replace_init(struct list_head *old, struct list_head *new) { list_replace(old, new); INIT_LIST_HEAD(old); } /** * list_entry - get the struct for this entry * @ptr: the &amp;struct list_head pointer. * @type: the type of the struct this is embedded in. * @member: the name of the list_struct within the struct. */ #define list_entry(ptr, type, member) \ ((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member))) /** * list_for_each - iterate over elements in a list * @pos: the &amp;struct list_head to use as a loop counter. * @head: the head for your list. */ #define list_for_each(pos, head) \ for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next) /** * list_for_each_safe - iterate over elements in a list, but don&#39;t dereference * pos after the body is done (in case it is freed) * @pos: the &amp;struct list_head to use as a loop counter. * @pnext: the &amp;struct list_head to use as a pointer to the next item. * @head: the head for your list (not included in iteration). */ #define list_for_each_safe(pos, pnext, head) \ for (pos = (head)-&gt;next, pnext = pos-&gt;next; pos != (head); \ pos = pnext, pnext = pos-&gt;next) #ifdef __cplusplus } #endif #endif /* _BLKID_LIST_H */这里面一般会用到一个重要实现：container_of, 它的原理这里不叙述
调试信息头文件: log.h 这个头文件实际上不是必须的，我只是用它来添加调试信息(代码中的errlog(), log()都是log.h中的宏函数)。它的效果是给打印的信息加上颜色，效果如下：
log.h的代码如下：
#ifndef _LOG_h_ #define _LOG_h_ #include &lt;stdio.h&gt;#define COL(x) &#34;\033[;&#34; #x &#34;m&#34; #define RED COL(31) #define GREEN COL(32) #define YELLOW COL(33) #define BLUE COL(34) #define MAGENTA COL(35) #define CYAN COL(36) #define WHITE COL(0) #define GRAY &#34;\033[0m&#34; #define errlog(fmt, arg...) do{ \ printf(RED&#34;[#ERROR: Toeny Sun:&#34;GRAY YELLOW&#34; %s:%d]:&#34;GRAY WHITE fmt GRAY, __func__, __LINE__, ##arg);\ }while(0) #define log(fmt, arg...) do{ \ printf(WHITE&#34;[#DEBUG: Toeny Sun: &#34;GRAY YELLOW&#34;%s:%d]:&#34;GRAY WHITE fmt GRAY, __func__, __LINE__, ##arg);\ }while(0) #endif 时间轮代码: timewheel.c /* *毫秒定时器 采用多级时间轮方式 借鉴linux内核中的实现 *支持的范围为1 ~ 2^32 毫秒(大约有49天) *若设置的定时器超过最大值 则按最大值设置定时器 **/ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/time.h&gt;#include &#34;list.h&#34;#include &#34;log.h&#34; #define TVN_BITS 6 #define TVR_BITS 8 #define TVN_SIZE (1&lt;&lt;TVN_BITS) #define TVR_SIZE (1&lt;&lt;TVR_BITS)  #define TVN_MASK (TVN_SIZE - 1) #define TVR_MASK (TVR_SIZE - 1)  #define SEC_VALUE 0 #define USEC_VALUE 2000  struct tvec_base; #define INDEX(N) ((ba-&gt;current_index &gt;&gt; (TVR_BITS + (N) * TVN_BITS)) &amp; TVN_MASK)  typedef void (*timeouthandle)(unsigned long ); struct timer_list{ struct list_head entry; //将时间连接成链表  unsigned long expires; //超时时间  void (*function)(unsigned long); //超时后的处理函数  unsigned long data; //处理函数的参数  struct tvec_base *base; //指向时间轮 }; struct tvec { struct list_head vec[TVN_SIZE]; }; struct tvec_root{ struct list_head vec[TVR_SIZE]; }; //实现5级时间轮 范围为0~ (2^8 * 2^6 * 2^6 * 2^6 *2^6)=2^32 struct tvec_base { unsigned long current_index; pthread_t thincrejiffies; pthread_t threadID; struct tvec_root tv1; /*第一个轮*/ struct tvec tv2; /*第二个轮*/ struct tvec tv3; /*第三个轮*/ struct tvec tv4; /*第四个轮*/ struct tvec tv5; /*第五个轮*/ }; static void internal_add_timer(struct tvec_base *base, struct timer_list *timer) { struct list_head *vec; unsigned long expires = timer-&gt;expires; unsigned long idx = expires - base-&gt;current_index; #if 1  if( (signed long)idx &lt; 0 ) /*这里是没有办法区分出是过时还是超长定时的吧?*/ { vec = base-&gt;tv1.vec + (base-&gt;current_index &amp; TVR_MASK);/*放到第一个轮的当前槽*/ } else if ( idx &lt; TVR_SIZE ) /*第一个轮*/ { int i = expires &amp; TVR_MASK; vec = base-&gt;tv1.vec + i; } else if( idx &lt; 1 &lt;&lt; (TVR_BITS + TVN_BITS) )/*第二个轮*/ { int i = (expires &gt;&gt; TVR_BITS) &amp; TVN_MASK; vec = base-&gt;tv2.vec + i; } else if( idx &lt; 1 &lt;&lt; (TVR_BITS + 2 * TVN_BITS) )/*第三个轮*/ { int i = (expires &gt;&gt; (TVR_BITS + TVN_BITS)) &amp; TVN_MASK; vec = base-&gt;tv3.vec + i; } else if( idx &lt; 1 &lt;&lt; (TVR_BITS + 3 * TVN_BITS) )/*第四个轮*/ { int i = (expires &gt;&gt; (TVR_BITS + 2 * TVN_BITS)) &amp; TVN_MASK; vec = base-&gt;tv4.vec + i; } else /*第五个轮*/ { int i; if (idx &gt; 0xffffffffUL) { idx = 0xffffffffUL; expires = idx + base-&gt;current_index; } i = (expires &gt;&gt; (TVR_BITS + 3 * TVN_BITS)) &amp; TVN_MASK; vec = base-&gt;tv5.vec + i; } #else  /*上面可以优化吧*/; #endif  list_add_tail(&amp;timer-&gt;entry, vec); } static inline void detach_timer(struct timer_list *timer) { struct list_head *entry = &amp;timer-&gt;entry; __list_del(entry-&gt;prev, entry-&gt;next); entry-&gt;next = NULL; entry-&gt;prev = NULL; } static int __mod_timer(struct timer_list *timer, unsigned long expires) { if(NULL != timer-&gt;entry.next) detach_timer(timer); internal_add_timer(timer-&gt;base, timer); return 0; } //修改定时器的超时时间外部接口 int mod_timer(void *ptimer, unsigned long expires) { struct timer_list *timer = (struct timer_list *)ptimer; struct tvec_base *base; base = timer-&gt;base; if(NULL == base) return -1; expires = expires + base-&gt;current_index; if(timer-&gt;entry.next != NULL &amp;&amp; timer-&gt;expires == expires) return 0; if( NULL == timer-&gt;function ) { errlog(&#34;timer&#39;s timeout function is null\n&#34;); return -1; } timer-&gt;expires = expires; return __mod_timer(timer,expires); } //添加一个定时器 static void __ti_add_timer(struct timer_list *timer) { if( NULL != timer-&gt;entry.next ) { errlog(&#34;timer is already exist\n&#34;); return; } mod_timer(timer, timer-&gt;expires); } /*添加一个定时器 外部接口 *返回定时器 */ void* ti_add_timer(void *ptimewheel, unsigned long expires,timeouthandle phandle, unsigned long arg) { struct timer_list *ptimer; ptimer = (struct timer_list *)malloc( sizeof(struct timer_list) ); if(NULL == ptimer) return NULL; bzero( ptimer,sizeof(struct timer_list) ); ptimer-&gt;entry.next = NULL; ptimer-&gt;base = (struct tvec_base *)ptimewheel; ptimer-&gt;expires = expires; ptimer-&gt;function = phandle; ptimer-&gt;data = arg; __ti_add_timer(ptimer); return ptimer; } /* *删除一个定时器 外部接口 * * */ void ti_del_timer(void *p) { struct timer_list *ptimer =(struct timer_list*)p; if(NULL == ptimer) return; if(NULL != ptimer-&gt;entry.next) detach_timer(ptimer); free(ptimer); } /*时间轮级联*/ static int cascade(struct tvec_base *base, struct tvec *tv, int index) { struct list_head *pos,*tmp; struct timer_list *timer; struct list_head tv_list; /*将tv[index]槽位上的所有任务转移给tv_list,然后清空tv[index]*/ list_replace_init(tv-&gt;vec + index, &amp;tv_list);/*用tv_list替换tv-&gt;vec + index*/ list_for_each_safe(pos, tmp, &amp;tv_list)/*遍历tv_list双向链表，将任务重新添加到时间轮*/ { timer = list_entry(pos,struct timer_list,entry);/*struct timer_list中成员entry的地址是pos, 获取struct timer_list的首地址*/ internal_add_timer(base, timer); } return index; } static void *deal_function_timeout(void *base) { struct timer_list *timer; int ret; struct timeval tv; struct tvec_base *ba = (struct tvec_base *)base; for(;;) { gettimeofday(&amp;tv, NULL); while( ba-&gt;current_index &lt;= (tv.tv_sec*1000 + tv.tv_usec/1000) )/*单位：ms*/ { struct list_head work_list; int index = ba-&gt;current_index &amp; TVR_MASK;/*获取第一个轮上的指针位置*/ struct list_head *head = &amp;work_list; /*指针指向0槽时，级联轮需要更新任务列表*/ if(!index &amp;&amp; (!cascade(ba, &amp;ba-&gt;tv2, INDEX(0))) &amp;&amp;( !cascade(ba, &amp;ba-&gt;tv3, INDEX(1))) &amp;&amp; (!cascade(ba, &amp;ba-&gt;tv4, INDEX(2))) ) cascade(ba, &amp;ba-&gt;tv5, INDEX(3)); ba-&gt;current_index ++; list_replace_init(ba-&gt;tv1.vec + index, &amp;work_list); while(!list_empty(head)) { void (*fn)(unsigned long); unsigned long data; timer = list_first_entry(head, struct timer_list, entry); fn = timer-&gt;function; data = timer-&gt;data; detach_timer(timer); (*fn)(data); } } } } static void init_tvr_list(struct tvec_root * tvr) { int i; for( i = 0; i&lt;TVR_SIZE; i++ ) INIT_LIST_HEAD(&amp;tvr-&gt;vec[i]); } static void init_tvn_list(struct tvec * tvn) { int i; for( i = 0; i&lt;TVN_SIZE; i++ ) INIT_LIST_HEAD(&amp;tvn-&gt;vec[i]); } //创建时间轮 外部接口 void *ti_timewheel_create(void ) { struct tvec_base *base; int ret = 0; struct timeval tv; base = (struct tvec_base *) malloc( sizeof(struct tvec_base) ); if( NULL==base ) return NULL; bzero( base,sizeof(struct tvec_base) ); init_tvr_list(&amp;base-&gt;tv1); init_tvn_list(&amp;base-&gt;tv2); init_tvn_list(&amp;base-&gt;tv3); init_tvn_list(&amp;base-&gt;tv4); init_tvn_list(&amp;base-&gt;tv5); gettimeofday(&amp;tv, NULL); base-&gt;current_index = tv.tv_sec*1000 + tv.tv_usec/1000;/*当前时间毫秒数*/ if( 0 != pthread_create(&amp;base-&gt;threadID,NULL,deal_function_timeout,base) ) { free(base); return NULL; } return base; } static void ti_release_tvr(struct tvec_root *pvr) { int i; struct list_head *pos,*tmp; struct timer_list *pen; for(i = 0; i &lt; TVR_SIZE; i++) { list_for_each_safe(pos,tmp,&amp;pvr-&gt;vec[i]) { pen = list_entry(pos,struct timer_list, entry); list_del(pos); free(pen); } } } static void ti_release_tvn(struct tvec *pvn) { int i; struct list_head *pos,*tmp; struct timer_list *pen; for(i = 0; i &lt; TVN_SIZE; i++) { list_for_each_safe(pos,tmp,&amp;pvn-&gt;vec[i]) { pen = list_entry(pos,struct timer_list, entry); list_del(pos); free(pen); } } } /* *释放时间轮 外部接口 * */ void ti_timewheel_release(void * pwheel) { struct tvec_base *base = (struct tvec_base *)pwheel; if(NULL == base) return; ti_release_tvr(&amp;base-&gt;tv1); ti_release_tvn(&amp;base-&gt;tv2); ti_release_tvn(&amp;base-&gt;tv3); ti_release_tvn(&amp;base-&gt;tv4); ti_release_tvn(&amp;base-&gt;tv5); free(pwheel); } /************demo****************/ struct request_para{ void *timer; int val; }; void mytimer(unsigned long arg) { struct request_para *para = (struct request_para *)arg; log(&#34;%d\n&#34;,para-&gt;val); mod_timer(para-&gt;timer,3000); //进行再次启动定时器  sleep(10);/*定时器依然被阻塞*/ //定时器资源的释放是在这里完成的  //ti_del_timer(para-&gt;timer); } int main(int argc,char *argv[]) { void *pwheel = NULL; void *timer = NULL; struct request_para *para; para = (struct request_para *)malloc( sizeof(struct request_para) ); if(NULL == para) return 0; bzero(para,sizeof(struct request_para)); //创建一个时间轮  pwheel = ti_timewheel_create(); if(NULL == pwheel) return -1; //添加一个定时器  para-&gt;val = 100; para-&gt;timer = ti_add_timer(pwheel, 3000, &amp;mytimer, (unsigned long)para); while(1) { sleep(2); } //释放时间轮  ti_timewheel_release(pwheel); return 0; } 编译运行 peng@ubuntu:/mnt/hgfs/timer/4. timerwheel/2. 多级时间轮$ ls a.out list.h log.h mutiTimeWheel.c toney@ubantu:/mnt/hgfs/timer录/4. timerwheel/2. 多级时间轮$ gcc mutiTimeWheel.c -lpthread toney@ubantu:/mnt/hgfs/timer/4. timerwheel/2. 多级时间轮$ ./a.out [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 [#DEBUG: Toeny Sun: mytimer:370]:100 从结果可以看出：如果添加的定时任务是比较耗时的操作，那么后续的任务也会被阻塞，可能一直到超时，甚至一直阻塞下去，这个取决于当前任务是否耗时。
这个理论上是绝不能接受的：一个任务不应该也不能去影响其他的任务吧。但是目前没有对此问题进行改进和完善，以后有机会再继续完善吧。
]]></content>
  </entry>
  
  <entry>
    <title>Linux mmap内存映射详解</title>
    <url>/post/linux/linux-mmap-explanation.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>linux</tag>
      <tag>device driver</tag>
    </tags>
    <content type="html"><![CDATA[mmap用于把文件映射到内存空间中，简单说mmap就是把一个文件的内容在内存里面做一个映像。
mmap基础概念 mmap是一种内存映射的方法，这一功能可以用在文件的处理上，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。在编程时可以使某个磁盘文件的内容看起来像是内存中的一个数组。如果文件由记录组成，而这些记录又能够用结构体来描述的话，可以通过访问结构体来更新文件的内容。
实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写到页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如图所示：
进程的虚拟地址空间，由多个虚拟内存区域构成。虚拟内存区域是进程的虚拟地址空间中的一个同质区间，即具有同样特性的连续地址范围。上图中所示的text数据段（代码段）、初始数据段、BSS数据段、堆、栈和内存映射，都是一个独立的虚拟内存区域。而为内存映射服务的地址空间处在堆栈之间的空余部分。
内核为系统中的每个进程维护一个单独的任务结构（task_struct）。任务结构中的元素包含或者指向内核运行该进程所需的所有信息(PID、指向用户栈的指针、可执行目标文件的名字、程序计数器等)。Linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：
vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。
mm_struct：描述了虚拟内存的当前状态。pgd指向一级页表的基址（当内核运行这个进程时， pgd会被存放在CR3控制寄存器，也就是页表基址寄存器中），mmap指向一个vm_area_structs 的链表，其中每个vm_area_structs都描述了当前虚拟地址空间的一个区域。 vm_starts 指向这个区域的起始处。 vm_end 指向这个区域的结束处。 vm_prot 描述这个区域内包含的所有页的读写许可权限。 vm_flags 描述这个区域内的页面是与其他进程共享的，还是这个进程私有的以及一些其他信息。 vm_next 指向链表的下一个区域结构。  mmap内存映射原理 mmap内存映射的实现过程，总的来说可以分为三个阶段：
(一)启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域    进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
  在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址。
  为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化。
  将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中。
  (二)调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系   为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护者和这个已打开文件相关的各项信息。
  通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。
  内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。
  通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。
  (三)进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝  注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读写操作时。
 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。
  缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。
  调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。
  之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。
  注意：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。
mmap 示例代码 mmap (内存映射)函数的作用是建立一段可以被两个或更多个程序读写的内存。一个程序对它所做出的修改可以被其他程序看见。这要通过使用带有特殊权限集的虚拟内存段来实现。对这类虚拟内存段的读写会使操作系统去读写磁盘文件中与之对应的部分。mmap 函数创建一个指向一段内存区域的指针，该内存区域与可以通过一个打开的文件描述符访问的文件的内容相关联。mmap 函数原型如下：
#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 可以通过传递 off 参数来改变共享内存段访问的文件中数据的起始偏移值。打开的文件描述符由 fildes 参数给出。可以访问的数据量(即内存段的长度)由 len 参数设置。
可以通过 addr 参数来请求使用某个特定的内存地址。如果它的取值是零，结果指针就将自动分配。这是推荐的做法，否则会降低程序的可移植性，因为不同系统上的可用地址范围是不一样的。
prot 参数用于设置内存段的访问权限。它是下列常数值的按位或的结果：
PROT_READ 内存段可读。 PROT_WRITE 内存段可写。 PROT_EXEC 内存段可执行。 PROT_NONE 内存段不能被访问。 flags 参数控制程序对该内存段的改变所造成的影响：
msync 函数的作用是：把在该内存段的某个部分或整段中的修改写回到被映射的文件中(或者从被映射文件里读出)。
#include &lt;sys/mman.h&gt;int msync(void *addr, size_t len, int flags); 内存段需要修改的部分由作为参数传递过来的起始地址 addr 和长度 len 确定。flags 参数控制着执行修改的具体方式，可以使用的选项如下：
MS_ASYNC 采用异步写方式 MS_SYNC 采用同步写方式 MS_INVALIDATE 从文件中读回数据 munmap 函数的作用是释放内存段：
#include &lt;sys/mman.h&gt;int munmap(void *addr, size_t length); 示例代码：
(1) 定义一个 RECORD 数据结构，然后创建出 NRECORDS 每个记录，每个记录中保存着它们各自的编号。然后把这些记录都追加到文件 records.dat 里去。
(2) 接着，把第 43 记录中的整数值由 43 修改为 143，并把它写入第 43 条记录中的字符串。
(3) 把这些记录映射到内存中，然后访问第 43 条记录，把它的整数值修改为 243 (同时更新该记录中的字符串)，使用的还是内存映射的方法。
可以将上述 (2) (3) 分别编写程序验证结果。
#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;typedef struct{ int integer; char string[24]; }RECORD; #define NRECORDS (100) int main() { RECORD record, *mapped; int i, f; FILE *fp; fp = fopen(&#34;records.dat&#34;, &#34;w+&#34;); for( i = 0; i &lt; NRECORDS; i++) { record.integer = i; sprintf(record.string, &#34;[RECORD-%d]&#34;, i); fwrite(&amp;record, sizeof(record), 1, fp); } fclose(fp); fp = fopen(&#34;records.dat&#34;, &#34;r+&#34;); fseek(fp, 43 * sizeof(record), SEEK_SET); fread(&amp;record, sizeof(record), 1, fp); record.integer = 143; sprintf(record.string, &#34;[RECORD-%d]&#34;, record.integer); fseek(fp, 43 * sizeof(record), SEEK_SET); fwrite(&amp;record, sizeof(record), 1, fp); fclose(fp); f = open(&#34;records.dat&#34;, O_RDWR); mapped = (RECORD*)mmap(0, NRECORDS * sizeof(record), PROT_READ | PROT_WRITE, MAP_SHARED, f, 0); printf(&#34;f:[%d]\n&#34;, f); //open是系统调用，返回文件描述符。fopen是库函数，返回指针。 	mapped[43].integer = 243; sprintf(mapped[43].string, &#34;[RECORD-%d]&#34;, mapped[43].integer); msync((void *) mapped, NRECORDS * sizeof(record), MS_ASYNC); munmap((void *)mapped, NRECORDS * sizeof(record)); close(f); return 0;	} mmap 和常规文件操作的区别 使用系统调用，函数的调用过程：
  进程发起读文件请求。
  内核通过查找进程文件描述符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。
  inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。
  如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。
  总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。
而使用mmap操作文件中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。
总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同、数据不通的繁琐过程。因此mmap效率更高。
由上文讨论可知，mmap优点共有一下几点：
  对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。
  实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。
  提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。
  同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。
可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。  mmap 使用的细节   使用mmap需要注意的一个关键点是，mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是，内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位。为了匹配内存的操作，mmap从磁盘到虚拟地址空间的映射也必须是页。
  内核可以跟踪被内存映射的底层对象（文件）的大小，进程可以合法的访问在当前文件大小以内又在内存映射区以内的那些字节。也就是说，如果文件的大小一直在扩张，只要在映射区域范围内的数据，进程都可以合法得到，这和映射建立时文件的大小无关。
  映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。
 ]]></content>
  </entry>
  
  <entry>
    <title>几道简单的Linux驱动相关面试题</title>
    <url>/post/linux/linux-device-driver-questions-and-answers.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>linux</tag>
      <tag>device driver</tag>
    </tags>
    <content type="html"><![CDATA[今天给大家分享几道Linux设备驱动相关的面试题，希望能对需要的网友一些帮助！
Linux基础 任意3种网络操作的Linux命令,并说明他们的含义 ifconfig 命令 ifconfig 用于查看和配置 Linux 系统的网络接口。 查看所有网络接口及其状态：ifconfig -a 。 使用 up 和 down 命令启动或停止某个接口：ifconfig eth0 up 和 ifconfig eth0 down 。
iptables 命令 iptables ，是一个配置 Linux 内核防火墙的命令行工具。功能非常强大，对于我们开发来说，主要掌握如何开放端口即可。
netstat 命令 Linux netstat命令用于显示网络状态。
利用netstat指令可让你得知整个Linux系统的网络情况。
ping 命令 Linux ping命令用于检测主机。
执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
telnet 命令 Linux telnet命令用于远端登入。
执行telnet指令开启终端机阶段作业，并登入远端主机。
Linux支持的文件类型  普通文件类型 - 目录文件类型 d 块设备文件类型 b 字符设备类型 c 套接字文件类型 s FIFO管道文件类型 p 链接文件类型 l  Linux系统编程 嵌入式操作系统进程间有哪些同步通信服务？ Linux进程间通信方式主要有  信号(signal) 信号量 管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。 消息队列 共享内存 套接字（本地的还有域套接字）  ARM 请问ARM支持哪几种异常类型？ 异常源分类
要进入异常模式，一定要有异常源，ARM规定有7种异常源：
   异常源 描述     Reset 上电时执行   Undef 当流水线中的某个非法指令到达执行状态时执行   SWI 当一个软中断指令被执行完的时候执行   Prefetch 当一个指令被从内存中预取时，由于某种原因而失败，如果它能到达执行状态这个异常才会产生   Data 如果一个预取指令试图存取一个非法的内存单元，这时异常产生   IRQ 通常的中断   FIQ 快速中断    请简述什么是中断？中断发生后，CPU做了哪些操作 中断：是指CPU在执行程序的过程中，出现了某些突发事件时CPU必须暂停执行当前的程序，转去处理突发事件，处理完毕后CPU又返回源程序被中断的位置并继续执行。
中断发生后，ARM核的操作步骤可以总结为4大步3小步。
4大步3小步  保存执行状态：将CPSR复制到发生的异常模式下SPSR中； 模式切换：   CPSR模式位强制设置为与异常类型相对应的值， 处理器进入到ARM执行模式， 禁止所有IRQ中断，当进入FIQ快速中断模式时禁止FIQ中断；   保存返回地址：将下一条指令的地址（被打断程序）保存在LR(异常模式下LR_excep)中。 跳入异常向量表：强制设置PC的值为相应异常向量地址，跳转到异常处理程序中。  什么是GPIO？ general purpose input/output GPIO是相对于芯片本身而言的，如某个管脚是芯片的GPIO脚，则该脚可作为输入或输出高或低电平使用，当然某个脚具有复用的功能，即可做GPIO也可做其他用途。
也就是说你可以把这些引脚拿来用作任何一般用途的输入输出，例如用一根引脚连到led的一极来控制它的亮灭，也可以用一根（一些）引脚连到一个传感器上以获得该传感器的状态，这给cpu提供了一个方便的控制周边设备的途经。如果没有足够多的gpio管脚，在控制一些外围设备时就会力有不逮，这时可采取的方案是使用CPLD来帮助管理。
IIC引脚名称及功能？  SDA 数据线，用于传输数据 SCL 时钟线，用于同步数据  IIC的S、P信号如何发出？ 每次通信都必须由主设备发起，当主设备决定开始通讯时，需要发送开始（S）信号，需要执行以下动作；
 空闲时SCL默认是高电平； 将SDA线从高压电平切换到低压电平； 然后将SCL从高电平切换到低电平。 在主设备发送开始条件信号之后，所有从机即使处于睡眠模式也将变为活动状态，并等待接收地址位。 当双方决定结束通讯时，需要发送停止（P）信号，需要执行以下动作； 先将SDA、SCL设置为低电平； 然后将SCL从低电平切换到高电平； 将SDA从低电平切换到高电平。 在停止条件信号之后，I2C总线即处于空闲状态。  SPI引脚名称及功能？ 串行时钟线（SCK）、 主机输入/从机输出数据线MISO、 主机输出/从机输入数据线MOSI 从机选择线SS
(有的SPI接口芯片带有中断信号线INT或INT、有的SPI接口芯片没有主机输出/从机输入数据线MOSI)
驱动  查看驱动模块中打印信息应该使用什么命令？如何查看内核中已有的字符设备的信息？如何查看正在使用的有哪些中断号？
 查看驱动模块中打印信息的命令： dmesg 查看加载模块信息可以用 lsmod 已经分配的字符设备块设备号信息可以查看下面文件 cat /proc/devices 内核会为每一个驱动模块建立一个文件夹，如下： ls /sys/module/ 显示当前使用的中断号 cat /proc/interrupts  如何手动创建字符设备？并简述主设备号和次设备号的用途。
 创建字符设备命令如下:
mknod chartest c 4 64， mknod : 创建设备节点 chartest ：设备节点名字 c ： 字符设备， 4 ： 主设备号 64： 次设备号 主设备号：主设备号标识设备对应的驱动程序。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织。
次设备号：次设备号由内核使用，用于正确确定设备文件所指的设备。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。
比如：
硬件平台可能又4个串口，他们驱动非常类似，区别仅仅是个字对应的SFR基地址不同， 那么我们可以让着几个串口共用同一个串口设备驱动 通过次设备号来区别具体是哪一个串口  内核中使用共享资源时，为了使之满足互斥条件，通常有哪些方法？
 原子操作，自旋锁，信号量，互斥锁
 Linux内核包括那几个子系统？
 Linux内核主要由进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）和进程间通信（IPC）5个子系统组成
]]></content>
  </entry>
  
  <entry>
    <title>10个Python脚本来自动化你的日常任务</title>
    <url>/post/python/ten-python-script-to-automatically-execute-your-daily-task.html</url>
    <categories><category>Python</category>
    </categories>
    <tags>
      <tag>python</tag>
    </tags>
    <content type="html"><![CDATA[ 在这个自动化时代，我们有很多重复无聊的工作要做。 想想这些你不再需要一次又一次地做的无聊的事情，让它自动化，让你的生活更轻松。 那么在本文中，我将向您介绍 10 个 Python 自动化脚本，以使你的工作更加自动化，生活更加轻松。 因此，没有更多的重复任务将这篇文章放在您的列表中，让我们开始吧。
 解析和提取 HTML  此自动化脚本将帮助你从网页 URL 中提取 HTML，然后还为你提供可用于解析 HTML 以获取数据的功能。这个很棒的脚本对于网络爬虫和那些想要解析 HTML 以获取重要数据的人来说是一种很好的享受。
 # Parse and Extract HTML # pip install gazpacho import gazpacho # Extract HTML from URL url = &#39;https://www.example.com/&#39; html = gazpacho.get(url) print(html) # Extract HTML with Headers headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0&#39;} html = gazpacho.get(url, headers=headers) print(html) # Parse HTML parse = gazpacho.Soup(html) # Find single tags tag1 = parse.find(&#39;h1&#39;) tag2 = parse.find(&#39;span&#39;) # Find multiple tags tags1 = parse.find_all(&#39;p&#39;) tags2 = parse.find_all(&#39;a&#39;) # Find tags by class tag = parse.find(&#39;.class&#39;) # Find tags by Attribute tag = parse.find(&#34;div&#34;, attrs={&#34;class&#34;: &#34;test&#34;}) # Extract text from tags text = parse.find(&#39;h1&#39;).text text = parse.find_all(&#39;p&#39;)[0].text 二维码扫描仪  拥有大量二维码图像或只想扫描二维码图像，那么此自动化脚本将帮助你。该脚本使用 Qrtools 模块，使你能够以编程方式扫描 QR 图像。
 # Qrcode Scanner # pip install qrtools from qrtools import Qr def Scan_Qr(qr_img): qr = Qr() qr.decode(qr_img) print(qr.data) return qr.data print(&#34;Your Qr Code is: &#34;, Scan_Qr(&#34;qr.png&#34;)) 截图  现在，你可以使用下面这个很棒的脚本以编程方式截取屏幕截图。使用此脚本，你可以直接截屏或截取特定区域的屏幕截图。
 # Grab Screenshot # pip install pyautogui # pip install Pillow from pyautogui import screenshot import time from PIL import ImageGrab # Grab Screenshot of Screen def grab_screenshot(): shot = screenshot() shot.save(&#39;my_screenshot.png&#39;) # Grab Screenshot of Specific Area def grab_screenshot_area(): area = (0, 0, 500, 500) shot = ImageGrab.grab(area) shot.save(&#39;my_screenshot_area.png&#39;) # Grab Screenshot with Delay def grab_screenshot_delay(): time.sleep(5) shot = screenshot() shot.save(&#39;my_screenshot_delay.png&#39;) 创建有声读物  厌倦了手动将您的 PDF 书籍转换为有声读物，那么这是你的自动化脚本，它使用 GTTS 模块将你的 PDF 文本转换为音频。
 # Create Audiobooks # pip install gTTS # pip install PyPDF2 from PyPDF2 import PdfFileReader as reader from gtts import gTTS def create_audio(pdf_file): read_Pdf = reader(open(pdf_file, &#39;rb&#39;)) for page in range(read_Pdf.numPages): text = read_Pdf.getPage(page).extractText() tts = gTTS(text, lang=&#39;en&#39;) tts.save(&#39;page&#39; + str(page) + &#39;.mp3&#39;) create_audio(&#39;book.pdf&#39;) PDF 编辑器  使用以下自动化脚本使用 Python 编辑 PDF 文件。该脚本使用 PyPDF4 模块，它是 PyPDF2 的升级版本，下面我编写了 Parse Text、Remove pages 等常用功能。当你有大量 PDF 文件要编辑或需要以编程方式在 Python 项目中使用脚本时，这是一个方便的脚本。
 # PDF Editor # pip install PyPDf4 import PyPDF4 # Parse the Text from PDF def parse_text(pdf_file): reader = PyPDF4.PdfFileReader(pdf_file) for page in reader.pages: print(page.extractText()) # Remove Page from PDF def remove_page(pdf_file, page_numbers): filer = PyPDF4.PdfReader(&#39;source.pdf&#39;, &#39;rb&#39;) out = PyPDF4.PdfWriter() for index in page_numbers: page = filer.pages[index] out.add_page(page) with open(&#39;rm.pdf&#39;, &#39;wb&#39;) as f: out.write(f) # Add Blank Page to PDF def add_page(pdf_file, page_number): reader = PyPDF4.PdfFileReader(pdf_file) writer = PyPDF4.PdfWriter() writer.addPage() with open(&#39;add.pdf&#39;, &#39;wb&#39;) as f: writer.write(f) # Rotate Pages def rotate_page(pdf_file): reader = PyPDF4.PdfFileReader(pdf_file) writer = PyPDF4.PdfWriter() for page in reader.pages: page.rotateClockwise(90) writer.addPage(page) with open(&#39;rotate.pdf&#39;, &#39;wb&#39;) as f: writer.write(f) # Merge PDFs def merge_pdfs(pdf_file1, pdf_file2): pdf1 = PyPDF4.PdfFileReader(pdf_file1) pdf2 = PyPDF4.PdfFileReader(pdf_file2) writer = PyPDF4.PdfWriter() for page in pdf1.pages: writer.addPage(page) for page in pdf2.pages: writer.addPage(page) with open(&#39;merge.pdf&#39;, &#39;wb&#39;) as f: writer.write(f) 迷你 Stackoverflow  作为一名程序员，我知道我们每天都需要 StackOverflow，但你不再需要在 Google 上搜索它。现在，在您继续处理项目的同时，在你的 CMD 中获得直接解决方案。通过使用 Howdoi 模块，你可以在命令提示符或终端中获得 StackOverflow 解决方案。你可以在下面找到一些可以尝试的示例。
 # Automate Stackoverflow # pip install howdoi # Get Answers in CMD #example 1 &gt; howdoi how do i install python3 # example 2 &gt; howdoi selenium Enter keys # example 3 &gt; howdoi how to install modules # example 4 &gt; howdoi Parse html with python # example 5 &gt; howdoi int not iterable error # example 6 &gt; howdoi how to parse pdf with python # example 7 &gt; howdoi Sort list in python # example 8 &gt; howdoi merge two lists in python # example 9 &gt;howdoi get last element in list python # example 10 &gt; howdoi fast way to sort list 自动化手机  此自动化脚本将帮助你使用 Python 中的 Android 调试桥 (ADB) 自动化你的智能手机。下面我将展示如何自动执行常见任务，例如滑动手势、呼叫、发送短信等等。您可以了解有关 ADB 的更多信息，并探索更多令人兴奋的方法来实现手机自动化，让您的生活更轻松。
 # Automate Mobile Phones # pip install opencv-python import subprocess def main_adb(cm): p = subprocess.Popen(cm.split(&#39; &#39;), stdout=subprocess.PIPE, shell=True) (output, _) = p.communicate() return output.decode(&#39;utf-8&#39;) # Swipe  def swipe(x1, y1, x2, y2, duration): cmd = &#39;adb shell input swipe {}{}{}{}{}&#39;.format(x1, y1, x2, y2, duration) return main_adb(cmd) # Tap or Clicking def tap(x, y): cmd = &#39;adb shell input tap {}{}&#39;.format(x, y) return main_adb(cmd) # Make a Call def make_call(number): cmd = f&#34;adb shell am start -a android.intent.action.CALL -d tel:{number}&#34; return main_adb(cmd) # Send SMS def send_sms(number, message): cmd = &#39;adb shell am start -a android.intent.action.SENDTO -d sms:{}--es sms_body &#34;{}&#34;&#39;.format(number, message) return main_adb(cmd) # Download File From Mobile to PC def download_file(file_name): cmd = &#39;adb pull /sdcard/{}&#39;.format(file_name) return main_adb(cmd) # Take a screenshot def screenshot(): cmd = &#39;adb shell screencap -p&#39; return main_adb(cmd) # Power On and Off def power_off(): cmd = &#39;&#34;adb shell input keyevent 26&#34;&#39; return main_adb(cmd) 监控 CPU/GPU 温度  你可能使用 CPU-Z 或任何规格监控软件来捕获你的 Cpu 和 Gpu 温度，但你也可以通过编程方式进行。好吧，这个脚本使用 Pythonnet 和 OpenhardwareMonitor 来帮助你监控当前的 Cpu 和 Gpu 温度。你可以使用它在达到一定温度时通知自己，也可以在 Python 项目中使用它来简化日常生活。
 # Get CPU/GPU Temperature # pip install pythonnet import clr clr.AddReference(&#34;OpenHardwareMonitorLib&#34;) from OpenHardwareMonitorLib import * spec = Computer() spec.GPUEnabled = True spec.CPUEnabled = True spec.Open() # Get CPU Temp def Cpu_Temp(): while True: for cpu in range(0, len(spec.Hardware[0].Sensors)): if &#34;/temperature&#34; in str(spec.Hardware[0].Sensors[cpu].Identifier): print(str(spec.Hardware[0].Sensors[cpu].Value)) # Get GPU Temp def Gpu_Temp() while True: for gpu in range(0, len(spec.Hardware[0].Sensors)): if &#34;/temperature&#34; in str(spec.Hardware[0].Sensors[gpu].Identifier): print(str(spec.Hardware[0].Sensors[gpu].Value)) Instagram 上传机器人  Instagram 是一个著名的社交媒体平台，你现在不需要通过智能手机上传照片或视频。你可以使用以下脚本以编程方式执行此操作。
 # Upload Photos and Video on Insta # pip install instabot from instabot import Bot def Upload_Photo(img): robot = Bot() robot.login(user) robot.upload_photo(img, caption=&#34;Medium Article&#34;) print(&#34;Photo Uploaded&#34;) def Upload_Video(video): robot = Bot() robot.login(user) robot.upload_video(video, caption=&#34;Medium Article&#34;) print(&#34;Video Uploaded&#34;) def Upload_Story(img): robot = Bot() robot.login(user) robot.upload_story(img, caption=&#34;Medium Article&#34;) print(&#34;Story Photos Uploaded&#34;) Upload_Photo(&#34;img.jpg&#34;) Upload_Video(&#34;video.mp4&#34;) 视频水印  使用此自动化脚本为你的视频添加水印，该脚本使用 Moviepy，这是一个方便的视频编辑模块。在下面的脚本中，你可以看到如何添加水印并且可以自由使用它。
 # Video Watermark with Python # pip install moviepy from moviepy.editor import * clip = VideoFileClip(&#34;myvideo.mp4&#34;, audio=True) width,height = clip.size text = TextClip(&#34;WaterMark&#34;, font=&#39;Arial&#39;, color=&#39;white&#39;, fontsize=28) set_color = text.on_color(size=(clip.w + text.w, text.h-10), color=(0,0,0), pos=(6,&#39;center&#39;), col_opacity=0.6) set_textPos = set_color.set_pos( lambda pos: (max(width/30,int(width-0.5* width* pos)),max(5*height/6,int(100* pos))) ) Output = CompositeVideoClip([clip, set_textPos]) Output.duration = clip.duration Output.write_videofile(&#34;output.mp4&#34;, fps=30, codec=&#39;libx264&#39;) ]]></content>
  </entry>
  
  <entry>
    <title>FPGA硬核和软核处理器的区别</title>
    <url>/post/fpga/difference-between-hard-core-processor-and-soft-core-processor-of-fpga.html</url>
    <categories><category>FPGA</category>
    </categories>
    <tags>
      <tag>CPU</tag>
      <tag>fpga</tag>
      <tag>processor</tag>
      <tag>Altera</tag>
      <tag>Xilinx</tag>
    </tags>
    <content type="html"><![CDATA[ 从架构的角度来说，SOPC和SoC FPGA是统一的，都是由FPGA部分和处理器部分组成。在SoC FPGA 中，嵌入的是纯硬件基础的硬核处理器，简称HPS(Hardware Processor System)，而SOPC技术中，嵌入的是使用FPGA逻辑资源实现的软核处理器，两者指令集不一样，处理器性能也不一样。
 软核处理器 SOPC技术，即软核处理器，最早是由Altera公司提出来的，它是基于 FPGA  的SOC片上系统设计技术。是使用FPGA的逻辑和资源搭建的一个软核CPU系统，由于是使用FPGA的通用逻辑搭建的CPU，因此具有一定的灵活性，用户可以根据自己的需求对CPU进行定制裁剪，增加一些专用功能，例如除法或浮点运算单元，用于提升CPU在某些专用运算方面的性能，或者删除一些在系统里面使用不到的功能，以节约逻辑资源。
另外也可以根据用户的实际需求，为CPU添加各种标准或定制的外设，例如UART，SPI，IIC等标准接口外设，同时，用户也可以自己使用FPGA的逻辑资源，编写各种专用的外设，然后连接到CPU总线上，由CPU进行控制，以实现软硬件的协同工作，在保证系统性能的同时，增加了系统的灵活性。
而且，如果单个的软核CPU无法满足用户需求，可以添加多个CPU软核，搭建多核系统，通过多核CPU协同工作，让系统拥有更加灵活便捷的控制能力。
由于是使用FPGA资源实现的，所以具有很大的灵活性，可以实现根据需要实现多种处理器，如8051，RISC-V，Xilinx的 MicroBlaze ，Altera的Nios-II等等。
硬核处理器 由于软核CPU是使用FPGA的通用逻辑资源搭建的，相较使用经过布局布线优化的硬核处理器来说，软核处理器够运行的最高实时钟主频要低一些，而且也会相应的消耗较多的FPGA逻辑资源以及片上存储器资源，因此SOPC方案仅适用于对于数处理器整体性能要求不高的应用，例如整个系统的初始化配置，人机交互，多个功能模块间的协调控制等功能。
所以，各大FPGA厂家推出了SoC FPGA技术，是在芯片设计之初，就在内部的硬件电路上添加了硬核处理器，是纯硬件实现的，不会消耗FPGA的逻辑资源，硬核处理器和FPGA逻辑在一定程度上是相互独立的，简单的说，就是SoC FPGA就是把一块ARM处理器和一块FPGA芯片封装成了一个芯片。
例如比较有名的Xilinx的ZYNQ/PYNQ系列集成ARM Cortex-A9处理器，同时具有ARM软件的可编程性和FPGA 的硬件可编程性，不仅可实现重要分析与硬件加速，同时还在单个器件上高度集成 CPU、DSP、ASSP 以及混合信号功能。
ZYNQ开发板 Intel的Cyclone V系列，集成双核Cortex-A9，于2013年发布，在单一芯片上集成了双核的ARM Cortex-A9处理器和FPGA逻辑资源的新型SoC芯片，相较于传统的单一ARM处理器或FPGA芯片，它既拥有了ARM处理器灵活高效的数据运算和事务处理能力，同时又集成了FPGA的高速并行处理优势，同时，基于两者独特的片上互联结构，使用时可以将FPGA上的通用逻辑资源经过配置，映射为ARM处理器的一个或多个具有特定功能的外设，通过高达128位宽的AXI高速总线进行通信，完成数据和控制命令的交互。由于片上的ARM处理器是经过布局布线的硬线逻辑，因此其能工作的时钟主频较高，因此单位时间内能够执行的指令也更多。
区别和联系 从架构的角度来说，SOPC和SoC FPGA是统一的，都是由FPGA部分和处理器部分组成。在SoC FPGA 中，嵌入的是纯硬件基础的硬核处理器，简称HPS(Hardware Processor System)，而SOPC技术中，嵌入的是使用FPGA逻辑资源实现的软核处理器，两者指令集不一样，处理器性能也不一样。
一般来说，硬核处理器的性能要远远高于软核处理器。另外，硬核处理器除了CPU部分，还集成了各种高性能外设，如MMU、DDR3控制器、Nand FLASH控制器等，可以运行成熟的Linux操作系统和应用程序，提供统一的系统API，降低开发者的软件开发难度。而软核CPU虽然可以通过配置，用逻辑资源来搭建相应的控制器以支持相应功能，但是从性能和开发难度上来说，基于SoC FPGA架构进行设计开发是比较好的选择。
ZYNQ内部框图 另外，虽然SoC FPGA芯片上既包含了有ARM，又包含了有FPGA，但是两者一定程度上是相互独立的，SoC芯片上的ARM处理器核并非是包含于FPGA逻辑单元内部的，FPGA和ARM（HPS）处理器只是封装到同一个芯片中，JTAG接口、电源引脚和外设的接口引脚都是独立的，因此，如果使用SoC FPGA芯片进行设计，即使不使用到片上的ARM处理器，ARM处理器部分占用的芯片资源也无法释放出来，不能用作通用的FPGA资源。
而SOPC则是使用FPGA通用逻辑和存储器资源搭建的CPU，当不使用CPU时，CPU部分占用的资源可以被释放，重新用作通用FPGA资源。
]]></content>
  </entry>
  
  <entry>
    <title>详解嵌入式LCD的接口类型</title>
    <url>/post/fpga/embedded-lcd-interface-model.html</url>
    <categories><category>FPGA</category>
    </categories>
    <tags>
      <tag>LCD</tag>
      <tag>RGB</tag>
    </tags>
    <content type="html"><![CDATA[ 从架构的角度来说，SOPC和SoC FPGA是统一的，都是由FPGA部分和处理器部分组成。在SoC FPGA 中，嵌入的是纯硬件基础的硬核处理器，简称HPS(Hardware Processor System)，而SOPC技术中，嵌入的是使用FPGA逻辑资源实现的软核处理器，两者指令集不一样，处理器性能也不一样。
 LCD的接口有多种，分类很细。主要看LCD的驱动方式和控制方式，目前手机上的彩色LCD的连接方式一般有这么几种：MCU模式，RGB模式，SPI模式，VSYNC模式，MDDI模式，DSI模式。MCU模式(也写成MPU模式的)。只有TFT模块才有RGB接口。
但应用比较多的就是MUC模式和RGB模式，区别有以下几点：
MCU接口: 会解码命令，由timing generator产生时序信号，驱动COM和SEG驱器。
RGB接口: 在写LCD register setting时，和MCU接口没有区别。区别只在于图像的写入方式。
用MCU模式时由于数据可以先存到IC内部GRAM后再往屏上写，所以这种模式LCD可以直接接在MEMORY的总线上。
用RGB模式时就不同了，它没有内部RAM，HSYNC，VSYNC，ENABLE，CS，RESET，RS可以直接接在MEMORY的GPIO口上，用GPIO口来模拟波形.
MPU接口方式: 显示数据写入DDRAM，常用于静止图片显示。
RGB接口方式: 显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。
主要的区别是: MCU接口方式: 显示数据写入DDRAM，常用于静止图片显示。 RGB接口方式: 显示数据不写入DDRAM，直接写屏，速度快，常用于显示视频或动画用。
MCU模式 因为主要针对单片机的领域在使用,因此得名.后在中低端手机大量使用,其主要特点是价格便宜的。MCU-LCD接口的标准术语是Intel提出的8080总线标准，因此在很多文档中用I80 来指MCU-LCD屏。主要又可以分为8080模式和6800模式，这两者之间主要是时序的区别。数据位传输有8位，9位，16位，18位，24位。连线分为：CS/，RS(寄存器选择)，RD/，WR/，再就是数据线了。优点是：控制简单方便，无需时钟和同步信号。缺点是：要耗费GRAM，所以难以做到大屏(3.8以上)。对于MCU接口的LCM，其内部的芯片就叫LCD驱动器。主要功能是对主机发过的数据/命令，进行变换，变成每个象素的RGB数据，使之在屏上显示出来。这个过程不需要点、行、帧时钟。
MCU接口的LCD的DriverIC都带GRAM，Driver IC作为MCU的一片协处理器，接受MCU发过来的Command/Data，可以相对独立的工作。对于MCU接口的LCM(LCD Module)，其内部的芯片就叫LCD驱动器。主要功能是对主机发过的数据/命令，进行变换，变成每个象素的RGB数据，使之在屏上显示出来。这个过程不需要点、行、帧时钟。
M6800模式 M6800模式支持可选择的总线宽度8/9/16/18-bit(默认为8位)，其实际设计思想是与I80的思想是一样的，主要区别就是该模式的总线控制读写信号组合在一个引脚上(/WR)，而增加了一个锁存信号(E)数据位传输有8位，9位，16位和18位。
I8080模式 I80模式连线分为：CS/，RS(寄存器选择)，RD/，WR/，再就是数据线了。优点是：控制简单方便，无需时钟和同步信号。缺点是：要耗费GRAM，所以难以做到大屏(QVGA以上)。
 MCU接口标准名称是I80，管脚的控制脚有5个： CS 片选信号 RS (置1为写数据,置0为写命令) /WR (为0表示写数据) 数据命令区分信号 /RD (为0表示读数据) RESET 复位LCD( 用固定命令系列 0 1 0来复位)  VSYNC模式 该模式其实就是就是在MCU模式上加了一个VSYNC信号，应用于运动画面更新，这样就与上述两个接口有很大的区别。该模式支持直接进行动画显示的功能，它提供了一个对MCU接口最小的改动，实现动画显示的解决方案。在这种模式下，内部的显示操作与外部VSYNC信号同步。可以实现比内部操作更高的速率的动画显示。但由于其操作方式的不同，该模式对速率有一个限制，那就是对内部SRAM的写速率一定要大于显示读内部SRAM的速率。
RGB模式 大屏采用较多的模式，数据位传输也有6位，16位和18位，24位之分。连线一般有：VSYNC，HSYNC，DOTCLK，CS，RESET，有的也需要RS，剩下就是数据线。它的优缺点正好和MCU模式相反。
MCU-LCD屏它与RGB-LCD屏主要区别在于显存的位置。RGB-LCD的显存是由系统内存充当的，因此其大小只受限于系统内存的大小，这样RGB-LCD可以做出较大尺寸，象现在4.3&quot;只能算入门级，而MID中7&quot;,10&quot;的屏都开始大量使用。而MCU-LCD的设计之初只要考虑单片机的内存较小，因此都是把显存内置在LCD模块内部.然后软件通过专门显示命令来更新显存，因此MCU屏往往不能做得很大。同时显示更新速度也比RGB-LCD慢。显示数据传输模式也有差别。RGB屏只需显存组织好数据。启动显示后，LCD-DMA会自动把显存中的数据通过RGB接口送到LCM。而MCU屏则需要发送画点的命令来修改MCU内部的RAM(即不能直接写MCU屏的RAM)。所以RGB显示速度明显比MCU快，而且播放视频方面，MCU-LCD也比较慢。
对于RGB接口的LCM，主机输出的直接是每个象素的RGB数据，不需要进行变换(GAMMA校正等除外)，对于这种接口，需要在主机部分有个LCD控制器，以产生RGB数据和点、行、帧同步信号。
彩色TFT液晶屏主要有2种接口：TTL接口(RGB颜色接口)， LVDS接口(将RGB颜色打包成差分信号传输)。TTL接口主要用于12.1寸一下的小尺寸TFT屏，LVDS接口主要用于8寸以上的大尺寸TFT屏。TTL接口线多，传输距离短;LVDS接口传输距离长，线的数量少。大屏采用较多的模式，控制脚是VSYNC，HSYNC，VDEN，VCLK， S3C2440最高支持24个数据脚，数据脚是VD[23-0]。
CPU或显卡发出的图像数据是TTL信号(0-5V、0-3.3V、0-2.5V、或0-1.8V)，LCD本身接收的也是TTL信号，由于TTL信号在高速率的长距离传输时性能不佳，抗干扰能力比较差，后来又提出了多种传输模式，比如LVDS、TDMS、GVIF、P&amp;D、DVI和DFP等。他们实际上只是将CPU或显卡发出的TTL信号编码成各种信号以传输，在LCD那边将接收到的信号进行解码得到TTL信号。
但是不管采用何种传输模式，本质的TTL信号是一样的。
注意: TTL/LVDS分别是两种信号的传输模式，TTL是高电平表示1，低电平表示0的模式，LVDS是正负两个对应波形，用两个波形的差值来表示当前是1还是0
SPI模式 采用较少，有3线和4线的，连线为CS/，SLK，SDI，SDO四根线，连线少但是软件控制比较复杂。
MDDI模式(MobileDisplayDigitalInterface) 高通公司于2004年提出的接口MDDI，通过减少连线可提高移动电话的可靠性并降低功耗，这将取代SPI模式而成为移动领域的高速串行接口。 连线主要是host_data,host_strobe,client_data,client_strobe,power,GND几根线。
DSI模式 该模式串行的双向高速命令传输模式，连线有D0P，D0N，D1P，D1N，CLKP，CLKN。
]]></content>
  </entry>
  
  <entry>
    <title>带你走进Linux内核源码中最常见的数据结构之「mutex」</title>
    <url>/post/linux/linux-kernel-source-code-data-structure-mutex.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>kernel</tag>
      <tag>mutex</tag>
    </tags>
    <content type="html"><![CDATA[定义 互斥锁（英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全域变量）进行读写的机制。
该目的通过将代码切片成一个一个的**临界区域（critical section）**达成。临界区域指的是一块对公共资源进行存取的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。
例如：一段代码（甲）正在分步修改一块数据。这时，另一条线程（乙）由于一些原因被唤醒。如果乙此时去读取甲正在修改的数据，而甲碰巧还没有完成整个修改过程，这个时候这块数据的状态就处在极大的不确定状态中，读取到的数据当然也是有问题的。更严重的情况是乙也往这块地方写数据，这样的一来，后果将变得不可收拾。因此，多个线程间共享的数据必须被保护。达到这个目的的方法，就是确保同一时间只有一个临界区域处于运行状态，而其他的临界区域，无论是读是写，都必须被挂起并且不能获得运行机会。
互斥锁实现多线程同步的核心思想是：有线程访问进程空间中的公共资源时，该线程执行“加锁”操作（将资源“锁”起来），阻止其它线程访问。访问完成后，该线程负责完成“解锁”操作，将资源让给其它线程。当有多个线程想访问资源时，谁最先完成“加锁”操作，谁就最先访问资源。
当有多个线程想访问“加锁”状态下的公共资源时，它们只能等待资源“解锁”，所有线程会排成一个等待（阻塞）队列。资源解锁后，操作系统会唤醒等待队列中的所有线程，第一个访问资源的线程会率先将资源“锁”起来，其它线程则继续等待。当有多个线程想访问“加锁”状态下的公共资源时，它们只能等待资源“解锁”，所有线程会排成一个等待（阻塞）队列。资源解锁后，操作系统会唤醒等待队列中的所有线程，第一个访问资源的线程会率先将资源“锁”起来，其它线程则继续等待。
mutex有什么缺点？ 不同于mutex最初的设计与目的，现在的struct mutex是内核中最大的锁之一，比如在x86-64上，它差不多有32bytes的大小，而struct samaphore是24bytes，rw_semaphore为40bytes，更大的数据结构意味着占用更多的CPU缓存和更多的内存占用。
什么时候应该使用mutex？ 除非mutex的严格语义要求不合适或者临界区域阻止锁的共享，否则相较于其他锁原语来说更倾向于使用mutex
mutex与spinlock的区别？ spinlock是让一个尝试获取它的线程在一个循环中等待的锁，线程在等待时会一直查看锁的状态。而mutex是一个可以让多个进程轮流分享相同资源的机制
spinlock通常短时间持有，mutex可以长时间持有
spinlock任务在等待锁释放时不可以睡眠，mutex可以
看到一个非常有意思的解释：
spinlock就像是坐在车后座的熊孩子，一直问“到了吗？到了吗？到了吗？…”
mutex就像一个司机返回的信号，说“我们到了！”
实现 看一下Linux kernel-5.8是如何实现mutex的2 实现
struct mutex { atomic_long_t owner; spinlock_t wait_lock; #ifdef CONFIG_MUTEX_SPIN_ON_OWNER  struct optimistic_spin_queue osq; /* Spinner MCS lock */ #endif  struct list_head wait_list; #ifdef CONFIG_DEBUG_MUTEXES  void *magic; #endif #ifdef CONFIG_DEBUG_LOCK_ALLOC  struct lockdep_map dep_map; #endif }; 可以看到，mutex使用了原子变量owner来追踪锁的状态，owner实际上是指向当前mutex锁拥有者的struct task_struct *指针，所以当锁没有被持有时，owner为NULL。
/* * This is the control structure for tasks blocked on mutex, * which resides on the blocked task&#39;s kernel stack: * 表示等待队列wait_list中进程的结构体 */ struct mutex_waiter { struct list_head list; struct task_struct *task; struct ww_acquire_ctx *ww_ctx; #ifdef CONFIG_DEBUG_MUTEXES  void *magic; #endif }; 上锁 当要获取mutex时，通常有三种路径方式
fastpath: 通过 cmpxchg() 当前任务与所有者来尝试原子性的获取锁。这仅适用于无竞争的情况（cmpxchg() 检查 0UL，因此上面的所有 3 个状态位都必须为 0）。如果锁被争用，它会转到下一个可能的路径。
midpath: 又名乐观旋转（optimistic spinning）—在锁的持有者正在运行并且没有其他具有更高优先级（need_resched）的任务准备运行时，通过旋转来获取锁。理由是如果锁的所有者正在运行，它很可能很快就会释放锁。mutex spinner使用 MCS 锁排队，因此只有一个spinner可以竞争mutex。
MCS 锁（由 Mellor-Crummey 和 Scott 提出）是一个简单的自旋锁，具有公平的理想属性，每个 cpu 都试图获取在本地变量上旋转的锁，排队采用的是链表实现的FIFO。它避免了常见的test-and-set自旋锁实现引起的昂贵的cacheline bouncing。类似MCS的锁是专门为睡眠锁的乐观旋转而量身定制的（毕竟如果只是短暂的自旋比休眠效率要高）。自定义 MCS 锁的一个重要特性是它具有额外的属性，即当spinner需要重新调度时，它们能够直接退出 MCS 自旋锁队列。这有助于避免需要重新调度的 MCS spinner持续在mutex持有者上自旋，而仅需直接进入慢速路径获取MCS锁。
slowpath: 最后的手段，如果仍然无法获得锁，则将任务添加到等待队列并休眠，直到被解锁路径唤醒。在正常情况下它阻塞为 TASK_UNINTERRUPTIBLE。 虽然正式的内核互斥锁是可休眠的锁，但midpath路径 (ii) 使它们更实际地成为混合类型。通过简单地不中断任务并忙于等待几个周期而不是立即休眠，此锁的性能已被视为显着改善了许多工作负载。请注意，此技术也用于 rw 信号量。
具体代码调用链很长…
/*不可中断的获取锁*/ void __sched mutex_lock(struct mutex *lock) { might_sleep(); /*fastpath*/ if (!__mutex_trylock_fast(lock)) /*midpath and slowpath*/ __mutex_lock_slowpath(lock); } __mutex_trylock_fast(lock) -&gt; atomic_long_try_cmpxchg_acquire(&amp;lock-&gt;owner, &amp;zero, curr) -&gt; atomic64_try_cmpxchg_acquire(v, (s64 *)old, new); __mutex_lock_slowpath(lock)-&gt;__mutex_lock(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_) -&gt; __mutex_lock_common(lock, state, subclass, nest_lock, ip, NULL, false) /*可中断的获取锁*/ int mutex_lock_interruptible(struct mutex *lock); 尝试上锁 int __sched mutex_trylock(struct mutex *lock) { bool locked; #ifdef CONFIG_DEBUG_MUTEXES  DEBUG_LOCKS_WARN_ON(lock-&gt;magic != lock); #endif  locked = __mutex_trylock(lock); if (locked) mutex_acquire(&amp;lock-&gt;dep_map, 0, 1, _RET_IP_); return locked; } static inline bool __mutex_trylock(struct mutex *lock) { return !__mutex_trylock_or_owner(lock); } 释放锁 void __sched mutex_unlock(struct mutex *lock) { #ifndef CONFIG_DEBUG_LOCK_ALLOC  if (__mutex_unlock_fast(lock)) return; #endif  __mutex_unlock_slowpath(lock, _RET_IP_); } 跟加锁对称，也有fastpath, midpath, slowpath三条路径。 判断锁状态
bool mutex_is_locked(struct mutex *lock) { return __mutex_owner(lock) != NULL; } 很显而易见，mutex持有者不为NULL即表示锁定状态。
实际案例 实验：
#include &lt;pthread.h&gt;#include &lt;stdio.h&gt; #define LOOP 1000000  int cnt = 0; int cs1 = 0, cs2 = 0; void* task(void* args) { while(1) { if(cnt &gt;= LOOP) { break; } cnt++; if((int)args == 1) cs1 ++; else cs2++; } return NULL; } int main() { pthread_t tid1; pthread_t tid2; /* create the thread */ pthread_create(&amp;tid1, NULL, task, (void*)1); pthread_create(&amp;tid2, NULL, task, (void*)2); /* wait for thread to exit */ pthread_join(tid1, NULL); pthread_join(tid2, NULL); printf(&#34;cnt = %d cs1=%d cs2=%d total=%d\n&#34;, cnt,cs1,cs2,cs1+cs2); return 0; } 输出：
cnt = 1000000 cs1=958560 cs2=1520226 total=2478786 正确结果不应该是1000000吗？为什么会出错呢，我们可以从汇编角度来分析一下。
$&gt; g++ -E test.c -o test.i $&gt; g++ -S test.i -o test.s $&gt; vim test.s .file &#34;test.c&#34; .globl _cnt .bss .align 4 _cnt: .space 4 .text .globl __Z5task1Pv .def __Z5task1Pv; .scl 2; .type 32; .endef __Z5task1Pv: ... 我们可以看到一个简单的cnt++，对应
movl _cnt, %eax addl $1, %eax movl %eax, _cnt CPU先将cnt的值读到寄存器eax中，然后将[eax] + 1，最后将eax的值返回到cnt中，这些操作不是**原子性质(atomic)**的，这就导致cnt被多个线程操作时，+1过程会被打断。
加入mutex保护临界资源
#include &lt;pthread.h&gt;#include &lt;stdio.h&gt; #define LOOP 1000000  pthread_mutex_t mutex; int cnt = 0; int cs1 = 0, cs2 = 0; void* task(void* args) { while(1) { pthread_mutex_lock(&amp;mutex); if(cnt &gt;= LOOP) { pthread_mutex_unlock(&amp;mutex); break; } cnt++; pthread_mutex_unlock(&amp;mutex); if((int)args == 1) cs1 ++; else cs2++; } return NULL; } int main() { pthread_mutex_init(&amp;mutex , NULL); pthread_t tid1; pthread_t tid2; /* create the thread */ pthread_create(&amp;tid1, NULL, task, (void*)1); pthread_create(&amp;tid2, NULL, task, (void*)2); /* wait for thread to exit */ pthread_join(tid1, NULL); pthread_join(tid2, NULL); printf(&#34;cnt = %d cs1=%d cs2=%d total=%d\n&#34;, cnt,cs1,cs2,cs1+cs2); return 0; } 输出：
cnt = 1000000 cs1=517007 cs2=482993 total=1000000 ]]></content>
  </entry>
  
  <entry>
    <title>openssl命令</title>
    <url>/post/linux/openssl.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>openssl</tag>
      <tag>系统管理</tag>
      <tag>系统安全</tag>
    </tags>
    <content type="html"><![CDATA[ 强大的安全套接字层密码库
 OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。在OpenSSL被曝出现严重安全漏洞后，发现多数通过SSL协议加密的网站使用名为OpenSSL的开源软件包。由于这是互联网应用最广泛的安全传输方法，被网银、在线支付、电商网站、门户网站、电子邮件等重要网站广泛使用，所以该漏洞影响范围广大。
OpenSSL有两种运行模式：交互模式和批处理模式。
直接输入openssl回车进入交互模式，输入带命令选项的openssl进入批处理模式。
OpenSSL整个软件包大概可以分成三个主要的功能部分：密码算法库、SSL协议库以及应用程序。OpenSSL的目录结构自然也是围绕这三个功能部分进行规划的。 对称加密算法 OpenSSL一共提供了8种对称加密算法，其中7种是分组加密算法，仅有的一种流加密算法是RC4。这7种分组加密算法分别是AES、DES、Blowfish、CAST、IDEA、RC2、RC5，都支持电子密码本模式（ECB）、加密分组链接模式（CBC）、加密反馈模式（CFB）和输出反馈模式（OFB）四种常用的分组密码加密模式。其中，AES使用的加密反馈模式（CFB）和输出反馈模式（OFB）分组长度是128位，其它算法使用的则是64位。事实上，DES算法里面不仅仅是常用的DES算法，还支持三个密钥和两个密钥3DES算法。 非对称加密算法 OpenSSL一共实现了4种非对称加密算法，包括DH算法、RSA算法、DSA算法和椭圆曲线算法（EC）。DH算法一般用户密钥交换。RSA算法既可以用于密钥交换，也可以用于数字签名，当然，如果你能够忍受其缓慢的速度，那么也可以用于数据加密。DSA算法则一般只用于数字签名。 信息摘要算法 OpenSSL实现了5种信息摘要算法，分别是MD2、MD5、MDC2、SHA（SHA1）和RIPEMD。SHA算法事实上包括了SHA和SHA1两种信息摘要算法，此外，OpenSSL还实现了DSS标准中规定的两种信息摘要算法DSS和DSS1。 密钥和证书管理 密钥和证书管理是PKI的一个重要组成部分，OpenSSL为之提供了丰富的功能，支持多种标准。 首先，OpenSSL实现了ASN.1的证书和密钥相关标准，提供了对证书、公钥、私钥、证书请求以及CRL等数据对象的DER、PEM和BASE64的编解码功能。OpenSSL提供了产生各种公开密钥对和对称密钥的方法、函数和应用程序，同时提供了对公钥和私钥的DER编解码功能。并实现了私钥的PKCS#12和PKCS#8的编解码功能。OpenSSL在标准中提供了对私钥的加密保护功能，使得密钥可以安全地进行存储和分发。 在此基础上，OpenSSL实现了对证书的X.509标准编解码、PKCS#12格式的编解码以及PKCS#7的编解码功能。并提供了一种文本数据库，支持证书的管理功能，包括证书密钥产生、请求产生、证书签发、吊销和验证等功能。 事实上，OpenSSL提供的CA应用程序就是一个小型的证书管理中心（CA），实现了证书签发的整个流程和证书管理的大部分机制。
实例 1、消息摘要算法应用例子 用SHA1算法计算文件file.txt的哈西值，输出到stdout：
# openssl dgst -sha1 file.txt 用SHA1算法计算文件file.txt的哈西值，输出到文件digest.txt：
# openssl sha1 -out digest.txt file.txt 用DSS1(SHA1)算法为文件file.txt签名，输出到文件dsasign.bin。签名的private key必须为DSA算法产生的，保存在文件dsakey.pem中。
# openssl dgst -dss1 -sign dsakey.pem -out dsasign.bin file.txt 用dss1算法验证file.txt的数字签名dsasign.bin，验证的private key为DSA算法产生的文件dsakey.pem。
# openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt 用sha1算法为文件file.txt签名,输出到文件rsasign.bin，签名的private key为RSA算法产生的文件rsaprivate.pem。
# openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt # 用sha1算法验证file.txt的数字签名rsasign.bin，验证的public key为RSA算法生成的rsapublic.pem。 # openssl sha1 -verify rsapublic.pem -signature rsasign.bin file.txt 2、对称加密应用例子 对称加密应用例子，用DES3算法的CBC模式加密文件plaintext.doc，加密结果输出到文件ciphertext.bin。
# openssl enc -des3 -salt -in plaintext.doc -out ciphertext.bin 用DES3算法的OFB模式解密文件ciphertext.bin，提供的口令为trousers，输出到文件plaintext.doc。注意：因为模式不同，该命令不能对以上的文件进行解密。
# openssl enc -des-ede3-ofb -d -in ciphertext.bin -out plaintext.doc -pass pass:trousers 用Blowfish的CFB模式加密plaintext.doc，口令从环境变量PASSWORD中取，输出到文件ciphertext.bin。
# openssl bf-cfb -salt -in plaintext.doc -out ciphertext.bin -pass env:PASSWORD 给文件ciphertext.bin用base64编码，输出到文件base64.txt。
# openssl base64 -in ciphertext.bin -out base64.txt 用RC5算法的CBC模式加密文件plaintext.doc，输出到文件ciphertext.bin，salt、key和初始化向量(iv)在命令行指定。
# openssl rc5 -in plaintext.doc -out ciphertext.bin -S C62CB1D49F158ADC -iv E9EDACA1BD7090C6 -K 89D4B1678D604FAA3DBFFD030A314B29 3、Diffie-Hellman应用例子 使用生成因子2和随机的1024-bit的素数产生D0ffie-Hellman参数，输出保存到文件dhparam.pem
# openssl dhparam -out dhparam.pem -2 1024 从dhparam.pem中读取Diffie-Hell参数，以C代码的形式，输出到stdout。
# openssl dhparam -in dhparam.pem -noout -C 4、DSA应用例子应用例子 生成1024位DSA参数集，并输出到文件dsaparam.pem。
# openssl dsaparam -out dsaparam.pem 1024 使用参数文件dsaparam.pem生成DSA私钥匙，采用3DES加密后输出到文件dsaprivatekey.pem
# openssl gendsa -out dsaprivatekey.pem -des3 dsaparam.pem 使用私钥匙dsaprivatekey.pem生成公钥匙，输出到dsapublickey.pem
# openssl dsa -in dsaprivatekey.pem -pubout -out dsapublickey.pem 从dsaprivatekey.pem中读取私钥匙，解密并输入新口令进行加密，然后写回文件dsaprivatekey.pem
# openssl dsa -in dsaprivatekey.pem -out dsaprivatekey.pem -des3 -passin 5、RSA应用例子 产生1024位RSA私匙，用3DES加密它，口令为trousers，输出到文件rsaprivatekey.pem
# openssl genrsa -out rsaprivatekey.pem -passout pass:trousers -des3 1024 从文件rsaprivatekey.pem读取私匙，用口令trousers解密，生成的公钥匙输出到文件rsapublickey.pem
# openssl rsa -in rsaprivatekey.pem -passin pass:trousers -pubout -out rsapubckey.pem 用公钥匙rsapublickey.pem加密文件plain.txt，输出到文件cipher.txt
# openssl rsautl -encrypt -pubin -inkey rsapublickey.pem -in plain.txt -out cipher.txt 使用私钥匙rsaprivatekey.pem解密密文cipher.txt，输出到文件plain.txt
# openssl rsautl -decrypt -inkey rsaprivatekey.pem -in cipher.txt -out plain.txt 用私钥匙rsaprivatekey.pem给文件plain.txt签名，输出到文件signature.bin
# openssl rsautl -sign -inkey rsaprivatekey.pem -in plain.txt -out signature.bin 用公钥匙rsapublickey.pem验证签名signature.bin，输出到文件plain.txt
# openssl rsautl -verify -pubin -inkey rsapublickey.pem -in signature.bin -out plain 从X.509证书文件cert.pem中获取公钥匙，用3DES加密mail.txt，输出到文件mail.enc
# openssl smime -encrypt -in mail.txt -des3 -out mail.enc cert.pem 从X.509证书文件cert.pem中获取接收人的公钥匙，用私钥匙key.pem解密S/MIME消息mail.enc，结果输出到文件mail.txt
# openssl smime -decrypt -in mail.enc -recip cert.pem -inkey key.pem -out mail.txt cert.pem为X.509证书文件，用私匙key,pem为mail.txt签名，证书被包含在S/MIME消息中，输出到文件mail.sgn
# openssl smime -sign -in mail.txt -signer cert.pem -inkey key.pem -out mail.sgn 验证S/MIME消息mail.sgn，输出到文件mail.txt，签名者的证书应该作为S/MIME消息的一部分包含在mail.sgn中
# openssl smime -verify -in mail.sgn -out mail.txt ]]></content>
  </entry>
  
  <entry>
    <title>syslog命令</title>
    <url>/post/linux/syslog.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>syslog</tag>
      <tag>系统管理</tag>
      <tag>系统安全</tag>
    </tags>
    <content type="html"><![CDATA[ 系统默认的日志守护进程
 syslog是Linux系统默认的日志守护进程。
概述 默认的syslog配置文件是/etc/syslog.conf文件。程序，守护进程和内核提供了访问系统的日志信息。因此，任何希望生成日志信息的程序都可以向 syslog 接口呼叫生成该信息。
几乎所有的网络设备都可以通过syslog协议，将日志信息以用户数据报协议(UDP)方式传送到远端服务器，远端接收日志服务器必须通过syslogd监听UDP 端口514，并根据 syslog.conf配置文件中的配置处理本机，接收访问系统的日志信息，把指定的事件写入特定文件中，供后台数据库管理和响应之用。意味着可以让任何事件都登录到一台或多台服务器上，以备后台数据库用off-line(离线) 方法分析远端设备的事件。
通常，syslog 接受来自系统的各种功能的信息，每个信息都包括重要级。/etc/syslog.conf 文件通知 syslogd 如何根据设备和信息重要级别来报告信息。
使用方法 在/var/log中创建并写入日志信息是由syslog协议处理的，是由守护进程sylogd负责执行。每个标准的进程都可以用syslog记录日志。可以使用logger命令通过syslogd记录日志。
要向syslog文件/var/log/messages中记录日志信息：
logger this is a test log line 输出： tail -n 1 messages Jan 5 10:07:03 localhost root: this is a test log line 如果要记录特定的标记（tag）可以使用：
logger -t TAG this is a test log line 输出： tail -n 1 messages Jan 5 10:37:14 localhost TAG: this is a test log line ]]></content>
  </entry>
  
  <entry>
    <title>如何在Ubuntu Linux下将mp4转成mp3</title>
    <url>/post/linux/how-to-convert-mp4-to-mp3-in-ubuntu-linux.html</url>
    <categories><category>Linux</category>
    </categories>
    <tags>
      <tag>ubuntu</tag>
      <tag>ffmpeg</tag>
      <tag>mp4</tag>
      <tag>mp3</tag>
    </tags>
    <content type="html"><![CDATA[ FFmpeg是一款开源软件，用于生成处理多媒体数据的各类库和程序。FFmpeg可以转码、处理视频和图片（调整视频、图片大小，去噪等）、打包、传输及播放视频。
 本文描述了如何在Ubuntu Linux系统下，通过ffmpeg将mp4文件转成mp3文件。
为什么要将mp4转成mp3 因为这样可以节省空间，一些基本的设备是不支持mp4扩展名的文件，在这个例子里，我们将使用ffmpeg将mp4文件转成mp3文件。
FFmpeg是一个完整的跨平台的解决方案，用来录制，转化以及分流音视频，它包括业界领先的音视频编码库 labavcodec 。
在ubuntu上安装ffmpeg sudo apt-get install ffmpeg libavcodec-extra-53 将mp4转成mp3 基本的命令
ffmpeg -i filename.mp4 filename.mp3 可以用命令`man ffmpeg&rsquo;来查看更多选项
ffmpeg -i filename.mp4 -b:a 192K -vn filename.mp3 一个流的说明符可以匹配一些流，这些选项会适用于所有的流，比如，在-b:a 128k选项中的流说明符可以匹配所有的音频流。
通过脚本 下面这个脚本会将Music目录下的带有.mp4扩展名的文件转成.mp3扩展名的文件。
#!/bin/bash MP4FILE=$(ls ~/Music/ |grep .mp4) for filename in $MP4FILE do name=`echo &#34;$filename&#34; | sed -e &#34;s/.mp4$//g&#34;` ffmpeg -i ~/Music/$filename -b:a 192K -vn ~/Music/$name.mp3 done ]]></content>
  </entry>
  
  <entry>
    <title>风河携手TCS建构5G/Open RAN分布式移动网络基础设施生态系统</title>
    <url>/post/news/windriver-and-TCS-build-5G-Open-Ran-ecos.html</url>
    <categories><category>News</category>
    </categories>
    <tags>
      <tag>WindRiver</tag>
      <tag>vRan</tag>
      <tag>TCS</tag>
      <tag>5G</tag>
    </tags>
    <content type="html"><![CDATA[ 全球领先的关键任务智能系统软件提供商风河公司®宣布，正在与塔塔咨询服务公司（TCS）合作，在Wind River Studio上托管vRAN解决方案。这项战略合作将创建一个全栈移动基础设施解决方案，在4G-5G vRAN下一代网络中开展TCS部署和工程服务，并以Studio作为云平台。
 TCS网络解决方案与服务副总裁Vimal Kumar表示：“我们很高兴与风河合作，帮助我们的客户借助5G技术改善他们的业务。我们的Cognitive Network Operations平台运行在Wind River Studio之上，由此帮助电信网络运营商运用AI和ML技术来监测网络健康状况，预测可能发生的故障，提供以客户为中心的网络体验，并确保卓越的服务质量。”
风河公司首席产品官Avijit Sinha表示：“运营商正在致力于创造数字化、云原生的未来，他们正在寻求灵活、经济的解决方案，以便降低部署复杂度并进行持续性维护。风河公司提供了成熟的生产就绪产品，与领先运营商实现了实用化部署，其基础正是经过广泛验证的Wind River Studio技术。”
风河公司印度销售主管Rajeev Rawal表示：“与TCS携手，提供敏捷、安全、可靠和超低延迟解决方案，以支持新的应用场景，让云计算、边缘计算和智能化技术承担起更加重要的任务。”
作为5G市场的领导者，风河在世界首次成功5G数据会话和商业vRAN/O-RAN项目中发挥了关键作用，其中包括世界上最大的Open RAN网络。
Wind River Studio提供了一个完全基于云原生、Kubernetes和容器的体系结构，可用于大规模分布式边缘网络的开发、部署、运营和服务。这套平台为地理分布的管理解决方案提供了基础，能够为数千个节点提供单一窗口（SPoG）、零接触的自动化管理，从而简化Day 1和Day 2运营，而且与节点的物理位置无关。Studio解决了部署和管理物理地理分散云原生vRAN基础设施的复杂挑战，在vRAN部署中提供了传统的RAN性能。
 塔塔咨询服务 (TCS）简介
 塔塔咨询服务公司是一家IT服务、咨询和业务解决方案提供商，50多年来一直与许多全球最大企业合作，帮助他们实现转型。TCS提供以咨询为主导、以认知为动力的综合性商业、技术和工程服务以及解决方案。所有这些都通过独特的Location Independent Agile™ 模式来提供，被作为卓越软件开发的基准指标。
作为印度最大的跨国商业集团塔塔集团的一部分，TCS在55个国家拥有超过606,000名训练有素的咨询师。在截至2022年3月31日的财年中，TCS创造了257亿美元的合并营收，并在印度的BSE和NSE上市。
]]></content>
  </entry>
  
  <entry>
    <title>VxWorks 6.8下基于QT的串口编程</title>
    <url>/post/vxworks/vxworks-6.8-qt-uart-programming.html</url>
    <categories><category>VxWorks</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>VxWorks 6.8</tag>
      <tag>UART</tag>
      <tag>QT</tag>
      <tag>串口</tag>
      <tag>编程</tag>
    </tags>
    <content type="html"><![CDATA[文章简要记录了VxWorks 6.8下基于Qt实现的串口编程。
相关的VxWorks 和 串口，请参阅 VxWorks下的串口测试程序设计和源码  。
VxWorks简介 VxWorks 操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），是嵌入式开发环境的关键组成部分。良好的持续发展能力、高性能的内核以及友好的用户开发环境，在嵌入式实时操作系统领域占据一席之地。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的 F-16、FA-18战斗机、B-2 隐形轰炸机和爱国者导弹上，甚至连1997年4月在火星表面登陆的火星探测器、2008年5月登陆的凤凰号，和2012年8月登陆的好奇号也都使用到了VxWorks。
串口简介 串行接口(Serial Interface) 简称串口，也称串行通信接口或串行通讯接口（通常指COM接口），是采用串行通信方式的扩展接口，指数据一位一位地顺序传送。
串行接口的特点是通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。常见的有一般计算机应用的RS-232（使用 25 针或 9 针连接器）和工业计算机应用的半双工RS-485与全双工RS-422。
我这里使用了232和422传输方式，在我本人理解这两种方式根据需求硬件已经做好的传输方式（也可以在BIOS设置），我们知道是什么传输方式，做到心中有数和如何搭建测试环境，今天在这里教大家个简单的232-9针连接器的接线方式，一般没接触过的拿过来一脸懵逼，好家伙9跟针都不知道是干嘛的，那么我告诉你如果是 232-9针，什么也别管直接找到第2针和第3针用杜邦线回连，这时你就具备环境自己检测板卡串口模块是否好用，如果测试程序一定记得把第5跟针要连接上，否则会出现数据不精准的情况（文章底部有贴图）。
在软件层面上只需要关注数据位、停止位、奇偶效验、读取方式和效率即可；
232串口接线说明 RS232串口接线方法：直连和交叉接法
一般情况下，设备和电脑的连接通讯，需用到RS232串口线直连线；而设备和设备的连接通讯，就会用到RS232串口线的交叉线。用户在选择的时候，应根据两个设备之间连接的实际情况，选择不同接法的RS232串口线。
代码实例 VxWorks串口所需要包含的头文件 #include &#34;vxWorks.h&#34;#include &#34;stdIo.h&#34;#include &#34;ioLib.h&#34;#include &#34;sysLib.h&#34;#include &#34;string.h&#34;#include &#34;taskLib.h&#34;VxWorks串口配置函数 ioctl(m_SeriPort,SIO_HW_OPTS_SET, CLOCAL | CS8 | PARODD | PARENB);	//8位数据位|1位停止位|偶效验 ioctl(m_SeriPort,FIOBAUDRATE,9600);	//波特率9600 ioctl(m_SeriPort,FIOSETOPTIONS,OPT_RAW);	//设置串口raw模式 ioctl(m_SeriPort,FIOFLUSH,0);	//清空输入输出的缓冲区 open函数 #define SERI_NAME &#34;/tyCo/0&#34; int m_SeriPort = open(SERI_NAME ,O_RDWR,0); int m_SeriPort = open(SERI_NAME ,O_WRONLY,0); write函数 char* sendData; int writeCom = write(m_SeriPort, sendData,strlen(sendData)); read函数 char data; int readCom = read(m_SeriPort,&amp;data,1); Seri_Demo_Qt_Vx #ifndef THREAD_H #define THREAD_H #include &lt;QThread&gt;#include &lt;QDebug&gt;#include &#34;vxWorks.h&#34;#include &#34;stdIo.h&#34;#include &#34;ioLib.h&#34;#include &#34;sysLib.h&#34;#include &#34;string.h&#34;#include &#34;taskLib.h&#34;class Thread : public QThread { Q_OBJECT public: explicit Thread(QObject *parent = 0); ~Thread(); void run(); //重写run函数 public: bool openSeri(QString comPort,int baudRate); //打开串口  void closeSeri(); //关闭串口  void writeSeri(char* sendData); //发送数据  void setFlag(bool flag = true); //线程数据标志位 signals: void RecvData(char data); private: bool seriStop; //读取数据标志位 true读取数据 false退出循环  int m_SeriPort; //串口文件描述符  QString m_SeriName; //串口名  int m_baud; //波特率 }; #endif //THREAD_H #include &#34;thread.h&#34; Thread::Thread(QObject *parent) : QThread(parent) { } Thread::~Thread() { } void Thread::run() { sysClkRateSet(1000); char rData; while(1) { int readCom = read(m_SeriPort,&amp;rData,1); if(readCom &gt; 0) { printf(&#34;%c\n&#34;,rData); emit RecvData(rData); if(seriStop == false) { qDebug()&lt;&lt; &#34;isStop == false break&#34;; break; } } else { taskDelay(10); } } } bool Thread::openSeri(QString comPort, int baudRate) { this-&gt;m_SeriName = comPort; this-&gt;m_baud = baudRate; qDebug()&lt;&lt; &#34;Thread::openSeri&#34; &lt;&lt; comPort.toUtf8().data() &lt;&lt; baudRate; m_SeriPort = open(comPort.toUtf8().data(),O_RDWR,0); if(m_SeriPort == ERROR) { qDebug()&lt;&lt; &#34;open :&#34; &lt;&lt; comPort.toUtf8().data() &lt;&lt; &#34; = &#34; &lt;&lt;m_SeriPort &lt;&lt; &#34;failed !&#34;; return false; } ioctl(m_SeriPort,SIO_HW_OPTS_SET, CLOCAL | CS8 | PARODD | PARENB); ioctl(m_SeriPort,FIOBAUDRATE,baudRate); ioctl(m_SeriPort,FIOSETOPTIONS,OPT_RAW); ioctl(m_SeriPort,FIOFLUSH,0); qDebug()&lt;&lt; &#34;open :&#34; &lt;&lt; comPort.toUtf8().data() &lt;&lt; &#34; = &#34; &lt;&lt; m_SeriPort &lt;&lt; &#34;succeeded !&#34;; return true; } void Thread::closeSeri() { if(seriStop == false) { qDebug()&lt;&lt; &#34;Thread::closeSeri&#34;; close(m_SeriPort); } } void Thread::writeSeri(char* sendData) { if(m_SeriPort == ERROR) { openSeri(m_SeriName,m_baud); } int writeCom = write(m_SeriPort, sendData,strlen(sendData)); qDebug()&lt;&lt; sendData &lt;&lt; writeCom; } void Thread::setFlag(bool flag) { this-&gt;seriStop = flag; qDebug()&lt;&lt; &#34;Thread::setFlag&#34; &lt;&lt; flag; } TestSeri_Demo_Qt_Vx_Demo #ifndef SERI_H #define SERI_H  #include &lt;QObject&gt;#include &lt;QDebug&gt;#include &#34;thread.h&#34; class Seri : public QObject { Q_OBJECT public: explicit Seri(QObject *parent = 0); ~Seri(); public: /*	open_Seri	打开串口 * comName	串口名 * comBaud	串口波特率 *	return 成功 true 失败 false */ bool open_Seri(QString comName,int comBaud); /* write_Seri	发送数据 * comData	发送数据内容 */ void write_Seri(QByteArray comData); /*	* close_Seri	关闭串口 */ void close_Seri(); signals: send_Seri(char data); private: Thread* m_pThread; }; #endif // SERI_H #include &#34;Seri.h&#34; Seri::Seri(QObject *parent) : QObject(parent) { m_pThread = new Thread; } Seri::~Seri() { if(m_pThread){ delete m_pThread; m_pThread=NULL; } } bool Seri::open_Seri(QString comName,int comBaud) { if(m_pThread-&gt;openSeri(comName,comBaud))//如果打开成功 	{ m_pThread-&gt;setFlag(true); m_pThread-&gt;start(); } return false; } void Seri::write_Seri(QByteArray comData) { m_pThread-&gt;writeSeri(comData.data()); } void Seri::close_Seri() { if(m_pThread-&gt;isRunning())//如果线程还在运行 --&gt; 退出循环接收数据 --&gt; 关闭串口 --&gt; 退出线程 --&gt; 回收线程 	{ m_pThread-&gt;setFlag(false); m_pThread-&gt;closeSeri(); m_pThread-&gt;quit(); m_pThread-&gt;wait(); } } 程序代码说明：  thread类为配置串口类 seri类为外部使用类 接收到的数据是利用信号槽为接口把数据传输出去 ]]></content>
  </entry>
  
  <entry>
    <title>VxWorks操作系统下的串口读写程序</title>
    <url>/post/vxworks/vxworks-uart-read-write-programming.html</url>
    <categories><category>VxWorks</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>UART</tag>
      <tag>串口</tag>
      <tag>编程</tag>
    </tags>
    <content type="html"><![CDATA[关于传统的串口编程，在各大操作系统下的流程基本是一致的，只是针对不同的操作系统，函数接口可能有所差异而已，下面讲述VxWorks操作系统下对于串口读写的编程步骤和代码
相关的VxWorks 和 串口，请参阅 VxWorks下的串口测试程序设计和源码  。
串口配置过程 打开串口 fd = open(&#34;/tyCo/0&#34;, O_RDWR, 0);  &ldquo;/tyCo/0&rdquo;: 串口1的设备名 O_RDWR: 按照读写方式打开串口  设置串口raw模式，清空输入输出的缓冲区 在VxWorks中配置串口可以直接通过ioctl的控制命令来实现
ioctl(fd,FIOSETOPTIONS,OPT_RAW); ioctl(fd,FIOFLUSH,0); ioctl(int fd,int function,int arg); function的参数如下：
   参数 说明     FIOBAUDRATE 设置波特率，arg为一整数，表示要设定的波特率   FIOGETOPTIONS 取得设备控制字，arg表示读出的内容存放的位置   FIOSETOPTIONS 设置设备控制字，arg表示要设置的选项   FIOGETNAME 取得文件描述符对应的文件名，arg存放文件名的缓冲区   FIOREAD 取得输入缓冲区内未读取的字符数，arg用于接收结果的整型指针   FIOWRITE 取得输出缓冲区内的字符个数，arg用于接收结果的整型指针   FIOFLUSH 清空输入输出缓冲区的字符   FIOCANCEL 取消读和写    设置波特率，数据位，停止位，校验方式 在 VxWorks 中设置串口也是用 &lsquo;ioctl&rsquo; 系统调用加控制命令实现，其控制命令为&rsquo;SIO_HW_OPTS_SET'，第三个参数跟配置参数，如：数据位为8，停止位为1，无奇偶校验位，无流控可以这样配置
ioctl(fd,SIO_HW_OPTS_SET,CS8|PARENB|CLOCAL|CREAD); 具体各项参数意义如下：
   参数 说明     CLOCAL 忽略modem控制信号   CREAD 启动接收器   CSIZE 指定数据位：CS5~CS8   HUPCL 最后关闭时挂断modem连接   STOP8 被设置时指定2位停止位，否则默认为1位停止位   PARENB 被设置时启用奇偶校验，否则默认为无奇偶校验   PARODD 被设置时启用奇校验，否则默认为偶校验(PARENB设置时才有效)    串口读写操作 在VxWorks系统中串口的读写操作非常简单，直接使用系统调用函数 read() 和 write() 就能实现串口的读写操作。
int read(int fd, char *buffer, size_t maxbytes) 参数说明：
 fd: 用open函数打开串口设备返回的文件描述符 buffer: 读取的内容将要存放的地址，为指针变量 maxbytes: 读取的最大字节数  int write(int fd, char *buffer, size_t nbytes) 参数说明：
 fd: 用open函数打开串口设备返回的文件描述符 buffer: 将要写的内容的地址，为指针变量，通常为字符串首地址 nbytes: 将要写入的字节数，通常为要写入的字符串的长度  实例代码 VxWorks系统下串口读写的实例代码，仅供参考。
#include &#34;vxWorks.h&#34;#include &#34;stdio.h&#34;#include &#34;ioLib.h&#34;#include &#34;taskLib.h&#34;#include &#34;sioLib.h&#34;#include &#34;sdLib.h&#34;#include &#34;semLib.h&#34;#include &#34;msgQLib.h&#34; char wbuf[] = &#34;hello&#34;; #define DEV_NAME &#34;/tyCo/2&#34; #define MAX_BUF_SIZE 20 #define SD_COMMDATA_NAME &#34;share_data&#34; #define SD_COMMDATA_MUTEX &#34;share_sem&#34; #define SHARE_DATA_LENGTH 20  typedef struct unix_clock_struct { UINT32 sec; /* ms */ UINT32 msec; /* s */ UINT8 quality; /* 时标质量 */ } UNIX_CLOCK_STRUCT; char *comdata; int set_serial(int fd); SEM_ID mutexComdata; void taskUart(void); int main(void) { int ret; int sdCommId; char r_buff[MAX_BUF_SIZE]; mutexComdata = semOpen(SD_COMMDATA_MUTEX, SEM_TYPE_MUTEX, SEM_FULL, SEM_Q_PRIORITY | SEM_DELETE_SAFE | \ SEM_INVERSION_SAFE, OM_CREATE | OM_DELETE_ON_LAST_CLOSE, NULL); if(mutexComdata == NULL) { /*致命错误，无法创建互斥锁*/ printf(&#34;ERROR TO OPEN SD_COMMDATA_MUTEX\n&#34;); taskExit(0); } /* 申请公共数据共享内存 */ sdCommId = sdOpen(SD_COMMDATA_NAME, SD_LINGER, OM_CREATE, SHARE_DATA_LENGTH, 0, SD_ATTR_RW|SD_CACHE_OFF, &amp;comdata); if(sdCommId == NULL) { /*致命错误，无法分配公共数据内存，报错退出*/ printf(&#34;ERROR TO OPEN SD_COMMDATA\n&#34;); taskExit(0); } if((ret = taskSpawn(&#34;taskUart&#34;,90,0x100, 20000, (FUNCPTR)taskUart,\ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)) &lt; 0) { printf(&#34;taskSpawn failed:ret = %s\n&#34;); } return 0; } void taskUart(void) { int ret; int fd = -1; UNIX_CLOCK_STRUCT w_buff; if((fd = open(DEV_NAME, O_RDWR,0)) &lt; 0) { printf(&#34;open %s failed.\n&#34;,DEV_NAME); } /*配置串口参数*/ if((ret = set_serial(fd)) &lt; 0) { printf(&#34;ret = %d\nset_serial failed.\n&#34;); } while(1) { semRTake(mutexComdata,WAIT_FOREVER); #if 0/*清空输入输出缓冲*/ if((ret = ioctl(fd, FIOFLUSH, 0))&lt;0) { printf(&#34; ret = %d\nset FIOFLUSH failed.\n&#34;,ret); } memset(r_buff,0,sizeof(r_buff)); /*读取串口中的值*/ if((ret = read(fd,r_buff,sizeof(r_buff)))&lt;0) { printf(&#34;ret = %d:read %s failed.\n&#34;,ret,DEV_NAME); } else printf(&#34;Received:%s\n&#34;,r_buff); #endif  #if 1  /*清空输入输出缓冲*/ if((ret = ioctl(fd, FIOFLUSH, 0))&lt;0) { printf(&#34; ret = %d\nset FIOFLUSH failed.\n&#34;,ret); } if(NULL == bzero(&amp;w_buff,sizeof(w_buff))) { printf(&#34;memset failed.\n&#34;); } if(NULL == memcpy(&amp;w_buff,comdata,sizeof(w_buff))) { printf(&#34;memset failed.\n&#34;); } if(&amp;w_buff != NULL) { /*往串口中写值*/ if((ret = write(fd, &amp;w_buff.sec, sizeof(ret)))&lt;0) // if((ret = write(fd, wbuf, sizeof(wbuf)))&lt;0)  { printf(&#34;ret = %d:write %s failed.\n&#34;,ret,DEV_NAME); } else { printf(&#34;write success:%d\n&#34;,w_buff.sec); } } semGive(mutexComdata); #endif  taskDelay(sysClkRateGet()*2); } } int set_serial(int fd) { int error = -1; int ok = 0; int ret; if(fd&lt;0) { printf(&#34;error:fd is %d\n&#34;,fd); } /*设定波特率为9600*/ if((ret = ioctl(fd, FIOBAUDRATE, 9600))&lt;0) { printf(&#34;ret = %d\nset baudrate failed\n&#34;,ret); return error; } /*设定：数据位为8，无奇偶校验，1位停止位*/ /*CLOCAL:忽略modem控制信号 * CREAD：启动接收器 * CS8:设定数据位为8*/ if((ret = ioctl(fd, SIO_HW_OPTS_SET,CREAD|CS8 |CLOCAL))&lt;0) { printf(&#34;ret = %d\nset SIO_HW_OPTS_SET failed.\n&#34;); return error; } return ok; } ]]></content>
  </entry>
  
  <entry>
    <title>针对VxWorks的QT 5.15.10发布了</title>
    <url>/post/vxworks/qt-5-15-10-for-vxworks-released.html</url>
    <categories><category>VxWorks</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>QT</tag>
      <tag>图像</tag>
    </tags>
    <content type="html"><![CDATA[Qt是一个多平台的C++图形用户界面应用程序框架。它提供给应用程序开发者建立艺术级的图形用户界面所需的所用功能。Qt是完全面向对象的编程，所以具有易扩展和组件编程的优势。
相关的VxWorks 和 QT的文章，请参阅 VxWorks 6.8操作系统下QT的安装设置和运行方法  。
我们非常激动地发布了支持VxWorks的QT 5.15.10 支持VxWorks的Qt 5.15.10长期支持的商业发行是基于我们最新的QT 5.15.10(LTS)之上的源代码发布。这个发行从早期的QT 5的版本官方升级了针对VxWorks的QT支持，这是对诸如航空和国防以及医疗等行业的市场需求的积极回应。它提供了QT版本的升级同时也提供了VxWorks系统具体的问题解决，还有别的一些改进。
这次发行支持基于iMX6硬件的Ubuntu主机，我们也同时在准备基于x68和基于Windows主机的支持。此次的发行包开放给拥有QT账户的客户，也同时通过git仓库的形式开放给具有商业许可证的客户，请和我们联系以获取更多细节。
从这儿开始 这儿有关于安装和配置的独立的文章，要获取更多关于QT和支持VxWorks的QT的详细信息，请查看这儿关于QT 5.15的在线文档。
   https://doc.qt.io/qt-5/vxworks.html  
   https://doc.qt.io/qt-5/index.html  
   https://wiki.qt.io/Getting_Commercial_Qt_Sources  
 ]]></content>
  </entry>
  
  <entry>
    <title>北南南北</title>
    <url>/about.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[北南南北 是众多使用 VxWorks 嵌入式实时操作系统的网友分享经验的平台，为的就是让 VxWorks 的学习和应用变得相对开放一些，在此也欢迎你的加入！
我们的愿景 技术创新是技术持续发展的生命力，紧跟技术的发展趋势，研究最新的技术，保持对新技术的热情和好奇心，让技术为生产和生活服务。
使用反馈  加入 VxWorks Club   或 Google AI TPU     欢迎你的加入
 ]]></content>
  </entry>
  
  <entry>
    <title>VxWorks实时性能探究</title>
    <url>/post/vxworks/vxworks-real-time-feature-explore.html</url>
    <categories><category>VxWorks</category>
    </categories>
    <tags>
      <tag>VxWorks</tag>
      <tag>实时性</tag>
    </tags>
    <content type="html"><![CDATA[ VxWorks操作系统是一款硬实时操作系统，一直听闻其实时性能非常优秀，但是一直没有一个直观地概念。
 笔者最近在使用 VxWorks  , 由大名鼎鼎的风河（WindRiver）开发。本篇文章就是将VxWorks操作系统和市面上几种其他实时操作系统的实时性能进行对比。
前期知识准备 实时性能和响应时间有关，为此，先对计算机操作系统中的时间概念和时间尺度进行一下介绍。
1 s = 1000 ms = 1000000 us = 1000000000 ns，看不出来1 s时间还是很长的嘛
  时钟周期：主频为4 GHz的CPU的时钟周期为1/4G = 0.25 ns，时钟周期是计算机中最基本的、最小的[时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。
  CPU周期：CPU周期亦称机器周期，一条指令执行过程被划分为若干阶段，每一阶段完成所需时间。完成一个基本操作所需要的时间称为机器周期。通常用内存中读取一个指令字的最短时间来规定CPU周期。
  指令周期：取出并执行一条指令的时间。想要详细了解可以看这篇文章【浅析】CPU中的指令周期、CPU周期和时钟周期
  内存时钟周期：相比CPU，一般的DDR内存芯片速率仅为400 MHz，时钟周期达2.5 ns, 再加上总线延时，导致内存访问时间达到几十纳秒。CPU运行速率与内存访问速率比大致为100：1。
  硬盘读取时间：硬盘的读写速度就更慢了，一般的机械硬盘的完成一次读写所需要的时间，主要取决寻道时间+旋转时间，完成一次读或者写的时间量级大致为ms级别，因此内存访问速率与磁盘存取速度比大致为1000:1。
  上面是有关硬件方面的时间周期情况，对于操作系统或者应用程序来说，我们一般关注的是算法的时间复杂度和空间复杂度，这是从整理理想的情况来衡量一个算法的优劣。如果想要详细了解每条代码的执行所耗时间，我们需要更深入了解代码是怎么在计算机上执行的。
C语言代码都是经过预处理、编译，产生汇编代码（汇编代码几乎已经接近机器码了），一句高级语言代码相当于汇编语言的几行甚至几十行。而学过汇编语言的都应该知道，不同的汇编代码指令执行所耗费的时间也是不同的。一般来说,移位,加法,取反这种指令只需要一个时钟周期,而乘法,除法等指令需要几个乃至几十个时钟周期执行。
实时操作系统（RTOS）的实时性能评价指标 实时操作系统的实时性能评价指标一般有两个：
 任务切换时间  当多任务应用程序运行在操作系统上时，它把正在运行的任务的状态保存到任务自己的栈区之中，然后把下一个将要运行的任务的当前状态从该任务的栈区装入CPU的寄存器，并开始这个任务的执行，这个过程就叫做任务切换。
 中断响应时间  计算机接收到中断信号到操作系统做出响应，并完成切换转入中断服务程序的时间。
下图是几种实时操作系统的实时性能对比：
可以看出不管是任务切换时间还是中断响应，VxWorks都是最好的，当然VxWorks也是最贵的。
此外我们还可以看出不管是任务切换还是中断响应，时间尺度都是在几个us，根据CPU主频的不同，大概是几千个时钟周期的样子。 下面代码是测试执行100万次简单循环语句所耗费的时间:
int i = 1000000; int j = 0; while(i){ j += 0; i--; } timer = 2033 us //执行100万次该循环所耗时间，可以将执行每次的时间和任务切换的时间进行对比 ]]></content>
  </entry>
  
  <entry>
    <title>风河公司的资本交易历史</title>
    <url>/post/vxworks/windriver-capital-transaction.html</url>
    <categories><category>VxWorks</category>
    </categories>
    <tags>
      <tag>WindRiver</tag>
    </tags>
    <content type="html"><![CDATA[日前，安波福宣布同意以43亿美元现金从私募股权公司TPG Capital收购风河公司（ Wind River  ），以帮助其在多个行业的关键软件领域建立独特地位，继续其智能转型，向边缘支持、软件定义的未来迈进。
该交易预计将于2022年年中完成，在被收购之后，风河将隶属于安波福主动安全与用户体验事业部，继续在公司总裁兼首席执行官Kevin Dallas的领导下作为独立业务单位运营。
实时操作系统 作为实时操作系统领域，全球最优秀的选手，它值得我们所有的溢美之词，无论怎么夸它，都不过分。
VxWorks是风河公司推出的实时多任务操作系统（RTOS）。过去40年间，风河和VxWorks在嵌入式OS领域一直处于领先地位，在航空航天、通信、工业控制等行业有着广泛的应用，在业内被称为嵌入式OS的常青树。
风河公司目前有2个嵌入式OS平台：Linux和VxWorks。
VxWorks是由支持多核、32/64位嵌入式处理器、内存包含和内存管理的VxWorks 6.x和VxWorks5.x，Workbench开发工具（包括多种C/C++编译器和调试器），连接组件（USB、IPv4/v6、多种文件系统等），先进的网络协议和图像多媒体等模块组成。除了通用平台外，VxWorks还包括支持工业、网络、医疗和消费电子等的特定平台产品。
老当益壮 风河成立于1981年，2021年收入大约4亿美元，毛利率超过80%。
1987年风河基于VRTX推出VxWorks，1993年IPO上市，1995年VxWorks在NASA Clementine月球探测器上，被发射入太空。
1997年NASA火星探险者号飞船的实时操作系统，登陆火星。
风河是全球第一大嵌入式RTOS厂家，也是全球第一大嵌入式Linux厂家，硬实时操作系统长达30年的霸主，市场占有率超30%。
它的主要收入来自4个领域：
 宇航与国防 工业与医疗 电信 汽车  宇航与国防所占比例最高，接近50%，各种飞船或者说航天飞行器基本都是风河VxWorks的市场，SpaceX也是它的忠实用户，中国神舟系列的SpaceOS也有借鉴VxWorks653。
除了航天飞行器，AH-64阿帕奇武装直升机、F-16V（全球空军主力机型）、F-18大黄蜂，B-2战略轰炸机，X-47A，波音787都是VxWorks。
美国的F-22猛禽、F-35、B-52轰炸机、B-1B轰炸机、C-17运输机和F-16改进型，以及欧洲的A-400M运输机，X-47B无人机，还有民航空客的A380，爱国者防空导弹，都是Vxworks的忠实用户。
把竞争对手买下来，然后干掉！
1999年风河收购一个主要竞争对手，pSOS的发明者，一家集成系统公司。从那以后风河公司不再支持pSOS产品线，并推荐现存的pSOS客户转向VxWorks。
2004年针对网络和通信市场，推出便携的Linux平台，正式进军嵌入式Linux市场。
VxWorks通过了汽车领域最高的ASIL-D级认证，以及远超汽车标准的DO-178C A级认证，它也通过了，已经准备好了对汽车行业进行降维打击。  卖来卖去 2009年英特尔以8.84亿美元收购风河；
2018年4月英特尔出售风河给投资公司TPG。
英特尔刚刚收购4年不到，就卖给了TPG，英特尔也是颇具渣男属性了。
不过，风河公司貌似还不是最后一个被卖来卖去的此类企业，另外一个汽车级嵌入式系统的大牛供应商，Green Hills也在被卖的路上了，我们接下来的文章会保持对它的追踪，及时报道相关信息。
戳穿实时操作系统 在日常的HIL测试工作中，几乎没有哪个测试任务是因为“实时仿真机的实时性不够高”而导致出问题。
HIL工作最容易出问题的地方，往往是功能定义不明确、工具链不完整、协同自动化测试做不起来、线束掉链子以及项目上各种瞎搞等等。
换句话说，在汽车HIL测试领域，哪怕是最low逼的实时操作系统，也足够了，人家Vector公司用wince做实时机，照样玩得飞起，不耽误事。
HIL实时机诞生的历史环境，已经不复存在了，当年的PC机真是太鸡肋了。
而且，在近些年大火的自动驾驶测试领域，我见过太多实时性差得一批的测试系统，响应滞后得跟PID调节似的，却闭口不谈实时性问题，忽忽悠悠就验收通过了……
资本市场 通过这些收购案例，我们也能看到资本唯利是图的本性，什么来钱快干什么，脑子一热就买了，兴奋劲儿过了之后又卖了，不符合自己的产品路线，也照样卖掉。
]]></content>
  </entry>
  
  <entry>
    <title>Mermaid支持流程图</title>
    <url>/post/mermaid-charts.html</url>
    <categories><category>示例</category>
    </categories>
    <tags>
      <tag>流程图</tag>
      <tag>时序图</tag>
    </tags>
    <content type="html"><![CDATA[本主题已支持 Mermaid 实现以纯文本的方式绘制流程图、序列图、甘特图、状态图、关系图行等等，随着 Mermaid 也在逐步发展，后续还会有各种各样的图被引入进来，更多的类型及使用方式可关注其官方网站： https://mermaid-js.github.io/  。
使用说明  通过 hugo new 命令创建一篇新的文章 在文章头部配置 mermaid: true 使用短代码书写各种类型的图，自带2个参数： align（对齐） 和 bc（背景色），可参考如下使用示例   流程图 {{&lt; mermaid align=&#34;left&#34; &gt;}} graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; {{&lt; /mermaid &gt;}} graph TD; A--B; A--C; B--D; C--D;  时序图 {{&lt; mermaid bc=&#34;#eee&#34; &gt;}} sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! {{&lt; /mermaid &gt;}} sequenceDiagram participant Alice participant Bob Alice-John: Hello John, how are you? loop Healthcheck John-John: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--Alice: Great! John-Bob: How about you? Bob--John: Jolly good!  类图 {{&lt; mermaid &gt;}} classDiagram Class01 &lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --&gt; C2 : Where am i? Class09 --* C3 Class09 --|&gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 &lt;--&gt; C2: Cool label {{&lt; /mermaid &gt;}} classDiagram Class01 C2 : Where am i? Class09 --* C3 Class09 --| Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08  C2: Cool label  甘特图 {{&lt; mermaid &gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d {{&lt; /mermaid &gt;}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d  实体关系图 {{&lt; mermaid &gt;}} erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses {{&lt; /mermaid &gt;}} erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses  用户旅程 {{&lt; mermaid &gt;}} journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me {{&lt; /mermaid &gt;}} journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ]]></content>
  </entry>
  
  <entry>
    <title>数学公式渲染</title>
    <url>/post/math-formula.html</url>
    <categories><category>示例</category>
    </categories>
    <tags>
      <tag>数学公式</tag>
      <tag>mathjax</tag>
      <tag>katex</tag>
    </tags>
    <content type="html"><![CDATA[本主题支持 mathjax 和 katex 两种不的方案支持数学公式的渲染，可根据自已的需求进行选择。
接下的示例中，将使用 MathJax   方案来展示渲染效果。
 使用 hugo new 命令创建一篇新的文章 可以全局启用数据公式渲染，请在项目配置参数 math: katex 或 math: mathjax 或是将该参数配置到需要显示数学公式的页面头部（减少不必要的加载消耗）   注意： 使用 支持的TeX功能  的联机参考资料。
例子 重复的分数 $$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} \equiv 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\cdots} } } } $$
总和记号 $$ \left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right) $$
几何级数之和 我把接下来的两个例子分成了几行，这样它在手机上表现得更好。这就是为什么它们包含 \displaystyle。
$$ \displaystyle\sum_{i=1}^{k+1}i $$
$$ \displaystyle= \left(\sum_{i=1}^{k}i\right) +(k+1) $$
$$ \displaystyle= \frac{k(k+1)}{2}+k+1 $$
$$ \displaystyle= \frac{k(k+1)+2(k+1)}{2} $$
$$ \displaystyle= \frac{(k+1)(k+2)}{2} $$
$$ \displaystyle= \frac{(k+1)((k+1)+1)}{2} $$
乘记号 $$ \displaystyle 1 + \frac{q^2}{(1-q)}+\frac{q^6}{(1-q)(1-q^2)}+\cdots = \displaystyle \prod_{j=0}^{\infty}\frac{1}{(1-q^{5j+2})(1-q^{5j+3})}, \displaystyle\text{ for }\lvert q\rvert &lt; 1. $$
随文数式 这是一些线性数学: $$ k_{n+1} = n^2 + k_n^2 - k_{n-1} $$ ， 然后是更多的文本。
希腊字母 $$ \Gamma\ \Delta\ \Theta\ \Lambda\ \Xi\ \Pi\ \Sigma\ \Upsilon\ \Phi\ \Psi\ \Omega \alpha\ \beta\ \gamma\ \delta\ \epsilon\ \zeta\ \eta\ \theta\ \iota\ \kappa\ \lambda\ \mu\ \nu\ \xi \ \omicron\ \pi\ \rho\ \sigma\ \tau\ \upsilon\ \phi\ \chi\ \psi\ \omega\ \varepsilon\ \vartheta\ \varpi\ \varrho\ \varsigma\ \varphi $$
箭头 $$ \gets\ \to\ \leftarrow\ \rightarrow\ \uparrow\ \Uparrow\ \downarrow\ \Downarrow\ \updownarrow\ \Updownarrow $$
$$ \Leftarrow\ \Rightarrow\ \leftrightarrow\ \Leftrightarrow\ \mapsto\ \hookleftarrow \leftharpoonup\ \leftharpoondown\ \rightleftharpoons\ \longleftarrow\ \Longleftarrow\ \longrightarrow $$
$$ \Longrightarrow\ \longleftrightarrow\ \Longleftrightarrow\ \longmapsto\ \hookrightarrow\ \rightharpoonup $$
$$ \rightharpoondown\ \leadsto\ \nearrow\ \searrow\ \swarrow\ \nwarrow $$
符号 $$ \surd\ \barwedge\ \veebar\ \odot\ \oplus\ \otimes\ \oslash\ \circledcirc\ \boxdot\ \bigtriangleup $$
$$ \bigtriangledown\ \dagger\ \diamond\ \star\ \triangleleft\ \triangleright\ \angle\ \infty\ \prime\ \triangle $$
微积分学 $$ \int u \frac{dv}{dx},dx=uv-\int \frac{du}{dx}v,dx $$
$$ f(x) = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} $$
$$ \oint \vec{F} \cdot d\vec{s}=0 $$
洛伦茨方程 $$ \begin{aligned} \dot{x} &amp; = \sigma(y-x) \\ \dot{y} &amp; = \rho x - y - xz \\ \dot{z} &amp; = -\beta z + xy \end{aligned} $$
交叉乘积 这在KaTeX中是可行的，但在这种环境中馏分的分离不是很好。
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
这里有一个解决方案:使用“mfrac”类(在MathJax情况下没有区别)的额外类使分数更小:
$$ \mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\ \frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\ \frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \end{vmatrix} $$
强调 $$ \hat{x}\ \vec{x}\ \ddot{x} $$
有弹性的括号 $$ \left(\frac{x^2}{y^3}\right) $$
评估范围 $$ \left.\frac{x^3}{3}\right|_0^1 $$
诊断标准 $$ f(n) = \begin{cases} \frac{n}{2}, &amp; \text{if } n\text{ is even} \\ 3n+1, &amp; \text{if } n\text{ is odd} \end{cases} $$
麦克斯韦方程组 $$ \begin{aligned} \nabla \times \vec{\mathbf{B}} -, \frac1c, \frac{\partial\vec{\mathbf{E}}}{\partial t} &amp; = \frac{4\pi}{c}\vec{\mathbf{j}} \\ \nabla \cdot \vec{\mathbf{E}} &amp; = 4 \pi \rho \\ \nabla \times \vec{\mathbf{E}}, +, \frac1c, \frac{\partial\vec{\mathbf{B}}}{\partial t} &amp; = \vec{\mathbf{0}} \\ \nabla \cdot \vec{\mathbf{B}} &amp; = 0 \end{aligned} $$
统计学 固定词组：
$$ \frac{n!}{k!(n-k)!} = {^n}C_k {n \choose k} $$
分数在分数 $$ \frac{\frac{1}{x}+\frac{1}{y}}{y-z} $$
ｎ次方根 $$ \sqrt[n]{1+x+x^2+x^3+\ldots} $$
矩阵 $$ \begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13}\\ a_{21} &amp; a_{22} &amp; a_{23}\\ a_{31} &amp; a_{32} &amp; a_{33} \end{pmatrix} \begin{bmatrix} 0 &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; 0 \end{bmatrix} $$
标点符号 $$ f(x) = \sqrt{1+x} \quad (x \ge -1) f(x) \sim x^2 \quad (x\to\infty) $$
现在用标点符号:
$$ f(x) = \sqrt{1+x}, \quad x \ge -1 f(x) \sim x^2, \quad x\to\infty $$
]]></content>
  </entry>
  
  <entry>
    <title>支持用户自定义设计</title>
    <url>/post/custom-files.html</url>
    <categories><category>示例</category>
    </categories>
    <tags>
      <tag>自定义</tag>
      <tag>个性化</tag>
      <tag>布局</tag>
    </tags>
    <content type="html"><![CDATA[对于熟悉前端开发的用户来说，可以通过自定义文件配置，实现对站点的样式和布局进行个性化的调整。其中布局方面主要是支持左侧边栏的站点概览部分，以及站点底部2个位置，但样式的重置可以是整个站点的任意位置。
打开配置参数 首先要明确在配置文件的 params 区域中有配置如下参数：
customFilePath: sidebar: custom_sidebar.html footer: custom_footer.html style: /css/custom_style.css 注意： sidebar 和 footer 的文件命名不可以与它们的参数名称相同，不然会影响系统默认的布局设计，切记！！！ 😄  然后在站点的根目录下创建 layouts/partials 2个目录，用于存放自定布局设计文件，另外在站点根目录下创建 statics/css 2个目录，用于存放自定义 CSS 样式文件。一切就绪后，就可以参考如下的步骤，完成自己的设计想法。
侧边栏设计 在前面创建 partials 目录中新一个后缀名为 html 的文件，可以在里面书写你所想表达的设计或内容，比如引入一些第三方组件内容。示例如下：
&lt;div class=&#34;mydefined animated&#34; itemprop=&#34;custom&#34;&gt; &lt;span&gt;支持自定义CSS和Sidebar布局啦💄💄💄&lt;/span&gt; &lt;/div&gt; 再把该文件的路径配置到相应的参数中，效果请查看左侧边栏底部的效果。
底部设计 在前面创建 partials 目录中新一个后缀名为 html 的文件，可以在里面书写你所想表达的设计或内容，比如引入一些第三方组件内容。示例如下：
&lt;div class=&#34;custom-footer&#34;&gt; Website source code &lt;a href=&#34;https://github.com/hugo-next/hugo-theme-next/tree/develop/exampleSite/layouts/partials/custom-footer.html&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt; &lt;/div&gt; 再把该文件的路径配置到相应的参数中，效果请查看站点底部的效果。
自定义样式 在前面创建 css 目录中新一个后缀名为 css 的文件，然后可以在里面把站点的样式进行重定义，或是增加一些自己定义的样式设计，在写文章时进行引用，示例如下：
.custom-head5 { font-size: 1.2em; color: #ed6c24; font-weight: bold; } 再把该文件的路径配置到相应的参数中，效果参考如下：
我是自定义的标题样式效果!!!
]]></content>
  </entry>
  
  <entry>
    <title>自定义短语示例</title>
    <url>/post/shortcodes.html</url>
    <categories><category>示例</category>
    </categories>
    <tags>
      <tag>短代码</tag>
      <tag>语法</tag>
    </tags>
    <content type="html"><![CDATA[虽然 Markdown 语法已经非常丰富能够满足我们写文章的绝大部分需求，但是为更好的对文章内容进行更友好的排版，为引设计一套自定义的短语，便于在使用时能够快速引用。
块引用 在引用一些经典名言名句时，可以采用此短语，语法参考如下：
{{&lt; quote &gt;}} ### block quote 写下你想表达的话语！ {{&lt; /quote &gt;}} 实际效果：
希望是无所谓有，无所谓无的，这正如地上的路。
其实地上本没有路，走的人多了，也便成了路。
鲁迅
 信息块 支持 default，info，success，warning，danger 等五种不同效果的展示，语法参考如下：
{{&lt; note [class] [no-icon] &gt;}} 书写表达的信息 支持 Markdown 语法 {{&lt; /note &gt;}} 实际效果：
Default Header without icon Welcome to Hugo NexT!  Default Header Welcome to Hugo NexT!  Info Header Welcome to Hugo NexT!  Success Header Welcome to Hugo NexT!  Warning Header Welcome to Hugo NexT!  Danger Header Welcome to Hugo NexT! ]]></content>
  </entry>
  
  <entry>
    <title>文章目录导航</title>
    <url>/post/table-of-content.html</url>
    <categories><category>示例</category>
    </categories>
    <tags>
      <tag>目录</tag>
      <tag>导航</tag>
      <tag>博客</tag>
    </tags>
    <content type="html"><![CDATA[巴顿将军说过：“衡量一个人是否成功，不是看他站到顶峰，而是从顶峰跌落之后的反弹力”，褚时健的人生便是如此，中年发家致富，名利双收，之后又跌落到谷底，等到74岁再创业，10年后带着褚橙归来，东山再起收获亿万财富，他的发展轨迹就是反弹的过程。
早年的故事 起始 2014年的春天，在云南省华宁县和宜良县的交界处，一座名叫矣则的小山村里，一处已经有上百年历史的古旧四合院宅子被拆掉。村委会正带领村民们进行“美丽乡村”的建设，一年以后，旧有村居将再也看不到，代之而起的是钢筋混凝土的新式民居。就像10年、20年前中国大小城市的改造一样，这个群山围绕的小村子也开始陷入“工地模式”。
童年浪花 在江河边长大的孩子几乎都有一个当仁不让的特长：善水。褚时健也不例外，他不仅从小就在南盘江和花鱼塘里扑腾出了上佳的游泳技术，五六岁已经可以一个猛子扎出老远，而且从七八岁就可以在南盘江和河滩上的鱼塘里捉鱼了。
少年故事 褚时健在乡村自由自在生活的十多年，其实正是中国社会风雨飘摇的十多年。特别是1937年卢沟桥事变后，日本人发动全面侵华战争，短短两三年间，中国的大部分国土相继沦陷
激情的青春十年 当上了游击队员 1948年夏天，褚时健回乡，在禄丰车站小学做了一名老师，同时也和褚时仁、褚时杰一起继续保持与共产党组织的联系，做一些传递情报的工作
战火纷飞 因为战斗力相较悬殊，所以游击队只能是靠打一枪换一个地方的办法，专找敌人薄弱的地方攻击，但更多时候，都是在防御和转移阵地。
迎来解放 1949年12月，国民党云南省主席卢汉在昆明宣布起义，云南正式拉开解放的序幕。1950年2月20日，陈赓、宋任穷、周保中率解放军第二野战军第四兵团进入昆明，24日，陈赓宣布云南全境解放。
生活的断层 跌入生活底层 “反右”运动中被打倒的人在“右派”身份确定后，只有一条路可走：下放到农场。农场名副其实，就是干农活儿的地方，必须过和农民一样的生活。
尾声 岁月像一条河 2015年，是褚时健和马静芬结婚60周年，被称为“钻石婚”的纪念年份。这简直是一份人生的奖赏,在中国离婚率愈益升高的当下，60年的婚姻，几乎就像一个前世之梦。一个甲子的相伴相随，褚时健和马静芬共同经历了国家和个人的各种风浪，共同面对过生死。他们两人已经不仅是夫妻，更是一对战友。尽管马静芬偶尔会对褚时健年轻时候的粗心抱怨上两句，但说到最后，她会说一句：“没有我就没有他，没有他也就没有我。”
作者致谢 这本书从2014年初夏开始采访，到今天完稿，历时18个月。封面上“作者”只能是我一个人的名字，但也只有我自己知道，这本书，包含了太多人的心力和体力。我当然首先要致谢王石先生，没有他就没有这本书。我自己细想下来，没有王石先生一直的鞭策和鼓励，也没有我写作工作的今天。从2006年我开始从事专业写作工作以来，他给我创造了很多写作的机会，并且不吝自己诸多人生和学习的体会和感悟，一一传递予我。知遇之恩，感谢非常。
最后，我当然要把最大的感谢致予褚时健先生。不仅是因为他慷慨、坦率面对我的各种提问，更重要的是，在倾听他的故事的过程里，他繁盛的人生经历，他的强大生命力，他对生活、对事业的一片赤子之心，也丰富了我对自己人生的思考。
]]></content>
  </entry>
  
  <entry>
    <title>Hugo 内置的 Chroma 语法高亮</title>
    <url>/post/syntax-highlighting.html</url>
    <categories><category>示例</category>
    </categories>
    <tags>
      <tag>语法</tag>
      <tag>高亮</tag>
      <tag>Chroma</tag>
    </tags>
    <content type="html"><![CDATA[Hugo 通过 Chroma 提供非常快速的语法高亮显示，现 Hugo 中使用 Chroma 作为代码块高亮支持，它内置在 Go 语言当中，速度是真的非常、非常快，而且最为重要的是它也兼容之前我们使用的 Pygments 方式。
以下通过 Hugo 内置短代码 highlight 和 Markdown 代码块方式分别验证不同语言的代码块渲染效果并能正确高亮显示，有关优化语法突出显示的更多信息，请参阅 Hugo 文档  。
编程语言 GO 199 200 201 202 203 204 205 206 207 208  func GetTitleFunc(style string) func(s string) string { switch strings.ToLower(style) { case &#34;go&#34;: return strings.Title case &#34;chicago&#34;: return transform.NewTitleConverter(transform.ChicagoStyle) default: return transform.NewTitleConverter(transform.APStyle)  } }   Java import javax.swing.JFrame; //Importing class JFrame import javax.swing.JLabel; //Importing class JLabel public class HelloWorld { public static void main(String[] args) { JFrame frame = new JFrame(); //Creating frame  frame.setTitle(&#34;Hi!&#34;); //Setting title frame  frame.add(new JLabel(&#34;Hello, world!&#34;));//Adding text to frame  frame.pack(); //Setting size to smallest  frame.setLocationRelativeTo(null); //Centering frame  frame.setVisible(true); //Showing frame  } } Python print &#34;Hello, world!&#34; Git 对比 *** /path/to/original &#39;&#39;timestamp&#39;&#39; --- /path/to/new &#39;&#39;timestamp&#39;&#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line *** /path/to/original &#39;&#39;timestamp&#39;&#39; --- /path/to/new &#39;&#39;timestamp&#39;&#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line 文件 Make 文件 CC=gcc CFLAGS=-I. hellomake: hellomake.o hellofunc.o $(CC) -o hellomake hellomake.o hellofunc.o -I. Markdown 文档 **bold** *italics* [link](www.example.com) 数据内容 JSON 数据 {&#34;employees&#34;:[ {&#34;firstName&#34;:&#34;John&#34;, &#34;lastName&#34;:&#34;Doe&#34;}, ]} XML 内容 &lt;employees&gt; &lt;employee&gt; &lt;firstName&gt;John&lt;/firstName&gt; &lt;lastName&gt;Doe&lt;/lastName&gt; &lt;/employee&gt; &lt;/employees&gt; SQL 查询 SELECT column_name,column_name FROM Table WHERE column_name = &#34;condition&#34; 除以上列举的代码高亮显示外，还支持诸如：C 语言、C++、HTML、CSS、Shell脚本等各主流的代码语言高亮显示，可自行测试效果。
]]></content>
  </entry>
  
  <entry>
    <title>支持 Emoji 表情</title>
    <url>/post/emoji-support.html</url>
    <categories><category>示例</category>
    </categories>
    <tags>
      <tag>表情</tag>
      <tag>emoji</tag>
    </tags>
    <content type="html"><![CDATA[Emoji 可以通过多种方式在 Hugo 项目中启用。
 emojify   方法可以直接在模板中调用, 或者使用 行内 Shortcodes  .
要全局使用 emoji, 需要在你的 网站配置  中设置 enableEmoji 为 true， 然后你就可以直接在文章中输入 emoji 的代码。
它们以冒号开头和结尾，并且包含 emoji 的 代码：
去露营啦! {:}tent: 很快就回来. 真开心! {:}joy: 呈现的输出效果如下:
去露营啦! ⛺ 很快就回来。
真开心! 😂
以下符号清单是 emoji 代码的非常有用的参考。
表情与情感 笑脸表情    图标 代码 图标 代码     😀 grinning 😃 smiley   😄 smile 😁 grin   😆 laughing satisfied 😅 sweat_smile   🤣 rofl 😂 joy   🙂 slightly_smiling_face 🙃 upside_down_face   😉 wink 😊 blush   😇 innocent      爱意表情    图标 代码 图标 代码     😍 heart_eyes 😘 kissing_heart   😗 kissing ☺️ relaxed   😚 kissing_closed_eyes 😙 kissing_smiling_eyes    吐舌头表情    图标 代码 图标 代码     😋 yum 😛 stuck_out_tongue   😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes   🤑 money_mouth_face      国家和地区旗帜    图标 代码 图标 代码     🇦🇩 andorra 🇦🇪 united_arab_emirates   🇦🇫 afghanistan 🇦🇬 antigua_barbuda   🇦🇮 anguilla 🇦🇱 albania   🇦🇲 armenia 🇦🇴 angola   🇦🇶 antarctica 🇦🇷 argentina   🇦🇸 american_samoa 🇦🇹 austria   🇦🇺 australia 🇦🇼 aruba   🇦🇽 aland_islands 🇦🇿 azerbaijan   🇧🇦 bosnia_herzegovina 🇧🇧 barbados   🇧🇩 bangladesh 🇧🇪 belgium   🇧🇫 burkina_faso 🇧🇬 bulgaria   🇧🇭 bahrain 🇧🇮 burundi   🇧🇯 benin 🇧🇱 st_barthelemy   🇧🇲 bermuda 🇧🇳 brunei   🇧🇴 bolivia 🇧🇶 caribbean_netherlands   🇧🇷 brazil 🇧🇸 bahamas   🇧🇹 bhutan 🇧🇼 botswana   🇧🇾 belarus 🇧🇿 belize   🇨🇦 canada 🇨🇨 cocos_islands   🇨🇩 congo_kinshasa 🇨🇫 central_african_republic   🇨🇬 congo_brazzaville 🇨🇭 switzerland   🇨🇮 cote_divoire 🇨🇰 cook_islands   🇨🇱 chile 🇨🇲 cameroon   🇨🇳 cn 🇨🇴 colombia   🇨🇷 costa_rica 🇨🇺 cuba   🇨🇻 cape_verde 🇨🇼 curacao   🇨🇽 christmas_island 🇨🇾 cyprus   🇨🇿 czech_republic 🇩🇪 de   🇩🇯 djibouti 🇩🇰 denmark   🇩🇲 dominica 🇩🇴 dominican_republic   🇩🇿 algeria 🇪🇨 ecuador   🇪🇪 estonia 🇪🇬 egypt   🇪🇭 western_sahara 🇪🇷 eritrea   🇪🇸 es 🇪🇹 ethiopia   🇪🇺 eu european_union 🇫🇮 finland   🇫🇯 fiji 🇫🇰 falkland_islands   🇫🇲 micronesia 🇫🇴 faroe_islands   🇫🇷 fr 🇬🇦 gabon   🇬🇧 gb uk 🇬🇩 grenada   🇬🇪 georgia 🇬🇫 french_guiana   🇬🇬 guernsey 🇬🇭 ghana   🇬🇮 gibraltar 🇬🇱 greenland   🇬🇲 gambia 🇬🇳 guinea   🇬🇵 guadeloupe 🇬🇶 equatorial_guinea   🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands   🇬🇹 guatemala 🇬🇺 guam   🇬🇼 guinea_bissau 🇬🇾 guyana   🇭🇰 hong_kong 🇭🇳 honduras   🇭🇷 croatia 🇭🇹 haiti   🇭🇺 hungary 🇮🇨 canary_islands   🇮🇩 indonesia 🇮🇪 ireland   🇮🇱 israel 🇮🇲 isle_of_man   🇮🇳 india 🇮🇴 british_indian_ocean_territory   🇮🇶 iraq 🇮🇷 iran   🇮🇸 iceland 🇮🇹 it   🇯🇪 jersey 🇯🇲 jamaica   🇯🇴 jordan 🇯🇵 jp   🇰🇪 kenya 🇰🇬 kyrgyzstan   🇰🇭 cambodia 🇰🇮 kiribati   🇰🇲 comoros 🇰🇳 st_kitts_nevis   🇰🇵 north_korea 🇰🇷 kr   🇰🇼 kuwait 🇰🇾 cayman_islands   🇰🇿 kazakhstan 🇱🇦 laos   🇱🇧 lebanon 🇱🇨 st_lucia   🇱🇮 liechtenstein 🇱🇰 sri_lanka   🇱🇷 liberia 🇱🇸 lesotho   🇱🇹 lithuania 🇱🇺 luxembourg   🇱🇻 latvia 🇱🇾 libya   🇲🇦 morocco 🇲🇨 monaco   🇲🇩 moldova 🇲🇪 montenegro   🇲🇬 madagascar 🇲🇭 marshall_islands   🇲🇰 macedonia 🇲🇱 mali   🇲🇲 myanmar 🇲🇳 mongolia   🇲🇴 macau 🇲🇵 northern_mariana_islands   🇲🇶 martinique 🇲🇷 mauritania   🇲🇸 montserrat 🇲🇹 malta   🇲🇺 mauritius 🇲🇻 maldives   🇲🇼 malawi 🇲🇽 mexico   🇲🇾 malaysia 🇲🇿 mozambique   🇳🇦 namibia 🇳🇨 new_caledonia   🇳🇪 niger 🇳🇫 norfolk_island   🇳🇬 nigeria 🇳🇮 nicaragua   🇳🇱 netherlands 🇳🇴 norway   🇳🇵 nepal 🇳🇷 nauru   🇳🇺 niue 🇳🇿 new_zealand   🇴🇲 oman 🇵🇦 panama   🇵🇪 peru 🇵🇫 french_polynesia   🇵🇬 papua_new_guinea 🇵🇭 philippines   🇵🇰 pakistan 🇵🇱 poland   🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands   🇵🇷 puerto_rico 🇵🇸 palestinian_territories   🇵🇹 portugal 🇵🇼 palau   🇵🇾 paraguay 🇶🇦 qatar   🇷🇪 reunion 🇷🇴 romania   🇷🇸 serbia 🇷🇺 ru   🇷🇼 rwanda 🇸🇦 saudi_arabia   🇸🇧 solomon_islands 🇸🇨 seychelles   🇸🇩 sudan 🇸🇪 sweden   🇸🇬 singapore 🇸🇭 st_helena   🇸🇮 slovenia 🇸🇰 slovakia   🇸🇱 sierra_leone 🇸🇲 san_marino   🇸🇳 senegal 🇸🇴 somalia   🇸🇷 suriname 🇸🇸 south_sudan   🇸🇹 sao_tome_principe 🇸🇻 el_salvador   🇸🇽 sint_maarten 🇸🇾 syria   🇸🇿 swaziland 🇹🇨 turks_caicos_islands   🇹🇩 chad 🇹🇫 french_southern_territories   🇹🇬 togo 🇹🇭 thailand   🇹🇯 tajikistan 🇹🇰 tokelau   🇹🇱 timor_leste 🇹🇲 turkmenistan   🇹🇳 tunisia 🇹🇴 tonga   🇹🇷 tr 🇹🇹 trinidad_tobago   🇹🇻 tuvalu 🇹🇼 taiwan   🇹🇿 tanzania 🇺🇦 ukraine   🇺🇬 uganda 🇺🇸 us   🇺🇾 uruguay 🇺🇿 uzbekistan   🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines   🇻🇪 venezuela 🇻🇬 british_virgin_islands   🇻🇮 us_virgin_islands 🇻🇳 vietnam   🇻🇺 vanuatu 🇼🇫 wallis_futuna   🇼🇸 samoa 🇽🇰 kosovo   🇾🇪 yemen 🇾🇹 mayotte   🇿🇦 south_africa 🇿🇲 zambia   🇿🇼 zimbabwe     ]]></content>
  </entry>
  
  <entry>
    <title>Markdown 语法支持</title>
    <url>/post/markdown-syntax.html</url>
    <categories><category>示例</category>
    </categories>
    <tags>
      <tag>Markdown</tag>
      <tag>语法</tag>
    </tags>
    <content type="html"><![CDATA[仅以此篇文章来测试下在 NexT 主题中在通过 Hugo 引擎来建站时，是否支持 Markdown 文件内容中所写的各种语法，并展示下实际的效果。
标题样式 让我们从所有可能的标题开始，在 HTML 中 &lt;h1&gt;-&lt;h6&gt;元素分别表示六个不同级别的标题样式，其中 &lt;h1&gt; 为最大标题，&lt;h6&gt;为最小标题，效果如下：
标题 1 标题 2 标题 3 标题 4 标题 5 标题 6 段落格式 根据 W3C  定义的 HTML5 规范  ，HTML 文档由元素和文本组成。每个元素的组成都由一个 开始标记  表示，例如： &lt;body&gt; ，和 结束标记  表示，例如： &lt;/body&gt; 。（某些开始标记和结束标记在某些情况下可以省略，并由其他标记暗示。） 元素可以具有属性，这些属性控制元素的工作方式。例如：超链接是使用 a 元素及其 href 属性形成的。
Markdown 语法 ![图像说明](图像地址) HTML IMG 标签 &lt;img src=&#34;图像地址&#34; width=&#34;宽度&#34; height=&#34;高度&#34; /&gt; SVG 格式 &lt;svg&gt;xxxxxx&lt;/svg&gt; 
列表类型 有序列表  第一个元素 第二个元素 第三个元素  无序列表  列表元素 另一个元素 和其它元素  嵌套列表 借助 HTML 的 ul 元素来实现。
 第一项 第二项  第二项第一个子项目 第二项第二个子项目  第二项第二分项第一分项 第二项第二分项第二分项 第二项第二分项第三分项   第二项第三个子项目  第二项第三分项第一分项 第二项第三分项第二分项 第二项第三分项第三分项    第三项  自定义列表 通过 HTML 的 dl 元素还支持自定义列表（表格列表）。
 Hugo 目录结构 assets config.toml content data theme static Hugo 模板 基础模板 列表模板 单页模板  块引用 blockquote 元素表示从另一个源引用的内容，可以选择引用必须在 footer 或 cite 元素中，也可以选择使用注释和缩写等行内更改。
 引用文本 这一行也是同样的引用 同样你也在 blockquote 中使用 Markdown 语法书写
 带有引文的 Blockquote 元素效果。
 我的目标不是赚大钱,是为了制造好的电脑。当我意识到我可以永远当工程师时，我才创办了这家公司。
— 史蒂夫·沃兹尼亚克  根据 Mozilla 的网站记录，Firefox 1.0 于 2004 年发布，并取得了巨大成功。
表格 表格并不算是 Markdown 的核心要素，但 Hugo 同样支持它。
   ID 创建者 模型 年份     1 Honda Accord 2009   2 Toyota Camry 2012   3 Hyundai Elantra 2010    可以使用 : （英文格式冒号）来对表格内容进行对齐。
   表格 可以是 很酷     左对齐 居中 右对齐   左对齐 居中 右对齐   左对齐 居中 右对齐    同样也可以在表格中使用 Markdown 语法。
   表格 中 使用 Markdown 语法     斜体 粗体 中划线 代码块    Code &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;Example HTML5 Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Test&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&#34;en&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;Example HTML5 Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Test&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 其它元素： abbr、sub、sup、kbd等等 GIF 是位图图像格式。
H2O
C6H12O6
Xn + Yn = Zn
按X获胜。或按CTRL+ALT+F显示 FPS 计数器。
比特作为信息论中的信息单位，也被称为 shannon ，以信息论领域的创始人 Claude shannon 的名字命名。
参考：
 来自 Mainroad 主题的 Basic Elements   内容 ]]></content>
  </entry>
  
  <entry>
    <title>友情链接</title>
    <url>/flinks.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
- name: VxWorks俱乐部 desc: VxWorks实时操作系统 avatar: https://www.vxworks.net/images/vxworks-club-logo.png link: https://www.vxworks.net ]]></content>
  </entry>
  
</search>