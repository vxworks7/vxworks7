
[{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/series/book/","section":"Series","summary":"","title":"Book","type":"series"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/book/","section":"Books","summary":"","title":"Books","type":"book"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/tags/embedded/","section":"Tags","summary":"","title":"Embedded","type":"tags"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/tags/vxworks/","section":"Tags","summary":"","title":"VxWorks","type":"tags"},{"content":" 本书详细介绍了当今流行的嵌入式操作系统VxWorks，首先概括 VxWorks 操作系统的基本知识，如任务管理、任务间通信机制、内存管理以及定时管理等内容，说明了嵌入式操作系统的实现关键。然后，结合作者多年的嵌入式系统的开发应用经验，详细阐述了 VxWorks 系统中 BSP 和应用程序的开发技巧，并提供了多个应用实例及分析设计。\n本书适用于嵌入式系统开发人员作为参考手册使用\n免费下载说明： 网络资源，整理仅供学习参考! 嵌入式VxWorks系统开发与应用 第 1 章 概述 # 1.1 嵌入式实时操作系统 VxWorks 1.1.1 VxWorks 的应用领域 1.1.2 VxWorks 系统的特点 1.1.3 VxWorks 的可用主机/目标机 1.2 Tornado 开发环境 1.2.1 Tornado 核心工具 1.2.2 WindPower 工具 1.3 Tornado 嵌入式开发系统可选组件 1.3.1 板级支持包 BSP Developer\u0026#39;s Kit 1.3.2 虚拟内存接口 VxVMI 1.3.3 支持紧耦合共享内存多处理器结构的 VxMP 1.3.4 支持紧耦合分布式多处理器结构的 VxDCOM 1.3.5 支持松耦合分布式多处理器结构的 VxFUSION 1.3.6 闪存文件系统 TrueFFS for Tornado 第 2 章 VxWorks 系统基本理论 # 2.1 VxWorks 系统概述 2.2 VxWorks 系统内核及组件 2.2.1 任务管理 2.2.2 任务间通信和同步机制 2.2.3 中断机制 2.2.4 定时管理机制 2.2.5 内存管理 2.2.6 I/O 与文件系统 2.3 VxWorks 系统开发经验 2.3.1 正确划分任务 2.3.2 防止任务异常 2.3.3 正确运用函数的可重入性 2.3.4 使用名称访问资源 2.3.5 用户任务优先级确定 2.4 VxWorks 系统开发模型概述 2.4.1 系统启动 2.4.2 应用系统配置 第 3 章 VxWorks 系统 BSP 基本概念 # 3.1 BSP 基础 3.2 BSP 文件结构 3.3 VxWorks 系统的 BSP 开发过程 3.3.1 建立 BSP 开发环境 3.3.2 编辑修改 BSP 文件 3.3.3 生成目标文件 bootrom 和 VxWorks 映像 3.3.4 基于 ROM 映像的初始化 3.4 BSP 中设备驱动程序的开发 第 4 章 VxWorks 系统 BSP 开发实例 # 4.1 MPC8260 处理器的组成与结构 4.1.1 基本功能模块 4.1.2 内核 603e 的组成 4.1.3 SIU 的结构 4.1.4 CPM 的模块结构 4.2 MPC8260 通信处理模块 4.2.1 内部存储空间 4.2.2 缓冲描述符 BD 4.2.3 参数 RAM 4.2.4 快速以太网控制器的功能 4.2.5 快速以太网控制器的接收过程 4.2.6 快速以太网控制器的发送过程 4.3 MPC8260 编程特点 4.3.1 数据格式和指令格式 4.3.2 指令分类 4.3.3 特殊功能寄存器 4.3.4 高速缓存控制 4.4 BSP 最小系统设计 4.4.1 BOOT ROM 配置编程 4.4.2 程序存储区 Flash 配置 4.4.3 SDRAM 初始化 4.4.4 CPU 初始化 4.4.5 系统软复位 4.5 接口驱动设计 4.5.1 MPC8260 SCC1-Ethernet 接口的设计 4.5.2 MPC8260 SMC1-RS232 接口的设计 4.6 BSP 的调试和测试 4.6.1 测试内容 4.6.2 测试项目及结果 第 5 章 VxWorks 系统开发环境 Tornado # 5.1 Tornado 开发环境概述 5.2 Tornado 开发环境的安装 5.2.1 安装 Tornado 开发环境 5.2.2 注册 Tornado 开发环境 5.3 初步使用 Tornado 环境 5.3.1 Tornado 工程的类型 5.3.2 启动 Tornado 环境 5.3.3 创建工作区和工程 5.3.4 添加文件到工作区和工程 5.3.5 编译工程 5.3.6 下载工程到 VxWorks 目标模拟器 5.3.7 在 Tornado Shell 下运行应用程序 5.4 监视与调试 5.4.1 检查内存消耗 5.4.2 软件逻辑分析 5.4.3 应用程序调试 第 6 章 VxWorks 系统编译器 # 6.1 Make 管理项目概述 6.2 编写 Makefile 的规则 6.2.1 虚拟目标 6.2.2 Makefile 的变量 6.2.3 make 的变量 6.2.4 隐式规则 6.2.5 模式规则 6.3 Make 命令 6.4 Makefile 实例分析 6.5 Gcc 的基本概念 6.6 Gcc 命令 6.7 Gcc 扩展 第 7 章 VxWorks 系统应用实例 # 7.1 VxWorks 系统中的任务划分 7.2 任务间通信机制 7.3 Wind 内核功能 7.4 中断处理 7.5 Sockets 通信 7.6 任务多实例应用 7.7 C++应用 7.8 数据报应用 7.9 虚拟内存设备驱动 7.10 RamDisk 驱动 7.11 WDB 应用 7.12 任务软调度实例一 7.13 任务软调度实例二 ","date":"2024-11-02","externalUrl":null,"permalink":"/book/embedded-vxworks-system-design-and-application/","section":"Books","summary":"\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./embedded-vxworks-system-design-and-application.webp\" alt=\"嵌入式VxWorks系统开发与应用\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003e本书详细介绍了当今流行的嵌入式操作系统\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e，首先概括 VxWorks 操作系统的基本知识，如任务管理、任务间通信机制、内存管理以及定时管理等内容，说明了嵌入式操作系统的实现关键。然后，结合作者多年的嵌入式系统的开发应用经验，详细阐述了 VxWorks 系统中 \u003ca href=\"https://www.vxworks7.com/bsp/\" target=\"_blank\"\u003eBSP\u003c/a\u003e 和\u003ca href=\"https://www.vxworks7.com/app/\" target=\"_blank\"\u003e应用程序\u003c/a\u003e的开发技巧，并提供了多个应用实例及分析设计。\u003c/p\u003e\n\u003cp\u003e本书适用于嵌入式系统开发人员作为参考手册使用\u003c/p\u003e\n\u003cblockquote\u003e\n免费下载说明：\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\u003c/br\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://www.filemail.com/d/xujzritxfgpsbws\" target=\"_blank\" download\u003e嵌入式VxWorks系统开发与应用\u003c/a\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e第 1 章 概述 \n    \u003cdiv id=\"%E7%AC%AC-1-%E7%AB%A0-%E6%A6%82%E8%BF%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%AC%AC-1-%E7%AB%A0-%E6%A6%82%E8%BF%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003e1.1 嵌入式实时操作系统 VxWorks\n1.1.1 VxWorks 的应用领域\n1.1.2 VxWorks 系统的特点\n1.1.3 VxWorks 的可用主机/目标机\n1.2 Tornado 开发环境\n1.2.1 Tornado 核心工具\n1.2.2 WindPower 工具\n1.3 Tornado 嵌入式开发系统可选组件\n1.3.1 板级支持包 BSP Developer\u0026#39;s Kit\n1.3.2 虚拟内存接口 VxVMI\n1.3.3 支持紧耦合共享内存多处理器结构的 VxMP\n1.3.4 支持紧耦合分布式多处理器结构的 VxDCOM\n1.3.5 支持松耦合分布式多处理器结构的 VxFUSION\n1.3.6 闪存文件系统 TrueFFS for Tornado\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 class=\"relative group\"\u003e第 2 章 VxWorks 系统基本理论 \n    \u003cdiv id=\"%E7%AC%AC-2-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%AC%AC-2-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003e2.1 VxWorks 系统概述\n2.2 VxWorks 系统内核及组件\n2.2.1 任务管理\n2.2.2 任务间通信和同步机制\n2.2.3 中断机制\n2.2.4 定时管理机制\n2.2.5 内存管理\n2.2.6 I/O 与文件系统\n2.3  VxWorks 系统开发经验\n2.3.1 正确划分任务\n2.3.2 防止任务异常\n2.3.3 正确运用函数的可重入性\n2.3.4 使用名称访问资源\n2.3.5 用户任务优先级确定\n2.4 VxWorks 系统开发模型概述\n2.4.1 系统启动\n2.4.2 应用系统配置\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 class=\"relative group\"\u003e第 3 章 VxWorks 系统 BSP 基本概念 \n    \u003cdiv id=\"%E7%AC%AC-3-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F-bsp-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%AC%AC-3-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F-bsp-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003e3.1 BSP 基础\n3.2 BSP 文件结构\n3.3 VxWorks 系统的 BSP 开发过程\n3.3.1 建立 BSP 开发环境\n3.3.2 编辑修改 BSP 文件\n3.3.3 生成目标文件 bootrom 和 VxWorks 映像\n3.3.4 基于 ROM 映像的初始化\n3.4 BSP 中设备驱动程序的开发\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 class=\"relative group\"\u003e第 4 章 VxWorks 系统 BSP 开发实例 \n    \u003cdiv id=\"%E7%AC%AC-4-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F-bsp-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%AC%AC-4-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F-bsp-%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003e4.1 MPC8260 处理器的组成与结构\n4.1.1 基本功能模块\n4.1.2 内核 603e 的组成\n4.1.3 SIU 的结构\n4.1.4 CPM 的模块结构\n4.2 MPC8260 通信处理模块\n4.2.1 内部存储空间\n4.2.2 缓冲描述符 BD\n4.2.3 参数 RAM\n4.2.4 快速以太网控制器的功能\n4.2.5 快速以太网控制器的接收过程\n4.2.6 快速以太网控制器的发送过程\n4.3 MPC8260 编程特点\n4.3.1 数据格式和指令格式\n4.3.2 指令分类\n4.3.3 特殊功能寄存器\n4.3.4 高速缓存控制\n4.4 BSP 最小系统设计\n4.4.1 BOOT ROM 配置编程\n4.4.2 程序存储区 Flash 配置\n4.4.3 SDRAM 初始化\n4.4.4 CPU 初始化\n4.4.5 系统软复位\n4.5 接口驱动设计\n4.5.1 MPC8260 SCC1-Ethernet 接口的设计\n4.5.2 MPC8260 SMC1-RS232 接口的设计\n4.6 BSP 的调试和测试\n4.6.1 测试内容\n4.6.2 测试项目及结果\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 class=\"relative group\"\u003e第 5 章 VxWorks 系统开发环境 Tornado \n    \u003cdiv id=\"%E7%AC%AC-5-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-tornado\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%AC%AC-5-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-tornado\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003e5.1 Tornado  开发环境概述\n5.2 Tornado 开发环境的安装\n5.2.1 安装 Tornado 开发环境\n5.2.2 注册 Tornado 开发环境\n5.3 初步使用 Tornado 环境\n5.3.1 Tornado 工程的类型\n5.3.2 启动 Tornado 环境\n5.3.3 创建工作区和工程\n5.3.4 添加文件到工作区和工程\n5.3.5 编译工程\n5.3.6 下载工程到  VxWorks 目标模拟器\n5.3.7 在 Tornado Shell 下运行应用程序\n5.4 监视与调试\n5.4.1 检查内存消耗\n5.4.2 软件逻辑分析\n5.4.3 应用程序调试\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 class=\"relative group\"\u003e第 6 章 VxWorks 系统编译器 \n    \u003cdiv id=\"%E7%AC%AC-6-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E5%99%A8\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%AC%AC-6-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E5%99%A8\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003e6.1 Make 管理项目概述\n6.2 编写 Makefile 的规则\n6.2.1 虚拟目标\n6.2.2 Makefile 的变量\n6.2.3 make 的变量\n6.2.4 隐式规则\n6.2.5 模式规则\n6.3 Make 命令\n6.4 Makefile 实例分析\n6.5 Gcc 的基本概念\n6.6 Gcc 命令\n6.7 Gcc 扩展\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2 class=\"relative group\"\u003e第 7 章 VxWorks 系统应用实例 \n    \u003cdiv id=\"%E7%AC%AC-7-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%AC%AC-7-%E7%AB%A0-vxworks-%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003e7.1 VxWorks 系统中的任务划分\n7.2 任务间通信机制\n7.3 Wind 内核功能\n7.4 中断处理\n7.5 Sockets 通信\n7.6 任务多实例应用\n7.7 C++应用\n7.8 数据报应用\n7.9 虚拟内存设备驱动\n7.10 RamDisk 驱动\n7.11 WDB 应用\n7.12 任务软调度实例一\n7.13 任务软调度实例二\n\u003c/code\u003e\u003c/pre\u003e","title":"嵌入式VxWorks系统开发与应用","type":"book"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/app/","section":"Apps","summary":"","title":"Apps","type":"app"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/tags/uart/","section":"Tags","summary":"","title":"UART","type":"tags"},{"content":" 摘要：结合嵌入式实时操作系统VxWorks实现风洞测控系统的实际应用,以其中的串口通信为例，讨论了在VxWorks下实现串口通信的关键技术，给出了基本原理、环境配置和程序示例。 关键词：VxWorks； 实时操作系统； 嵌入式操作系统；串行通信\n[Abstract] Combining with the application of wind tunnel measure and control system with embedded real-time operating system VxWorks , with the serial communication in it as an example ,the key techniques about realization of the serial communication in VxWorks are discussed. Communication mechanism， environment configure and corresponding program examples are provided. [Key words] VxWorks；RTOS；embedded operating system； Serial Communication\n前言 # 目前市场上比较著名的实时操作系统有：VxWorks、PSOS、Nucleus、QNX、VRTX、Windows CE、Palm 0S、Lynx0S等。 其中，VxWorks是一个具有微内核、可裁剪的高性能强实时操作系统，在实时操作系统市场上处于领先地位。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、弹道制导、飞机导航等。在美国的 F-16战斗机、B-2 隐形轰炸机和爱国者导弹上，甚至火星探测器上都使用了VxWorks实时操作系统。在嵌入式实时操作系统中使用串口通信，不仅可扩展嵌入式设备通信能力，而且可扩大其应用范围。\nVxWorks简介 # VxWorks是由wRS(wind River Systems，Inc．)公司开发的一套具有微内核、高性能、可伸缩的实时操作系统，支持广泛的网络通信协议，并能够根据用户的需求进行组合，其开放式的结构和对工业标准的支持使开发者只需做最少的工作即可设计出有效的适合于不同用户要求的系统。除了性能出众的操作系统之外，wRS公司还提供了优秀的实时操作系统开发工具Tornado。Tornado由三个高度集成的部分组成：Tornado工具，一整套强有力的交叉开发工具；VxWorks运行系统，是运行在目标机上的高性能、可裁剪的实时操作系统；连接目标机和宿主机的通信选项，加以太网、串行线路、在线仿真等。Tornado能够支持Windows、Unix等流行的工作平台和PowerPC、X86、ARM等几乎所有的目标处理器，所提供的工具可用于所有目标机，并具有两种调试模式(系统模式和任务模式)。除了基本的功能和开发工具外，Tornado还具有先进的系列网络产品，极大地扩展了Tornado的网络特性，并增强了嵌人式微处理器的网络特性。[1]\n串口通信基本原理 # 串口在嵌入式系统当中是一类重要的数据通信接口，其本质功能是作为CPU和串行设备间的编码转换器。当数据从CPU经过串行端口发送出去时，字节数据转换为串行的位；在接收数据时，串行的位被转换为字节数据。应用程序要使用串口进行通信，必须在使用之前向操作系统提出资源申请要求(打开串口)，通信完成后必须释放资源(关闭串口)。\n串口通信的优点是开发简单，在传输数据量不大、要求速度不高而传输距离较大的通信场合得到广泛应用。\n在VxWorks中，将I/O系统设计成为任何类型的设备提供一个简单、统一、独立于设备的接口，任何对于串口的操作都可以视为对一个文件的操作，而不必了解串口设备或程序驱动实现的细节。在串口通信软件的设计中，当串口初始化完成后，在使用之前利用open()打开相应串口，然后进行配置。\nVxWorks提供终端和伪终端设备驱动。Tty驱动针对实终端；pty针对仿真终端的程序。Tty设备有两种操作模式：raw模式和line模式。在raw模式下，每个刚从设备输入的字符对读者都是有效的；在line模式下所有输入字符被存储，直到NEWLINE字符输入。设备选项字使用带FIOSETOPTIONS 功能的ioctl()程序来设置。[2]\n配置完成后，依据串口打开时的读写标志，调用函数write()、read()对串口进行只读操作、只写操作或同时进行读写操作。\n为提高数据接收的实时性，可采用中断方式，利用VxWorks提供的select函数的事件触发机制，将读串口的任务阻塞使其一直等待数据，当有数据来到的时候该任务会立刻自动响应，提高系统的实时性。\n环境配置 # 在本实时应用系统中采用486机作为目标机，串口通信时目标机VxWorks系统启动盘的制作步骤：\n修改通用配置文件Tornado\\target\\config\\pc486\\config.h。在config.h文件中加入以下宏定义：\n在Tornado集成环境中执行菜单命令Project \u0026gt; Make PC486 \u0026gt; Common Targets \u0026gt; clean删除以前生成的文件，执行菜单命令Project \u0026gt; Make PC486 \u0026gt; Boot Rom Targets \u0026gt; bootrom_uncmp编译链接生成bootrom_uncmp ；再选择VxWorks Target,编译生成vxworks；\n拷贝Tornado\\target\\config\\pc486\\bootrom_uncmp至Tornado\\host\\bin下\n重命名文件bootrom_uncmp为bootrom；\n准备一张已格式化的空盘插入软驱；\n在目录Tornado\\host\\bin下执行命令 mkboot a: bootrom；\n拷贝Tornado\\target\\config\\pc486\\VxWorks至软盘；\n将系统制作盘插入目标机软驱，加电启动目标机即载入VxWork.st系统。[3]\n程序示例 # 在程序中加入下列头文件 # #include \u0026#34;vxWorks.h\u0026#34; #include \u0026#34;strLib.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;sioLib.h\u0026#34; #include \u0026#34;ioLib.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;ioctl.h\u0026#34; #include \u0026#34;selectLib.h\u0026#34; #include \u0026#34;types/vxTypesOld.h\u0026#34; 打开串口 # int open_com1(void) //打开串口1函数 { int sfd；//串口设备文件描述符 sfd =open(”／tyCo／0”，0_RDWR，0)；//打开串口并返回串口设备文件描述符 if(sfd ==ERROR) //如果不能打开串口1则打印出错信息 printf(\u0026#34;You can’t open port com1 !\u0026#34;); } 配置串口 # int config_com1(void) //串口1配置函数 { ioctl(sfd,FIOSETOPTIONS,OPT_LINE); //设置串口工作模式为行模式：LINE_MODE ioctl(sfd,FIOBAUDRATE,9600); //设置串口波特率为9600bps ioctl(sfd,FIOFLUSH,0); //清空输入输出缓冲 ioctl(sfd,SIO_HW_OPTS_SET,CS8|STOPB|PARENB|PARODD); //设置 8 位数据位，2位停止位，带校验位，奇校验 } 串口接收数据 # int accept _com1(void) //从串口1接收数据函数 { while(1) { char * accept _buf; FD_ZERO(\u0026amp;fds_data);//位码置零 FD_SET(sfd,\u0026amp;fds_data);//初始化位码 width＝sfd +1; //任务阻塞等待读串口准备完毕； if(select(width，\u0026amp;fds_data，NULL，NULL，NULL)==ERROR) return(ERROR); read(sfd, accept _buf,sizeof(accept _buf)); //从串口读字符 printf(\u0026#34;accept message is : %s \u0026#34;n\u0026#34;n\u0026#34;, accept _buf); //输出接收到的信息 } } 串口发送数据 # int send_com1(void) //向串口1发送数据函数 { char *send_buf =\u0026#34; Data had accept!\u0026#34;; //待发送数据 //任务阻塞等待写串口准备完毕 if(select(width，NULL，＆data_fds，NULL,NULL==ERROR) return(ERROR) ; if(FD_ISSET(sfd，\u0026amp;fds_data)) //检查串口准备好就向串口写数据 write(sfd，send_buf，sizeof(send_buf)) ; } 关闭串口 # close(sfd)； 结束语 # RS-232串口通信虽速率不高，但RS-422标准串行口通信则采用了双线传输，大大增加了抗共模干扰的能力，最大数据传输速度可以达到10Mb/s，这对于远程数据交换具有极大的优势。\n本文描述了在实时操作系统VxWorks中利用串口实现数据通信的方法，并给出了示例程序，目前已经在我们开发的风洞测控系统中获得了应用。该方法可将其串口通信可适用于工业控制等多方面，具有广泛的适应性。在嵌入式实时操作系统中使用串口通信，不仅可扩展嵌入式设备通信能力，而且可扩大其的应用范围。\n参考文献： # 孔祥营，柏桂枝．嵌入式实时操作系统vxworks及其开发环境Tornodo[M]．北京:中国电力出版社，2002.01 陈智育，温彦军，陈琪编著VxWorks程序开发实践. 北京:人民邮电出版社，2004.05 李方敏编著VxWorks高级程序设计. 北京:清华大学出版社，2004.05 原文地址: 基于VxWorks实时操作系统的串口通信程序设计与实现\nDownload the file\n","date":"2024-11-02","externalUrl":null,"permalink":"/app/design-and-implementation-of-uart-communication-application-based-on-vxworks/","section":"Apps","summary":"\u003cblockquote\u003e\n摘要：结合嵌入式实时操作系统VxWorks实现风洞测控系统的实际应用,以其中的串口通信为例，讨论了在VxWorks下实现串口通信的关键技术，给出了基本原理、环境配置和程序示例。\n\u003cp\u003e关键词：VxWorks； 实时操作系统； 嵌入式操作系统；串行通信\u003c/p\u003e\n\u003cp\u003e[Abstract] Combining with the application of wind tunnel measure and control system with embedded real-time operating system VxWorks , with the serial communication in it as an example ,the key techniques about realization of the serial communication in VxWorks are discussed. Communication mechanism， environment configure and corresponding program examples are provided. [Key words] VxWorks；RTOS；embedded operating system； Serial Communication\u003c/p\u003e","title":"基于VxWorks实时操作系统的串口通信程序设计与实现","type":"app"},{"content":"","date":"2024-10-24","externalUrl":null,"permalink":"/tags/timer/","section":"Tags","summary":"","title":"Timer","type":"tags"},{"content":"VxWorks是一种嵌入式实时操作系统(RTOS)，具有内核小、可裁剪、实时性强等特点。VxWorks内核(Wind)提供了共享内存、信号量、消息队列、套接字通信和定时器等多种机制。为了实现基于UDP网络的可靠通信，本文利用VxWorks的多种任务间通信机制和看门狗定时器机制，设计了一种多重定时器模型，该模型可以确保数据包的可靠传递。\nVxWOrks的时钟及定时器机制 # VxWorks延时函数 # VxWorks既提供了延时功能，也提供了时限约束功能。VxWorks系统有2种延时方式：一种是Wind内核提供的taskDelay()函数；另一种是POSIX函数nanosleep()。taskDelay()函数以tick作为延时单位，默认情况下1个tick为16．67 ms(1／60 s)，可以通过调用sysClkRateSet()函数对tick进行重新设定。taskDelay()函数使调用该函数的任务在指定时间内主动放弃CPU，用于任务调度或等待某一外部事件。nanosleep()函数指定一个以s和ns为单位的睡眠或延时时间。其实，两个延时函数的精度是相同的，都是以tick为时间基准。不同之处在于，taskDelay(0)有自身意义，用于相同优先级任务间的任务调度，而nanosleep(0)是没有意义的。\nVxWorks定时器机制 # VxWorks提供一种看门狗定时器机制(watchdogtimer)，可以用来处理任务的时限约束。看门狗定时器作为系统时钟中断服务程序的一部分来维护，因此，看门狗定时器的回调函数以系统时钟中断级作为中断服务程序执行。看门狗定时器回调函数受到中断服务程序的限制，不能调用可能引起阻塞的函数，比如试图获取信号量，调用malloc()和free()等创建和释放内存函数或执行I／O操作。\nPOSIX定时器也可以处理任务时限。此外，VxWorks中一些函数具有时限控制的功能，semTake()、msgQSend()、msgQReceive()函数中都有设定时限控制的参数。超时参数NO_WAIT意味着立即返回，而WAIT_FOREVER意味着程序永不超时。\n多重定时器实现要求 # 在VxWorks系统下，利用网络套接字建立基于UDP协议的客户端／服务器通信模式。由于UDP是无连接的协议，发送方并不清楚发出的数据包是否已经正确到达接收方，于是提出一种支持重传和定时等待确认的协议。\n这个协议要求发送方发送的数据包与接收方回复的确认包具有对应的序列号，发送方和接收方都可以通过序列号来判断是不是想要得到的数据包。序列号是循环的，考虑到如果序列号太小会出现折返情况产生混淆，所以序列号至少大于2。如果用1个字节来表示序列号，则可以设定序列号为256。\n发送方送出一个数据包后启动一个定时器。这时可能会有4种情况发生：\n发送方接收到正确序号的确认包，则发送下一序列号的数据包。 发送方接收到已经接收过的重复确认包，则丢弃该确认包继续等待。如果在超时前收到了正确确认包，则发送下一序列号的数据包。 定时器超时，没有收到想要的确认包，则重新发送数据包，启动下一定时器。 设定的多重定时器超时后，没有收到想要确认包，则通知网络管理设备。 接收方在收到所需序列号的数据包后，回复一个确认包给发送方。如果接收方回复的确认包后没有正确到达发送方，则会引起发送方超时，重新发送原序列号数据包。接收方收到数据包后，需要检查数据包序列号。如果是重复序列号数据包，则丢弃，但是依旧回复确认包给发送方，以免已发送确认包在发送过程中丢失。这里基于支持重传和定时等待确认协议。具体要求是，在客户端通过UDP协议发送数据包后启动一个定时器，等待接收服务器端回复的ACK(acknowl-edgement)确认包。如果成功接收，则继续发送下一序列号的数据包；如果超时后还没有收到需要的确认包，则重新传输原序列号的数据包。图1所示为数据包均按时、正确地接收的情况。\n一般情况下，假定启动定时器30 ms内可以完成从发送数据包到接收ACK确认包的全过程，但是由于某些原因使得30 ms内无法收到确认包，则会重传原数据包，并启动一个稍长的40 ms定时器。如果40 ms还无法收到确认，则再次重传原数据包，并启动一个考虑到最差情况的60 ms定时器。如果依旧无法收到确认则不再发送，通知网络管理设备。\n出现定时器超时情况有3种可能：发送方发送数据包过程中丢包；接收方发送确认包过程中丢包；从发送数据包到确认包到达发送方过程中，延时时间超过定时时间。造成超时有两方面原因：一是，双方终端在接收数据包时由于缓冲问题不能及时处理，使得终端出现延时接收数据包或丢包；二是，通信链路发生断链情况，导致双方无法进行通信。从图2中可以看到，如果链路没有断开，则包含3种情况的三重定时器超时情况。\n多重定时器设计 # 设计方案 # 选用看门狗定时器机制来设计。看门狗定时器操作较为简单，只有4个函数，即wdCreate()、wdDelete()、wdStart()、wdCancel()。看门狗定时器与调用任务异步执行，并不阻塞调用任务，所以看门狗定时器很适合多任务的非阻塞计时。\n当看门狗定时器启动后，如果在规定的30 ms内收到了正确的确认包，就会将定时器取消掉，继续发送下面的数据包。如果30 ms规定时间内没有收到确认数据包ACK，则需要重新发送数据包，并启动第2个40 ms的定时器。VxWorks中单CPU的任务间常用通信机制是消息队列。当定时器到时后利用消息队列向发送任务发送消息，通知发送任务重新发送数据包，启动下一定时器。看门狗定时器的回调函数可以执行msgQSend()这种向消息队列发送消息的函数，我们通过msgQSend()函数向主任务发送时限已达消息。但是，将msgQSend()的延时参数设为wAIT_FOREVER时，消息队列中一旦没有了可用缓冲，则进入等待状态。由于中断服务程序优先级高，而从消息队列中接收消息的优先级低，当有任务准备从消息队列中取消息时，要等待中断服务程序执行完毕，则消息队列始终处于已满状态，造成系统死锁。如果将msgQSend()函数中的延时参数改为NO_WAIT，则可避免一直等待向消息队列发消息的情况，一旦消息队列已满就将该消息丢弃。但这样一来，向接收端发送数据包任务接收不到定时器超时消息，不会重发原序列号数据包和启动下一定时器，所以使用参数NO_WAIT也不可行。\n这里提出一种避免上述情况造成系统死锁的方法，即使用信号量机制来使msgQSend()不在中断服务程序中执行。通过使用信号量的任务间同步机制来实现这个功能。释放信号量函数semGive()不像msgQSend()那样需要在消息队列中等待，一旦执行就可以马上释放信号量，从而避免了冲突。\n由于任务中事件发生有一定间隔，不必选用计数器信号量，所以选用最常用的二进制信号量。首先建立3个先进先出的二进制信号量，设定可调用信号量为空。然后在看门狗定时器的回调函数中使用semGive()函数来释放信号量，重建一个任务在任务起始使用semTake()函数来获取信号量。当获得信号量后，通过msgQSend(，，，WAIT_FOREVER，)函数向消息队列中发送超时消息，而且保证只要消息队列有可用缓冲，就一定可以将消息送出。本文给出一个多重定时器的任务框架，如图3所示。\n主要实现代码 # 一个三重定时器的主要实现代码如下：\n以上程序中通过sysClkRateSet(100)将最小延时单位tick修改成10 ms，它是几个定时时间(30 ms、40 ms、60ms)的最大公约数。通过抓包软件Ethereal抓包，查看发送时间。以30 ms为例，抓包100次的平均定时时间在25 ms左右。出现这种情况的原因是，延时N个tick实际是延时(N-1)tick~N·tick。由于是等可能概率，则它的数学期望是(N+1／2)。对于tick为10 ms，30 ms即N=3，数学期望为25 ms。示意图如图4所示。\n延时精度为1／N秒，N越大越精确。于是调用函数synClkRateSet(500)，可以使定时的最大误差不超过2 ms。但是如果时钟频率太高，会造成系统在时钟中断处理方面开销太大，影响系统的任务调度，最好通过实验选用较为合适的时钟频率。这里选用sysClkRate-Set(200)。\n结 语 # 本文针对VxWorks下UDP网络通信中的可靠传输问题，提出了一个支持重传和定时等待确认的协议，并利用VxWorks系统提供的信号量同步、消息队列和看门狗定时器等多种机制，综合设计了一种可扩展的三重定时器。针对遇到的具体问题，笔者还进行了一定的优化处理。这种多重定时器模型已在笔者所研究的项目中得到利用，验证了其可行性和相对稳定性。这种多重定时器模型并不完全适合所有环境，需要根据具体情况改进和优化。\n","date":"2024-10-24","externalUrl":null,"permalink":"/app/design-of-multiple-timers-in-vxworks/","section":"Apps","summary":"\u003cp\u003e\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e是一种嵌入式实时操作系统(\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eRTOS\u003c/a\u003e)，具有内核小、可裁剪、实时性强等特点。VxWorks内核(Wind)提供了共享内存、信号量、消息队列、套接字通信和定时器等多种机制。为了实现基于UDP网络的可靠通信，本文利用VxWorks的多种任务间通信机制和看门狗定时器机制，设计了一种多重定时器模型，该模型可以确保数据包的可靠传递。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eVxWOrks的时钟及定时器机制 \n    \u003cdiv id=\"vxworks%E7%9A%84%E6%97%B6%E9%92%9F%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%9C%BA%E5%88%B6\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#vxworks%E7%9A%84%E6%97%B6%E9%92%9F%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%9C%BA%E5%88%B6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\n\u003ch3 class=\"relative group\"\u003eVxWorks延时函数 \n    \u003cdiv id=\"vxworks%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#vxworks%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003eVxWorks既提供了延时功能，也提供了时限约束功能。VxWorks系统有2种延时方式：一种是Wind内核提供的taskDelay()函数；另一种是POSIX函数nanosleep()。taskDelay()函数以tick作为延时单位，默认情况下1个tick为16．67 ms(1／60 s)，可以通过调用sysClkRateSet()函数对tick进行重新设定。taskDelay()函数使调用该函数的任务在指定时间内主动放弃CPU，用于任务调度或等待某一外部事件。nanosleep()函数指定一个以s和ns为单位的睡眠或延时时间。其实，两个延时函数的精度是相同的，都是以tick为时间基准。不同之处在于，taskDelay(0)有自身意义，用于相同优先级任务间的任务调度，而nanosleep(0)是没有意义的。\u003c/p\u003e","title":"VxWorks下的多重定时器设计","type":"app"},{"content":"","date":"2024-10-22","externalUrl":null,"permalink":"/bsp/","section":"Bsps","summary":"","title":"Bsps","type":"bsp"},{"content":"","date":"2024-10-22","externalUrl":null,"permalink":"/tags/u-boot/","section":"Tags","summary":"","title":"U-Boot","type":"tags"},{"content":"VxWorks是美国风河公司制作的一个实时操作系统，U-Boot是一个广为人知的通用启动加载器，它是嵌入式系统加电后运行的最早的代码。U-Boot通常被用于嵌入式系统，比如PowerPC或者ARM设备，这些设备上没有X86的BIOS。\n介绍 # 尽管VxWorks可以有它自己的bootloader(VxWorks Bootrom或者Bootapp)，U-Boot具有更多的功能，如果硬件板子已经提供了U-Boot的支持，那我们更有道理去直接使用它。\nU-boot : http://www.denx.de/wiki/U-Boot/WebHome VxWorks : https://www.windriver.com/products/vxworks/ 现在最新的VxWorks版本(VxWorks 7)已经比过去的VxWorks版本(我在VxWorks 6.9上遇到了好多问题)更加简单地和U-Boot集成了。\n这篇文章讲述了我们为最近的VxWorks 7 BSP进行设置的细节，我们选择使用一个独立于VxWorks镜像文件的DTB文件，而不是将DTB文件嵌入到VxWorks镜像里面。这将给我们带来更好的灵活性，让启动行能够从U-Boot上进行修改，而不需要重新编译DTB。\n具体地，VxWorks镜像需要将U-Boot头编译进去，然后U-Boot需要配置传递命令行参数以及MAC地址给VxWorks。\n编译VxWorks镜像文件 # 一个支持U-Boot的VxWorks镜像文件需要编译(将把U-Boot的头加入到VxWorks二进制中)\n从Workbench或者命令行来编译uVxWorks的目标文件。\n打开一个DOS命令行，配置编译环境，然后编译工程项目。\ncd \u0026lt;WIND_HOME\u0026gt; // your installation directory wrenv -p vxworks-7 cd \u0026lt;YOUR_VIP\u0026gt; // your VxWorks Image Project vxprj vip build uVxWorks 这将创建两个文件，用tftp被U-Boot加载到内存：\n文件名 描述 uVxWorks VxWorks image with U-Boot header [yourboard].dtb the device tree binary 为VxWorks配置U-Boot # U-Boot需要设置一些环境变量来加载VxWorks，针对VxWorks的启动参数(bootline)：\n=\u0026gt; setenv bootargs memac(2,0)host:vxWorks h=192.168.1.101 e=192.168.1.50:ffffff00 g=192.168.1.254 u=vxworks pw=gaitpu f=0x0 =\u0026gt; saveenv =\u0026gt; printenv bootargs bootargs=memac(2,0)host:vxWorks h=192.168.1.101 e=192.168.1.50:ffffff00 g=192.168.1.254 u=vxworks pw=gaitpu f=0x0 还有你可以随意给网络设备改变MAC地址：\nsetenv ethaddr 00:00:13:3a:ad:00 setenv eth1add 00:00:13:3a:ad:01 setenv eth1add 00:00:13:3a:ad:02 setenv eth1add 00:00:13:3a:ad:03 saveenv 加载和执行VxWorks镜像文件 # 配置一个tftp服务器来加载VxWorks镜像文件和DTB文件。\n你可以从下面下载一个非常好的Windows TFTP服务器：\nhttp://tftpd32.jounin.net/ 加载VxWorks镜像文件 # =\u0026gt; tftp 0x100000 uVxWorks Using FM1@DTSEC3 device TFTP from server 192.168.1.101; our IP address is 192.168.1.50 Filename \u0026#39;uVxWorks\u0026#39;. Load address: 0x100000 Loading: ################################################################# ################################################################# ################################################################# 1.5 MiB/s done Bytes transferred = 2861632 (2baa40 hex) 加载dtb blob # =\u0026gt; tftp 0xe00000 t4240qds.dtb Using FM1@DTSEC3 device TFTP from server 192.168.1.101; our IP address is 192.168.1.50 Filename \u0026#39;t4240qds.dtb\u0026#39;. Load address: 0xe00000 Loading: ## 1.4 MiB/s 启动VxWorks镜像文件 # =\u0026gt; bootm 0x100000 - 0xe00000 WARNING: adjusting available memory to 30000000 ## Booting kernel from Legacy Image at 00100000 ... Image Name: vxWorks Image Type: PowerPC VxWorks Kernel Image (uncompressed) Data Size: 2861568 Bytes = 2.7 MiB 创建U-boot命令 # 用下面的步骤创建一个新的U-Boot命令\nsetenv vxboot \u0026#39;tftp 0x100000 uVxWorks; tftp 0xe00000 t4240qds.dtb; bootm 0x100000 - 0xe00000\u0026#39; saveenv 运行这个命令：\nrun vxboot 配置U-Boot来传递MAC地址 # 这对于硬件开发者来说是至关重要的，MAC地址通常是在工厂里面分配的，会被VxWorks镜像文件使用。否则每一块板子出厂前都需要编译和加载一个独立的VxWorks，这绝对是一个梦魇般的情况。\n幸运地我们找到了一个方法，因为我们使用一个独立的dtb文件，而不是将dtb文件编译到VxWorks里面，U-Boot会用网络环境变量中的MAC地址覆盖dts文件中的MAC地址。\n不仅仅U-Boot可以覆盖本地的MAC地址，如果你在U-Boot环境变量中存储额外的网络地址变量并在你的设备树中为网络接口添加别名的话，U-Boot可以通过设备树将这些MAC地址传递给VxWorks。所以理论上所有网络设备的MAC地址都可以被覆盖。\n比如针对一块T4240的PowerPC板子：\n/* * U-boot only fixes up MAC Adrress (ethernet0 - n) if * environment variable is set. * aliases simplyfies the path to the property i.e by using a * label \u0026lt;\u0026amp;enet0\u0026gt; to assign a path to a particular node */ aliases{ ethernet0 = \u0026amp;enet0; ethernet1 = \u0026amp;enet1; ethernet2 = \u0026amp;enet2; ethernet3 = \u0026amp;enet3; }; .... fman0: fman@400000 { #address-cells = ; #size-cells = ; cell-index = ; compatible = \u0026#34;fsl,fman\u0026#34;; ranges = ; reg = ; interrupts = \u0026lt; 96 2 0 0 16 2 1 1\u0026gt;; clocks = \u0026lt;\u0026amp;hwac1\u0026gt;; clock-names = \u0026#34;fman0-clk\u0026#34;; /* FDT dummyMdio driver : memac0*/ enet0: ethernet@e0000 { compatible = \u0026#34;fsl,fman-memac\u0026#34;; reg = ; phy-handle = \u0026lt;\u0026amp;dummy_phy0\u0026gt;; phy-connection-type = \u0026#34;sgmii\u0026#34;; cell-index = ; local-mac-address = [ 00 04 9F 03 0A 5C ]; }; /* FDT dummyMdio driver : memac1*/ enet1: ethernet@e2000 { .... }; .... }; ","date":"2024-10-22","externalUrl":null,"permalink":"/bsp/how-to-integrate-u-boot-and-vxworks-7/","section":"Bsps","summary":"\u003cp\u003e\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e是美国风河公司制作的一个实时操作系统，\u003ca href=\"https://www.vxworks.net/bsp/834-u-boot-and-vxworks-7-integration\" target=\"_blank\"\u003eU-Boot\u003c/a\u003e是一个广为人知的通用启动加载器，它是嵌入式系统加电后运行的最早的代码。U-Boot通常被用于嵌入式系统，比如PowerPC或者ARM设备，这些设备上没有X86的BIOS。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e介绍 \n    \u003cdiv id=\"%E4%BB%8B%E7%BB%8D\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E4%BB%8B%E7%BB%8D\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e尽管VxWorks可以有它自己的bootloader(VxWorks Bootrom或者Bootapp)，U-Boot具有更多的功能，如果硬件板子已经提供了U-Boot的支持，那我们更有道理去直接使用它。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003eU-boot : http://www.denx.de/wiki/U-Boot/WebHome \n\nVxWorks : https://www.windriver.com/products/vxworks/ \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在最新的VxWorks版本(\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003eVxWorks 7\u003c/a\u003e)已经比过去的VxWorks版本(我在VxWorks 6.9上遇到了好多问题)更加简单地和U-Boot集成了。\u003c/p\u003e","title":"U-Boot和VxWorks 7的集成","type":"bsp"},{"content":"","date":"2024-10-22","externalUrl":null,"permalink":"/tags/vxworks-7/","section":"Tags","summary":"","title":"VxWorks 7","type":"tags"},{"content":"","date":"2024-10-22","externalUrl":null,"permalink":"/tags/rtos/","section":"Tags","summary":"","title":"RTOS","type":"tags"},{"content":"VxWorks操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），是嵌入式开发环境的关键组成部分。\n嵌入式操作系统VxWorks简介 # 良好的持续能力、高性能的内核以及友好的用户开发环境，在嵌入式实时操作系统领域占据一席之地。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的F-16、FA-18战斗机、B-2隐形轰炸机和爱国者导弹上，甚至连1997年在火星表面登陆的火星探测器上也使用到了VxWorks。\n实时操作系统和分时操作系统的区别 # 从操作系统能否满足实时性要求来区分，可把操作系统分成分时操作系统和实时操作系统。\n分时操作系统按照相等的时间片调度进程轮流运行，分时操作系统由调度程序自动计算进程的优先级，而不是由用户控制进程的优先级。这样的系统无法实时响应外部异步事件。\n实时操作系统能够在限定的时间内执行完所规定的功能，并能在限定的时间内对外部的异步事件作出响应。分时系统主要应用于科学计算和一般实时性要求不高的场合。实时性系统主要应用于过程控制、数据采集、通信、多媒体信息处理等对时间敏感的场合。\n实时操作系统的结构 # 在计算的早期开发的操作系统的最原始的结构形式是一个统一的实体(monolithic)。在这样的系统中，提供的不同功能的模块，如处理器管理、内存管理、输入输出等，通常是独立的。然而他们在执行过程中并不考虑其他正在使用中的模块，各个模块都以相同的时间粒度运行。\n由于现代实时环境需要许多不同的功能，以及在这样的环境中存在的并发活动所引起的异步性和非确定性，操作系统变得更加复杂。所以早期操作系统的统一结构的组织已经被更加精确的内部结构所淘汰。层次结构的起点————内核\n操作系统的最好的内部结构模型是一个层次性的结构，最低层是内核。这些层次可以看成为一个倒置的金字塔，每一层都建立在较低层的功能之上。 内核仅包含一个操作系统执行的最重要的低层功能。正象一个统一结构的操作系统，内核提供了在高层软件与下层硬件之间的抽象层。然而，内核仅提供了构造操作系统其他部分所需的最小操作集。\n拥有其它名字的内核 # 许多商用化的内核支持的功能远强于上面所列的要求。在这方面，他们不是真正的内核，而更象一个小的统一结构的操作系统。因为他们包含简单的内存分配、时钟管理、甚至一些输入输出系统调用的功能。\n这种分类不仅仅是在语义上的争论，在这篇文章的后面章节将说明限制内核功能和油画这些功能的重要性。\nVxWorks的特点 # 可靠性 # 操作系统的用户希望在一个工作稳定，可以信赖的环境中工作，所以操作系统的可靠性是用户首先要考虑的问题。而稳定、可靠一直是VxWorks的一个突出优点。自从对中国的销售解禁以来，VxWorks以其良好的可靠性在中国赢得了越来越多的用户。\n实时性 # 实时性是指能够在限定时间内执行完规定的功能并对外部的异步事件作出响应的能力。实时性的强弱是以完成规定功能和作出响应时间的长短来衡量的。\nVxWorks的实时性做得非常好，其系统本身的开销很小，进程调度、进程间通信、中断处理等系统公用程序精练而有效，它们造成的延迟很短。VxWorks提供的多任务机制中对任务的控制采用了优先级抢占（Preemptive Priority Scheduling）和轮转调度（Round-Robin Scheduling）机制，也充分保证了可靠的实时性，使同样的硬件配置能满足更强的实时性要求，为应用的开发留下更大的余地。\n可裁减性 # 用户在使用操作系统时，并不是操作系统中的每一个部件都要用到。例如图形显示、文件系统以及一些设备驱动在某些嵌入系统中往往并不使用。\nVxWorks由一个体积很小的内核及一些可以根据需要进行定制的系统模块组成。VxWorks内核最小为8kB，即便加上其它必要模块，所占用的空间也很小，且不失其实时、多任务的系统特征。由于它的高度灵活性，用户可以很容易地对这一操作系统进行定制或作适当开发，来满足自己的实际应用需要。\n对一个实时内核的要求 # 一个实时操作系统内核需满足许多特定的实时环境所提出的基本要求，这些包括：\n多任务：由于真实世界的事件的异步性，能够运行许多并发进程或任务是很重要的。多任务提供了一个较好的对真实世界的匹配，因为它允许对应于许多外部事件的多线程执行。系统内核分配CPU给这些任务来获得并发性。 抢占调度：真实世界的事件具有继承的优先级，在分配CPU的时候要注意到这些优先级。基于优先级的抢占调度，任务都被指定了优先级， 在能够执行的任务（没有被挂起或正在等待资源）中，优先级最高的任务被分配CPU资源。换句话说，当一个高优先级的任务变为可执行态，它会立即抢占当前正在运行的较低优先级的任务。 快速灵活的任务间的通信与同步：在一个实时系统中，可能有许多任务作为一个应用的一部分执行。系统必须提供这些任务间的快速且功能强大的通信机制。内核也要提供为了有效地共享不可抢占的资源或临界区所需的同步机制。 方便的任务与中断之间的通信：尽管真实世界的事件通常作为中断方式到来，但为了提供有效的排队、优先化和减少中断延时，我们通常希望在任务级处理相应的工作。所以需要杂任务级和中断级之间存在通信。 性能边界：一个实时内核必须提供最坏情况的性能优化，而非针对吞吐量的性能优化。我们更期望一个系统能够始终以50微妙执行一个函数，而不期望系统平均以10微妙执行该函数，但偶尔会以75微妙执行它。 特殊考虑：由于对实时内核的要求的增加，必须考虑对内核支持不断增加的复杂功能的要求。这包括多进程处理，Ada和对更新的、功能更强的处理器结构如RISC的支持。 VxWorks内核：Wind # VxWorks操作系统是一种功能最全的现在可以获得的独立于处理器的实时系统。然而，VxWorks是带有一个相当小的真正微内核的层次结构。内核仅提供多任务环境、进程间通信和同步功能。这些功能模块足够支持VxWorks在较高层次所提供的丰富的性能的要求。 通常内核操作对于用户是不可见的。应用程序为了实现需要内核参与的任务管理和同步使用一些系统调用，但这些调用的处理对于调用任务是不可见的。应用程序仅链接恰当的VxWorks例程（通常使用VxWorks的动态链接功能），就象调用子程序一样发出系统调用。这种接口不象有些系统需要一个笨拙的跳转表接口，用户需要通过一个整数来指定一个内核功能调用。\n多任务 # 内核的基本功能是提供一个多任务环境。多任务使得许多程序在表面上表现为并发执行，而事实上内核是根据基本的调度算法使他们分段执行。每个明显独立的程序被成为一个任务。每个任务拥有自己的上下文，其中包含在内核调度使该任务执行的时候它所看到的CPU环境和系统资源。\n任务状态和状态迁移 # 内核维护系统中的每个任务的当前状态。状态迁移发生在应用程序调用内核功能服务的时候。下面定义了wind内核状态：\n就绪态\u0026mdash;-一个任务当前除了CPU不等待任何资源 阻塞态\u0026mdash;-一个任务由于某些资源不可获得而被阻塞 延迟态\u0026mdash;-一个任务睡眠一段时间 挂起态\u0026mdash;-主要用于调试的一个辅助状态，挂起禁止任务的执行 任务被创建以后进入挂起态，需要通过特定的操作使被创建的任务进入就绪态，这一操作执行速度很快，使应用程序能够提前创建任务，并以一种快捷的方式激活该任务。\n实时系统的一个任务可有多种状态，其中最基本的状态有四种：\n就绪态：任务只等待系统分配CPU资源； 悬置态：任务需等待某些不可利用的资源而被阻塞； 休眠态：如果系统不需要某一个任务工作，则这个任务处于休眠状态； 延迟态：任务被延迟时所处状态； 当系统函数对某一任务进行操作时，任务从一种状态迁移到另一状态。处于任一状态的任务都可被删除。\n状态迁移调用\n就绪态 ----\u0026gt; 悬置态semTake()/msgQReceive() 就绪态 ----\u0026gt; 延迟态taskDelay() 就绪态 ----\u0026gt; 休眠态taskSuspend() 悬置态 ----\u0026gt; 就绪态semGive()/msgQSend() 悬置态 ----\u0026gt; 休眠态taskSuspend() 延迟态 ----\u0026gt; 就绪态expireddelay 延迟态 ----\u0026gt; 休眠态taskSuspend() 休眠态 ----\u0026gt; 就绪态taskResume()/taskActivate() 休眠态 ----\u0026gt; 悬置态taskResume() 休眠态 ----\u0026gt; 延迟态taskResume() 调度控制 # 多任务需要一个调度算法分配CPU给就绪的任务。在VxWorks中默认的调度算法是基于优先级的抢占调度，但应用程序也可以选择使用时间片轮转调度。\n基于优先级抢占调度：基于优先级的抢占调度，每个任务被指定一个优先级，内核分配CPU给处于就绪态的优先级最高的任务。调度采用抢占的方式，是因为当一个优先级高于当前任务的任务变为就绪态时，内核将立即保存当前任务的上文，并切换到高优先级任务的上文。VxWorks有从0到255共256个优先级。在创建的时候任务被指定一个优先级，在任务运行的过程中可以动态地修改优先级以便跟踪真实世界的事件优先级。外部中断被指定优先于任何任务的优先级，这样能够在任何时候抢占一个任务。\n时间片轮转：基于优先级抢占调度可以扩充时间片轮转调度。时间片轮转调度允许在相同优先级的处于就绪态的任务公平地共享CPU。没有时间片轮转调度，当有多个任务在同一优先级共享处理器时，一个任务可能独占CPU，不会被阻塞直到被一个更高优先级的任务抢占，而不给同一优先级的其他任务运行的机会。如果时间片轮转被使能，执行任务的时间计数器在每个时钟滴答递增。当指定的时间片耗尽，计数器会被清零，该任务被放在同一优先级任务队列的队尾。加入特定优先级组的新任务被放在该组任务的队尾，并将运行计数器初始化为零。\n基本的任务函数 # 用于状态控制的基本任务函数包括一个任务的创建、删除、挂起和唤醒。一个任务也可以使自己睡眠一个特定的时间间隔不去运行。许多其他任务例程提供由任务上下文获得的状态信息。这些例程包括访问一个任务当前处理器寄存器控制。\n高效的任务管理：\n多任务，具有256个优先级。 具有优先级排队和循环调度。 快速的、确定性的上下文切换。 任务删除问题 # wind内核提供防止任务被意外删除的机制。通常，一个执行在临界区或访问临界资源的任务要被特别保护。我们设想下面的情况：一个任务获得一些数据结构的互斥访问权，当它正在临界区内执行时被另一个任务删除。由于任务无法完成对临界区的操作，该数据结构可能还处于被破坏或不一致的状态。而且，假想任务没有机会释放该资源，那麽现在其他任何任务现在就不能获得该资源，资源被冻结了。\n任何要删除或终止一个设定了删除保护的任务的任务将被阻塞。当被保护的任务完成临界区操作以后，它将取消删除保护以使自己可以被删除，从而解阻塞删除任务。\n正如上面所展示的，任务删除保护通常伴有互斥操作。\n这样，为了方便性和效率，互斥信号量包含了删除保护选项。（参见\u0026quot;互斥信号量\u0026quot;）\n任务间通信 # 为了提供完整的多任务系统的功能，wind内核提供了一套丰富的任务间通信与同步的机制。这些通信功能使一个应用中各个独立的任务协调他们的活动。\n灵活的任务间通讯：\n三种信号灯：二进制、计数、有优先级继承特性的互斥信号灯。 消息队列。 套接字（Socket）。 共享内存。 信号（Signals） 微秒级的中断处理。 支持POSIX 1003.1b实时扩展标准。 支持多种物理介质及标准的、完整的TCP/IP网络协议。 灵活的引导方式。支持从ROM、flash、本地盘（软盘或硬盘）或网络引导。 支持多处理器并行处理。 快速灵活的I/O系统。 支持MS-DOS和RT－11文件系统。 支持本地盘，flash，CD-ROM的使用。 完全符合ANSI C标准。 多个系统调用。 共享地址空间 # wind内核的任务间通信机制的基础是所有任务所在的共享地址空间。通过共享地址空间，任务能够使用共享数据结构的指针自由地通信。管道不需要映射一块内存区到两个互相通信任务的寻址空间。\n不幸的是，共享地址空间具有上述优点的同时，带来了未被保护内存的重入访问的危险。UNIX操作系统通过隔离进程提供这样的保护，但同时带来了对于实时操作系统来说巨大的性能损失。\n互斥操作 # 当一个共享地址空间简化了数据交换，通过互斥访问避免资源竞争就变为必要的了。用来获得一个资源的互斥访问的许多机制仅在这些互斥所作用的范围上存在差别。实现互斥的方法包括禁止中断、禁止任务抢占和通过信号量进行资源锁定。\n中断禁止：最强的互斥方法是屏蔽中断。这样的锁定保证了对CPU的互斥访问。这种方法当然能够解决互斥的问题，但它对于实时是不恰当的，因为它在锁定期间阻止系统响应外部事件。长的中断延时对于要求有确定的响应时间的应用来说是不可接受的。\n抢占禁止：禁止抢占提供了强制性较弱的互斥方式。 当前任务运行的过程中不允许其他任务抢占，而中断服务程序可以执行。这也可能引起较差的实时响应，就象被禁止中断一样，被阻塞的任务会有相当长时间的抢占延时，就绪态的高优先级的任务可能会在能够执行前被强制等待一段不可接受的时间。为避免这种情况，在可能的情况下尽量使用信号量实现互斥。\n互斥信号量：信号量是用于锁定共享资源访问的基本方式。不象禁止中断或抢占，信号量限制了互斥操作仅作用于相关的资源。一个信号量被创建来保护资源。VxWorks的信号量遵循Dijkstra的P()和V()操作模式。\n当一个任务请求信号量，P()， 根据在发出调用时信号量的置位或清零的状态， 会发生两种情况。如果信号量处于置位态， 信号量会被清零，并且任务立即继续执行。如果信号量处于清零态，任务会被阻塞来等待信号量。\n当一个任务释放信号量，V()，会发生几种情况。如果信号量已经处于置位态，释放信号量不会产生任何影响。如果信号量处于清零态且没有任务等待该信号量，信号量只是被简单地置位。如果信号量处于清零态且有一个或多个任务等待该信号量，最高优先级的任务被解阻塞，信号量仍为清零态。\n通过将一些资源与信号量关联，能够实现互斥操作。当一个任务要操作资源，它必须首先获得信号量。只要任务拥有信号量，所有其他的任务由于请求该信号量而被阻塞。当一个任务使用完该资源，它释放信号量，允许等待该信号量的另一个任务访问该资源。\nWind内核提供了二值信号量来解决互斥操作所引起的问题。 这些问题包括资源拥有者的删除保护，由资源竞争引起的优先级逆转。\n删除保护：互斥引起的一个问题会涉及到任务删除。在由信号量保护的临界区中，需要防止执行任务被意外地删除。删除一个在临界区执行的任务是灾难性的。资源会被破坏，保护资源的信号量会变为不可获得，从而该资源不可被访问。通常删除保护是与互斥操作共同提供的。由于这个原因，互斥信号量通常提供选项来隐含地提供前面提到的任务删除保护的机制。\n优先级逆转/优先级继承： 优先级逆转发生在一个高优先级的任务被强制等待一段不确定的时间以便一个较低优先级的任务完成执行。考虑下面的假设：\nT1，T2和T3分别是高、中、低优先级的任务。T3通过拥有信号量而获得相关的资源。当T1抢占T3，为竞争使用该资源而请求相同的信号量的时候，它被阻塞。如果我们假设T1仅被阻塞到T3使用完该资源为止，情况并不是很糟。毕竟资源是不可被抢占的。然而，低优先级的任务并不能避免被中优先级的任务抢占，一个抢占的任务如T2将阻止T3完成对资源的操作。这种情况可能会持续阻塞T1等待一段不可确定的时间。这种情况成为优先级逆转，因为尽管系统是基于优先级的调度，但却使一个高优先级的任务等待一个低优先级的任务完成执行。\n互斥信号量有一个选项允许实现优先级继承的算法。优先级继承通过在T1被阻塞期间提升T3的优先级到T1解决了优先级逆转引起的问题。这防止了T3，间接地防止T1，被T2抢占。通俗地说，优先级继承协议使一个拥有资源的任务以等待该资源的任务中优先级最高的任务的优先级执行。当执行完成，任务释放该资源并返回到它正常的或标准的优先级。因此，继承优先级的任务避免了被任何中间优先级的任务抢占。\n同步 # 信号量另一种通常的用法是用于任务间的同步机制。在这种情况下，信号量代表一个任务所等待的条件或事件。最初，信号量是在清零态。一个任务或中断通过置位该信号量来指示一个事件的发生。等待该信号量的任务将被阻塞直到事件发生、该信号量被置位。一旦被解阻塞，任务就执行恰当的事件处理程序。信号量在任务同步中的应用对于将中断服务程序从冗长的事件处理中解放出来以缩短中断响应时间是很有用的。\n消息队列 # 消息队列提供了在任务与中断服务程序或其他任务间交换变长消息的一种较低层的机制。这种机制在功能上类似于管道，但有较少的开销。\n管道、套接字、远程过程调用和更多高层的VxWorks机制提供任务间通信的更高层的抽象，包括管道、TCP/IP套接字、远程过程调用和更多。为了保持裁减内核为仅包含足够支持高层功能的一个最小函数集的设计目标，这些特性都是基于上面描述的内核同步方式的。\n内核设计的优点 # wind内核的一个重要的设计特性是最小的抢占延时。其他的主要设计的优点包括史无前例的可配置性，对不可预见的应用需求的可扩展性，在各种微处理器应用开发中的移植性。\n最小的抢占延时 # 正如前面所讨论的，禁止抢占是获得代码临界资源互斥操作的通常手段。这种技巧的不期望的负面影响是高的抢占延时，这可以通过尽量使用信号量实现互斥和保持临界区尽量紧凑被减小。但即使广泛地使用信号量也不能解决所有的可能导致抢占延时的根源。内核本身就是一个导致抢占延时的根源。为了理解其原因，我们必须更好地理解内核所需的互斥操作。\n内核级和任务级 # 在任何多任务系统中，大量的应用是发生在一个或多个任务的上下文。然而，有些CPU时间片不在任何任务的上下文。这些时间片发生在内核改变内部队列或决定任务调度。在这些时间片中，CPU在内核级执行，而非任务级。\n为了内核安全地操作它的内部的数据结构，必须有互斥操作。内核级没有相关的任务上下文，内核不能使用信号量保护内部链表。内核使用工作延期作为实现互斥的方式。当有内核参与时，中断服务程序调用的函数不是被直接激活，而是被放在内核的工作 队列中。内核完成这些请求的执行而清空内核工作队列。\n当内核正在执行已经被请求服务时系统将不响应到达内核的函数调用。可以简单地认为内核状态类似于禁止抢占。如前面所讨论的，抢占延时在实时系统中是不期望有的，因为它增加了对于会引起应用任务重新调度的事件的响应时间.\n管操作系统在内核级（此时禁止抢占）完全避免消耗时间是不可能的，但减少这些时间是很重要的。这是减少由内核执行的函数的数量的主要原因， 也是不采用统一结构的系统设计方式的原因。例如，有一种流行的实时操作系统的每个函数都是在内核级执行。这意味着当一个低优先级的任务在执行分配内存、获得任务信息的函数时所有高优先级的任务被禁止抢占。\n一个最小的内核 # 已经说明了一个最小内核的优点和构造高层操作系统功能的必要功能，我们使用这些操作原语来执行一个传统的内核级功能，而在VxWorks中作为任务级功能执行，内存管理。 在这个例子中，考虑用户可调用的子例程malloc， 用于分配所请求大小的内存区并返回一个指向该内存区的指针。假定空闲内存区是通过搜索一个空闲内存块的队列找到的，一个信号量必须被用来保护这个非抢占多用户资源。分配内存的操作如下：\n获得互斥信号量 搜索空闲内存块链表 释放互斥信号量 值得注意的是搜索一个足够大的空闲内存块的可能的冗长的时间是发生在调用任务的上下文中。这是可以被高优先级的任务抢占的（除了信号量调用的这段执行时间）。\n在一个标准的统一结构的实时内核中，内存分配例程操作如下：\n进入内核 搜索空闲内存块链表 退出内核 整个内存分配发生在内核级，任务抢占被禁止如果高优先级的任务在此时变为就绪态，它必须等待直到内核为低优先级的任务完成内存分配。有些操作系统甚至在这段市时间禁止中断。\n任务级操作系统服务 # Wind River System的实时操作系统，VxWorks，显示了这样设计的一个最小内核是能够满足需求的。VxWorks是现在能够获得的独立于任何处理器的、拥有相当小内核的、功能完全的层次结构的实时操作系统。\nVxWorks在内核之上提供了大量的功能。它包括内存管理，一个完整的BSD4.3网络包，TCP/IP，网络文件系统（NFS），远程过程调用（RPC），UNIX兼容的链接加载模块，C语言的解释界面，各种类型的定时器，性能监测组件，调试工具，额外的通信工具如管道、信号和套接字，I/O和文件系统，和许多功能例程。这些都不是运行在内核级，所以不会禁止中断或任务抢占。\n可配置性 # 实时应用有多种内核需求。没有哪个内核有一个用来满足每种需求的很好的设计折衷。然而，一个内核可以通过配置来调整特定的性能特性，裁减实时系统来最好地适应一个应用的要求。不可预见的内核配置性以用户可选择的内核排队算法的形式提供给应用。\n排队策略 # VxWorks中的排队库是独立于使用他们的内核队列功能而执行的，这样提供了将来增加新的排队方式的灵活性。\n在VxWorks中有各种内核队列。就绪队列是一个按优先级索引的所有等待调度的任务队列。滴答队列用于定时功能。信号量是一个等待信号量的被阻塞任务的链表。活动队列是一个系统中所有任务的一个先进先出（FIFO）的链表。这些队列中的每个队列都需要一个不同的排队算法。这些算法不是被内嵌在内核中，而是被抽取到一个自治的、可转换的排队库中。这种灵活的组织形式是满足特殊的配置需求的基础。\n可扩展性 # 支持不可预见的内核扩展的能力与以有功能的可配置性是同样重要的。简单的内核接口和互斥方法使内核级功能扩展相当容易； 在某些情况下，应用可以仅利用内核钩子函数来实现特定的扩展。\n内部钩子函数 # 为了不修改内核而能够向系统增加额外的任务相关的功能，VxWorks提供了任务创建、切换和删除的钩子函数。这些允许在任务被创建、 上下文切换和任务被删除的时候额外的例程被调用执行。这些钩子函数可以利用任务上下文中的空闲区创建wind内核的任务特性。\n未来考虑 # 有许多系统函数现在变得越来越重要，而且会影响到内核设计时的抢占延时。尽管涉及这些问题一个完整的讨论超出了本文的范围，但值得简单地提一下。 RISC/CISC设计一个独立于CPU的操作系统一直是一个挑战。随着新的RSIC（精简指令集）处理器变得很流行，这些难度也加大了。为了在RISC环境下有效地执行，内核和操作系统需要有执行不同策略的灵活性。\n例如，考虑在任务切换时内核执行的例程。在CISC（复杂指令集，如680x0或80x86）CPU，内核为每个任务存储一套完整的寄存器，在运行任务的时候将这些寄存器换入换出。在一个RISC机器上，这样是不合理的，因为涉及到太多的寄存器。所以内核需要一个更精密复杂的策略，如为任务缓存寄存器，允许应用指定一些寄存器给特殊的任务。\n移植性 # 为了使wind内核在他们出现的结构上能够运行，需要有一个可移植的内核版本。这使移植是可行的，但不是最优化的。\n多处理 # 支持紧耦合的多处理需求要求实时内核的内部功能包含，在理想情况下，在远端请求内核调用，如从一个处理器到另一个处理器。这就要涉及到信号量调用（为处理器间同步）和任务调用（为了控制另一个CPU上的任务）。这种复杂性无疑会增加内核级功能调用的开销，但是许多服务如对象标识可以在任务级执行。在多处理系统中保持一个最小内核的优点是处理器之间的互锁可以有较好的时间粒度。大的内核将在内核级消耗额外的时间，仅能获得粗糙的互锁时间粒度。\nAda # Ada语言为实时系统设计者提供了象聚会机制这样的任务原语。异常处理、任务终止、终止替换和聚会都将潜在地影响内核设计。这些操作可以由前面讨论的任务和同步机制构造，为了保持减小抢占延时的设计目标，许多工作能够在任务级执行。\n实时内核的重要尺度 # 许多性能特性被用来比较以有的实时内核，这些包括：\n快速的任务上下文切换\u0026mdash;-由于实时系统的多任务的特性，系统能够快速地从一个任务切换到另一个任务是很重要的。在分时系统中，如UNIX，上下文切换是在ms级。Wind内核执行原始上下文切换只用17us。 最小的同步开销\u0026mdash;-因为同步是实现资源互斥访问的基本方法，这些操作所引起的开销最小化是很重要的。在VxWorks中，请求和释放二值信号量仅用8us。 最小的中断延时\u0026mdash;-因为外部世界来的事件通常以中断的形式到来，操作系统快速的处理这些中断是很重要的。内核在操作一些临界数据结构的时候必须禁止中断。为了减小中断延时，必须使这些时间最小化。Wind内核的中断延时小于10us。 抢占延时对性能指标的影响 # 当许多的实时解决方案被提交给应用工程师时， 性能指标对于评估供应商的产品变得越来越重要。不象上下文切换和中断延时，抢占延时很难测量。所以它很少在说明中被提及。但是考虑到当内核通常禁止上下文切换会长达数百微妙，而声称一个50us的固定长度（与任务个数无关）的上下文切换时间是毫无意义的。除了很难测量外，抢占延时可能会削弱许多性能指标的有效性。\nWind内核通过减小内核的大小来尽量减小抢占延时。 包含繁多功能的内核必将引起长的抢占延时。\n任务管理 # 任务是代码运行的一个映象，从系统的角度看，任务是竞争系统资源的最小运行单元。任务可以使用或等待CPU、I/O设备及内存空间等系统资源，并独立于其它任务，与它们一起并发运行（宏观上如此）。VxWorks内核使任务能快速共享系统的绝大部分资源，同时有独立的上下文来控制个别线程的执行。\n任务结构 # 多任务设计能随时打断正在执行着的任务，对内部和外部发生的事件在确定的时间里作出响应。VxWorks实时内核Wind提供了基本的多任务环境。从表面上来看，多个任务正在同时执行，实际上，系统内核根据某一调度策略让它们交替运行。系统调度器使用任务控制块的数据结构（简记为TCB)来管理任务调度功能。任务控制块用来描述一个任务，每一任务都与一个TCB关联。TCB包括了任务的当前状态、优先级、要等待的事件或资源、任务程序码的起始地址、初始堆栈指针等信息。调度器在任务最初被激活时以及从休眠态重新被激活时，要用到这些信息。\n此外，TCB还被用来存放任务的\u0026quot;上下文\u0026quot;（context)。任务的上下文就是当一个执行中的任务被停止时，fPW\u0026quot;教T供\\aI管h;`所要保存的所有信息。在任务被重新执行时，必须要恢复上下文。通常，上下文就是计算机当前的状态，也即各个寄存器的内容。如同在发生中断所要保存的内容一样。当发生任务切换时，当前运行的任务的上下文被存入TCB，将要被执行的任务的上下文从它的TCB中取出，放入各个寄存器中。于是转而执行这个任务，执行的起点是前次它在运行时被中止的位置。\nVxWorks中，内存地址空间不是任务上下文的一部分。所有的代码运行在同一地址空间。如每一任务需各自的内存空间，需可选产品VxVMI的支持。\n任务调度策略 # 多任务调度须采用一种调度算法来分配CPU给就绪态任务。Wind内核采用基于优先级的抢占式调度法作为它的缺省策略，同时它也提供了轮转调度法。\n基于优先级的抢占式调度，它具有很多优点。这种调度方法为每个任务指定不同的优先级。没有处于悬置或休眠态的最高优先级任务将一直运行下去。当更高优先级的任务由就绪态进入运行时，系统内核立即保存当前任务的上下文，切换到更高优先级的任务。\n多任务调度须采用一种调度算法来分配CPU给就绪态任务。Wind内核采用基于优先级的抢占式调度法作为它的缺省策略，同时它也提供了轮转调度法。\n基于优先级的抢占式调度，它具有很多优点。这种调度方法为每个任务指定不同的优先级。没有处于悬置或休眠态的最高优先级任务将一直运行下去。当更高优先级的任务由就绪态进入运行时，系统内核立即保存当前任务的上下文，切换到更高优先级的任务。\nWind内核划分优先级为256 级（0~255）。优先级0为最高优先级，优先级255为最低。当任务被创建时，系统根据给定值分配任务优先级。然而，优先级也可以是动态的，它们能在系统运行时被用户使用系统调用taskPrioritySet()来加以改变，但不能在运行时被操作系统所改变。\n轮转调度法分配给处于就绪态的每个同优先级的任务一个相同的执行时间片。时间片的长度可由系统调用KernelTimeSlice()通过输入参数值来指定。很明显，每个任务都有一运行时间计数器，任务运行时每一时间滴答加1。一个任务用完时间片之后，就进行任务切换，停止执行当前运行的任务，将它放入队列尾部，对运行时间计数器置零，并开始执行就绪队列中的下一个任务。当运行任务被更高优先级的任务抢占时，此任务的运行时间计数器被保存，直到该任务下次运行时。\n抢占禁止 # Wind内核可通过调用taskLock()和taskUnlock（）来使调度器起作用和失效。当一个任务调用taskLock()使调度器失效，任务运行时没有基于优先级的抢占发生。然而，如果任务被阻塞或是悬置时，调度器从就绪队列中取出最高优先级的任务运行。当设置抢占禁止的任务解除阻塞，再次开始运行时，抢占又被禁止。这种抢占禁止防止任务的切换，但对中断处理不起作用。\n异常处理 # 程序代码和数据的出错，如非法命令、总线或地址错误、被零除等。VxWorks异常处理包，一般是将引起异常的任务休眠，保存任务在异常出错处的状态值。内核和其它任务继续执行。用户可借助Tornado开发工具，查看当前任务状态，从而确定被休眠的任务。\n任务管理 # VxWorks内核的任务管理提供了动态创建、删除和控制任务的功能，具体实现通过如下一些系统调用：\ntaskSpawn()创建（产生并激活）新任务 taskInit() 初始化一个新任务 taskActivate() 激活一个已初始化的任务 taskName() 由任务ID号得到任务名 taskNameToId（）由任务名得到任务ID号 taskPriorityGet()获得任务的优先级 taskIsSuspended()检查任务是否被悬置 taskIsReady()检查任务是否准备运行 taskTcb()得到一个任务控制块的指针 taskDelete() 中止指定任务并自由内存（仅任务堆栈和控制块） taskSafe() 保护被调用任务 taskSuspend()悬置一个任务 taskResume() 恢复一个任务 taskRestart()重启一个任务 taskDelay()延迟一个任务 VxWorks中的多任务通讯机制 # 通常，在一个实时系统中，存在着多个并发的任务来协同实现系统的功能，操作系统必须为这些任务提供快速且功能强大的通信机制。在VxWorks系统中，有信号量（semaphore）、消息队列（message queue）、管道（pipe）、事件（event）等通信机制，对一个系统开发人员来说，如何合理地使用这些通信机制，是系统能够长期高效、可靠、安全运行的关键。\n信号量（semaphore） # 在VxWorks种，信号量是提供任务间同步和互斥的最快速、开销最小的机制，VxWorks有三种不同类型的信号量：\n二进制信号量：可用于2个任务之间的同步工作。如任务A必须在任务B完成特定的动作以后才能进行，在这种情况下，任务A可以获取信号量而处于阻塞（pend）状态，任务B在完成特定的动作后释放该信号量。一般来说二进制信号量适用于一对一的任务之间的同步。 互斥信号量：主要用于任务之间共享数据区的互斥保护，具有优先级反转、安全删除、递归等特性。在有2个或2个以上的任务共享一个数据区的时候，必须使用互斥机制进行保护。 计数器信号量：类似于二进制信号量，但是对信号量的释放、获取有计数功能，而二进制信号量则只有0和1两种状态。 VxWorks提供了一组管理信号量的函数接口供开发者使用，包括创建、删除、获取、释放等。 虽然信号量具有快速、开销小的优点，但也有它的局限性，首先它无法提供额外的信息，其次对于一个任务必须与多个任务进行同步的情况，信号量也无能为力。因此在许多场合，信号量必须与其它通信机制配合使用来完成任务之间的通信。\n消息队列（message queue） # 消息队列是VxWorks提供的单个CPU中的任务之间通信的主要机制之一。消息队列允许基于FIFO或基于任务优先级方式排队消息，一个消息队列的消息数目和消息长度可以由开发者在创建消息队列时指定。在理论上，VxWorks允许多个任务向同一个消息队列发送消息，或者从同一个消息队列接收消息；而在实际应用中，一般来说只有一个任务从消息队列接收消息，有一个或多个任务发送消息，即这个消息队列有多个生产者，而只有一个消费者。消息队列时单向的，对于需要进行双向通信的两个任务，必须使用两个消息队列。消息队列非常适合于Client-Server结构的任务之间的通信，如图一，任务Client1和Client2都需要任务Server的服务，它们通过消息队列“Request Queue”向任务Server发送请求和参数，任务Server处理请求后分别通过“Reqpy Queue 1”和“Reqpy Queue 2”向这两个任务返回结果。\n在VxWorks中，消息队列是一种代价比较高的一种通信机制，因此在使用时应该使消息的长度尽量短，而且应避免在需要十分频繁通信的场合使用消息队列。另外消息队列中的消息是排队的，即使是完全相同的消息，后面的消息也不会覆盖前面的消息。\n管道（pipe） # 在VxWorks中，管道是一种通过虚拟的I/O设备来实现的消息队列通信机制。使用函数pipeDevCreate()和pipeDevDelete()来生成和删除管道，管道一经生成后，任务之间就可以使用标准I/O操作主要是read()和write()进行通信。管道的优点在于它是一个I/O设备，与标准的VxWorks I/O一样，可以使用select机制，而有了select机制，一个任务很方便地使用多个异步I/O设备，如任务要处理同时从串口、管道、socket接收到的数据，就可以使用select。\n事件（event） # 在5.5版本之前，VxWorks并没有事件这一通信机制。事件(event) 最早出现在pSOS实时操作系统中，在风河公司收购了pSOS之后，从VxWorks 5.5之后，加入了事件机制，并在pSOS事件的基础上做了增强和改进。事件可用于任务和中断服务程序ISR之间、任务和任务之间、任务和VxWorks资源之间进行通信。任务用函数eventReceive()来接收它关心的事件，用eventSend()来向另一个任务发送事件。\nVxWorks资源主要是指信号量和消息队列，一个任务要想从VxWorks资源接收到事件，必须先进行注册(register)，那么当资源处于FREE状态时，会向注册过的任务发送一个事件。对于每一个VxWorks资源，最多只允许有一个任务注册。如对于消息队列，任务可以使用函数msgQEvStart()来进行注册，那么当有消息到达这个消息队列而又没有任务等待这个消息队列时，会向这个任务发送一个事件，表明消息队列可用。而对于信号量，可以用函数semEvStart()来进行注册。但必须注意的是，一个任务接收到资源发送的事件后，并不能保证这个任务能获取该资源，如获取信号量、从消息队列接收到消息。\n在VxWorks中，每一个任务都有一个32位事件寄存器，其中高8位由VxWorks系统保留，开发者可以使用低24位，其每一位表示一种事件，而事件的意义则完全有任务来定义，因此对于不同的任务，相同的位可能有不同的意义。而VxWorks并不对事件进行计数，而只表示该事件发生过，这与消息队列不同，因此接收事件的任务并不能知道接受到的事件发生的次数。\n事件非常适合于一个任务必须与多个任务进行通信的场合，如任务A必须同时与任务B、任务C、任务D进行通信，其中任务B通过消息队列向任务A发送数据，其发送频率较低，它要求任务A必须及时进行处理；而任务C则只是向任务A指示一种状态，但频率很高；而任务D用来通知任务A释放动态申请的资源，并停止运行。在这种场合，事件机制能很好地解决问题。\n总结 # 在VxWorks中，任务之间高效、经济地通信对整个系统的性能有很大的影响。一般来说并不能使用一种单一的通信机制就能解决问题，而是需要同时使用多种通信机制。另外，对任务的合理划分，又能简化任务之间的通信。总之，开发者必须通过足够的实践，才能充分利用VxWorks的各种通信机制，设计出高效、可靠的实时系统\n","date":"2024-10-22","externalUrl":null,"permalink":"/bsp/embedded-os-vxworks-introduction/","section":"Bsps","summary":"\u003cp\u003e\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eRTOS\u003c/a\u003e），是嵌入式开发环境的关键组成部分。\u003c/p\u003e\n\n\n\u003ch1 class=\"relative group\"\u003e嵌入式操作系统VxWorks简介 \n    \u003cdiv id=\"%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fvxworks%E7%AE%80%E4%BB%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fvxworks%E7%AE%80%E4%BB%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003e良好的持续能力、高性能的内核以及友好的用户开发环境，在嵌入式实时操作系统领域占据一席之地。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的F-16、FA-18战斗机、B-2隐形轰炸机和爱国者导弹上，甚至连1997年在火星表面登陆的火星探测器上也使用到了VxWorks。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e实时操作系统和分时操作系统的区别 \n    \u003cdiv id=\"%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BA%E5%88%AB\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BA%E5%88%AB\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e从操作系统能否满足实时性要求来区分，可把操作系统分成分时操作系统和实时操作系统。\u003c/p\u003e","title":"嵌入式实时操作系统VxWorks简介","type":"bsp"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/series/app/","section":"Series","summary":"","title":"App","type":"series"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/vip/","section":"Tags","summary":"","title":"VIP","type":"tags"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/vsb/","section":"Tags","summary":"","title":"VSB","type":"tags"},{"content":"本文介绍了VxWorks 7系统下自启动应用程序的四种方法。\n在开始之前我们先来了解一下一些vxworks的一些基础知识。\nVxWorks工程 # VxWorks 7 可以创建以下几种典型的工程：\nProject Type Output VSB (VxWorks Source Build) .a VIP (VxWorks Image Project) DKM (Downloadable Kernel Module) .out RTP(Real-Time Process) .vxe VSB: 基于某个特定的bsp，根据支持的cpu架构，把vxworks内核源码编译成静态库。 注意这里这是只是把内核源码编译成库，供后续创建的VIP工程使用，并不会产生任何的映像文件。 内核公共代码预先编译成库，也可以加速用户VIP工程的编译速度。另外也说明，如果你修改了内核代码，你需要重新编译VSB工程才会生效。 VIP: VxWorks 用户自定义的VxWorks映像工程。 把用户选择的各种内核组件(使用CDF文件描述)，根据vxworks的启动顺序编译链接起来，得到常用的VxWorks映像。 各种内核组件在VSB工程中已经预先编译好，供VIP工程挑选使用。 DKM: VxWorks内核态应用程序。可加载的内核模块，类似如linux下的ko文件。 对于跑在内核态的用户代码，即可以添加到VIP工程中，也可以使用DKM工程独立成内核模块。 在VxWorks启动完成后，使用`ld \u003c xxx.out`的命令来动态加载。 RTP: VxWorks用户态应用程序。 跑在用户态的用户代码，使用RTP工程编译成.vxe文件。 在vxworks启动完成后，使用“rtp exec xxx.vxe”命令来执行。 VxWorks shell # VxWorks拥有自己的命令行交互工具kernel shell，比较特殊的是shell有两种模式分别支持两种解析器：C Interpreter和Command Interpreter。\nMode 提示符 模式切换 C Interpreter -\u0026gt; 使用“cmd”命令切换到Command Interpreter模式 Command Interpreter # 使用“C”命令切换到C Interpreter模式 C Interpreter 设计的目的是用来监控、调试内核代码。它最大的特点是可以直接调用函数名来执行，非常方便调试 Command Interpreter 设计的目的是用来启动、监控、调试用户态的RTP应用程序。它提供了很多专门的调试命令，类似于linux shell 详细描述可以参考文档： “installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf” 内核应用程序(DKM)自启动 # 需求来源 # 用户有两个内核应用程序，已经使用DKM工程编译成了.out文件：pruss_eth.out，s24_DriveRotationCiA402.out，在shell的C Interpreter模式下可以动态加载和运行：\nstep 1: 手工加载pruss_eth.out，并调用prussStart()函数进行运行：\n-\u0026gt; ld \u0026lt; /mmc1:1/pruss_eth.out value = 541560848 = 0x20479010 -\u0026gt; prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 step 2: 手工加载s24_DriveRotationCiA402.out，并调用main()函数进行运行：\n-\u0026gt; ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerStop. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerCreate. Warning: module 0x20479874 holds reference to undefined symbol MasterStartPIClientProcessor. Warning: module 0x20479874 holds reference to undefined symbol MasterStopPIClientProcessor. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. value = 0 = 0x0 -\u0026gt; main Initialize Master ... Create Master instance ... Get network adapter name ... Network adapters count: Attach Master to adapter \u0026#39;kpa_pruss0\u0026#39; ... Create Configurator instance to load configuration ... Loading ENI \u0026#39;/master.xml\u0026#39; ... ... 用户希望在做硬件测试或者正式产品时，以上两步骤能够自动运行。\n方案1(失败) # VxWorks支持使用INCLUDE_RTP_APPL_INIT_BOOTLINE组件来配置系统启动时自动运行C Interpreter格式的脚本，我们尝试使用此方法来实现系统启动时自加载DKM并运行。\n首先我们在VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_BOOTLINE选项： VIP工程的SCRIPT_DEFAULT选项设置为我们需要运行的脚本“/mmc1:1/autorun_c.sh”： ** SCRIPT_DEFAULT **主要的作用是设置default bootline中的startup script选项。VxWorks在INCLUDE_RTP_APPL_INIT_BOOTLINE使能的情况下，会在启动阶段执行bootline中startup script选项描述的C脚本：\nusrRoot() -\u0026gt; usrToolsInit() -\u0026gt; usrShellInit(): void usrShellInit (void) { shellLibInit (); /* This component includes the shell core files. */ shellHistLibInit (); /* This component provides the histSave() and histLoad() functions for the C interpreter. */ dbgLibInit (DEBUG_STACK_TRACE_BUF_SIZE);/* This component includes the primary interactive functions for VxWorks. * The following facilities are provided: task breakpoints, task single-stepping, * symbolic disassembly, symbolic task stack tracing. */ vxdbgRtpLibInit (); /* This component includes the process debugging library. */ ledModeRegister (emacsLedLibInit); /* This component provides an editing mode similar to the Emacs editor. */ shellInterpRegister (shellInterpCInit); /* This component provides the C interpreter for the kernel shell. */ shellInterpRegister (shellInterpCmdInit); /* This component provides the command interpreter for the kernel shell. */ usrShellCmdInit (); /* The kernel shell commands initialization sequence */ /* (1) 从bootline参数的startupScript选项中解析出脚本名，并执行 */ usrStartupScript (startupScriptFieldSplit (sysBootParams.startupScript)); /* Including this component results in the execution of a kernel shell script at VxWorks startup. */ usrShell (); /* This component includes the target-resident kernel shell, * which is spawned as a task. Any function that is invoked from the kernel shell, * rather than spawned, runs in the shell\u0026#39;s context. * The task name for a shell on the console is \u0026#34;tShell0\u0026#34;. * The kernel shell is re-entrant, and more than one shell task can run at a time (hence the number suffix). * In addition, if a user logs in remotely (using rlogin or telnet) to a VxWorks target, * the name reflects that fact as well. For example, \u0026#34;tShellRem1\u0026#34;. * The \u0026#34;tShell\u0026#34; basename is configurable, see the VxWorks 7 Kernel Shell User\u0026#39;s Guide. */ } 如果使用VxWorks自带的bootloader，可以在boot cmd命令行中配置bootline的startup script选项:\nstartup script (s) : /mmc1:1/autorun_c.sh 但是我们目前方案的bootloader使用的是uboot，所以我们只需配置好默认bootline中的startup script选项。\nautorun_c.sh脚本中的内容非常简单，就是我们手工执行时需要键入的4条指令： ld \u0026lt; /mmc1:1/pruss_eth.out prussStart ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out main 运行结果： 实际的运行结果，发现VxWorks启动后，卡住几分钟才能执行到autorun_c.sh脚本： Adding 11197 symbols for standalone. // vxworks启动完成 // 卡住了好几分钟 Waiting for device to mount // autorun_c.sh脚本才得到执行 Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541474832 = 0x20464010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 ... 初步分析卡住的原因： 在“usrRoot() -\u0026gt; usrToolsInit() -\u0026gt; usrShellInit()-\u0026gt;usrStartupScript()”这个时间点执行“/mmc1:1/autorun_c.sh”脚本时，“/mmc1:1/”设备并没有mount好，usrStartupScript()函数中重试机制在不停的重新尝试执行，但是这个重试机制又会阻止“/mmc1:1/”的mount进程，所以会卡死很久。\n因为没有深入研究VxWorks的初始化流程，我们先尝试使用别的方法，后续有时间可以研究卡住问题的解决方案。\n方案2(成功) # VxWorks执行自定义内核程序，还有一个公共的入口在usrAppInit()函数当中，函数调用关系如下：\nvoid usrRoot (char *pMemPoolStart, unsigned memPoolSize) { ... usrToolsInit (); // 这里进行usrShellInit()-\u0026gt;usrStartupScript()的调用 usrAppInit (); ... } 可以看到usrAppInit()调用点比方案1的usrShellInit()调用点靠后，我们尝试在usrAppInit()里面实现内核模块DKM的自加载。\n我们在usrAppInit()函数中直接调用usrStartupScript()来运行\u0026quot;/mmc1:1/autorun_c.sh\u0026quot;脚本： void usrAppInit (void) { #ifdef\tUSER_APPL_INIT USER_APPL_INIT;\t/* for backwards compatibility */ #endif /* TODO: add application specific code here */ ioDefPathSet(\u0026#34;/mmc1:1/\u0026#34;); usrStartupScript(\u0026#34;/mmc1:1/autorun_c.sh\u0026#34;); } autorun_c.sh脚本的内容还是和方案1一样： ld\u0026lt;/mmc1:1/pruss_eth.out prussStart ld\u0026lt;/mmc1:1/s24_DriveRotationCiA402.out main 运行结果： VxWorks启动后，没有卡住的现象，autorun_c.sh脚本能迅速得到执行：\nAdding 11197 symbols for standalone. Waiting for device to mount .-\u0026gt; Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541536272 = 0x20473010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStop. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerCreate. Warning: module 0x204735b8 holds reference to undefined symbol MasterStartPIClientProcessor. Warning: module 0x204735b8 holds reference to undefined symbol MasterStopPIClientProcessor. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. value = 0 = 0x0 Done executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;. -\u0026gt; 但细心的同学会发现autorun_c.sh脚本中的4条指令只执行了3条，最后一条\u0026quot;main\u0026quot;指令并没有得到执行，但是在shell下手工键入又可以得到执行，这是为什么呢？\n首先怀疑main这个符号和其他人重名，造成调用失败。但是查找符号表后，发现并没有重名情况：\n-\u0026gt; -\u0026gt; cmd [vxWorks *]# [vxWorks *]# lookup main ipnet_radvd_main 0x001b8988 text main 0x00c9976c text (s24_DriveRotationCiA402.out) ipftpc_cmd_main 0x001325bc text vxbClkDomainInit 0x003d5c00 text tiClkDomainDrv 0x004cf6fc data vxbClkDomainRegister 0x003d4af8 text ipnet_flow_spec_domain 0x0015bc78 text ipftps_main 0x001374a8 text __dataset__driver_tiClkDomainDrv 0x004ddaa4 data [vxWorks *]# 进一步分析运行log发现一个情况：同样是加载.out文件，ld \u0026lt; /mmc1:1/pruss_eth.out的返回值0x20473010其实是pruss_eth.out 加载后的MODULE ID，但是ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out的返回值却为0:\n-\u0026gt; cmd [vxWorks *]# module MODULE NAME MODULE ID GROUP # TEXT START DATA START BSS START --------------- ---------- ---------- ---------- ---------- ---------- pruss_eth.out 0x20473010 1 0x00b59010 0x00b5b0e4 NO SEGMENT s24_DriveRotati 0x20473874 2 0x00b5c010 0x00cade18 0x00cb4064 于是怀疑ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out的加载过程出错，autorun_c.sh脚本执行中断，造成了随后的main命令没有得到运行。 在ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out我们可以看到有几个人符号没有得到解析的告警，虽然module还是加载上了还能手工执行，但是这个出错可能会中断脚本的运行：\n... Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. 沿着这个分析方向，让用户编译一份没有符号解析错误的.out文件进行测试。\n没有符号解析错误的.out，运行结果： 用户编译了一份没有符号解析错误的newmaster.out，来替换之前出错的s24_DriveRotationCiA402.out，autorun_c.sh脚本中的4条指令能够完美的得到执行：\nAdding 11197 symbols for standalone. Waiting for device to mount .-\u0026gt; Instantiating /sd0:2 as rawFs, device = 0x50001 Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541560848 = 0x20479010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 ld \u0026lt; /mmc1:1/newmaster.out value = 541562996 = 0x20479874 = \u0026#39;t\u0026#39; main Initialize Master ... Create Master instance ... Get network adapter name ... Network adapters count: Attach Master to adapter \u0026#39;kpa_pruss0\u0026#39; ... Create Configurator instance to load configuration ... Loading ENI \u0026#39;/master.xml\u0026#39; ... Starting Master ... Master started. Start EtherCAT frames exchange ... Requesting Operational Master state ... ... 用户应用程序(RTP)自启动 # 在文档\u0026quot;installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf\u0026quot;的\u0026quot;Automatic Execution of RTP Applications\u0026quot;章节，对RTP自启动的几种方法有着详细的描述，感兴趣可以自行学习。\n我们以vxsim架构下的一个RTP程序为例来详细介绍这些方法。\n首先我们创建了基于vxsim架构的VSB、VIP工程，并且创建了一个测试使用的RTP工程。测试代码的内容很简单：\nrtp.c: #include \u0026lt;stdio.h\u0026gt; int main ( int\targc,\t/* number of arguments */ char * argv[]\t/* array of arguments */ ) { int i = 0; printf(\u0026#34;Hello World!\\nFrom your RTP application...\\nBy pwl.\\n\u0026#34;); while(i\u0026lt;3){ i++; taskDelay(100); printf(\u0026#34;%d ticks\\n\u0026#34;, i*100); } return 0; } 我们使用这个RTP工程编译出TestSimRtp.vxe映像文件。\n手工执行TestSimRtp.vxe文件有两种方式：\n在C shell下执行： -\u0026gt; -\u0026gt; rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; value = 941088064 = 0x3817dd40 = \u0026#39;@\u0026#39; -\u0026gt; Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; 在Command shell下执行： -\u0026gt; -\u0026gt; cmd [vxWorks *]# rtp exec host:D:/pwl_workspace/TestSimRtp.vxe Launching process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; ... Process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; (process Id = 0x38cfb358) launched. Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks [vxWorks *]# 自动执行方式1 (RTP_APPL_INIT_STRING) # 首先在vxsim的VIP工程中的配置选项中，使能INCLUDE_RTP_APPL_INIT_STRING选项： 配置其中的RTP_APPL_INIT_STRING参数： RTP_APPL_INIT_STRING参数的具体内容为：\n\u0026#34;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 这个字符串的详细语法可以参考 \"installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf\"中的\"Application Startup String Syntax\"小节。 启动vxworks simulator，查看运行结果，成功自动运行： Loading symbol table from host:D:/pwl_workspace/TestSimVip/default/vxWorks.sym ...done -\u0026gt; Spawning RTP: host:D:/pwl_workspace/TestSimRtp.vxe Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; 自动执行方式2 (RTP_APPL_INIT_BOOTLINE) # VxWorks支持使用INCLUDE_RTP_APPL_INIT_BOOTLINE组件来配置系统启动时自动运行C Interpreter格式的脚本，我们尝试使用此方法来实现系统启动时自动运行RTP程序。\n首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_BOOTLINE选项： vxsim VIP工程的SCRIPT_DEFAULT选项设置： startup script具体的配置如下：\n\u0026#34;host:D:/pwl_workspace/autorun_c.sh#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 需要注意的是startup script中可以配置两种不同的自启动方式，上述的参数可以分成两部分：\n“host:D:/pwl_workspace/autorun_c.sh”这部分配置的是VxWorks在启动阶段执行一个C Interpreter格式的脚本。autorun_c.sh脚本的具体内容如下： rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 需要特别注意的是，这里调用的是C Interpreter格式的脚本，后面的`RTP_APPL_INIT_CMD_SHELL_SCRIPT`方式调用的是Command Interpreter格式的脚本。 \u0026ldquo;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026quot;这部分配置的语法和INCLUDE_RTP_APPL_INIT_STRING选项一样。 上述参数分别运行了一次TestSimRtp.vxe，所以TestSimRtp.vxe会被运行两次。\n启动vxworks simulator，查看运行结果，成功自动运行两次： Loading symbol table from host:D:/pwl_workspace/TestSimVip/default/vxWorks.sym ...done // (1) 第一次执行，使用autorun_c.sh脚本的执行 Executing startup script \u0026#39;host:D:/pwl_workspace/autorun_c.sh\u0026#39;... rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; value = 950476976 = 0x38a720b0 Hello World! From your RTP application... By pwl. Done executing startup script \u0026#39;host:D:/pwl_workspace/autorun_c.sh\u0026#39;. // (2) 第二次执行，使用\u0026#34;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34;选项配置的执行 -\u0026gt; Spawning RTP: host:D:/pwl_workspace/TestSimRtp.vxe Hello World! From your RTP application... By pwl. 100 ticks 100 ticks 200 ticks 200 ticks 300 ticks 300 ticks -\u0026gt; 自动执行方式3 (RTP_APPL_INIT_CMD_SHELL_SCRIPT) # 首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_CMD_SHELL_SCRIPT选项，并配置其中的RTP_APPL_CMD_SCRIPT_FILE参数： 参数的具体内容为：\u0026ldquo;host:D:/pwl_workspace/autorun_cmd.sh\u0026rdquo; 系统启动时自动运行配置的Command Interpreter格式的脚本autorun_cmd.sh,autorun_cmd.sh脚本的具体内容为：\nrtp exec host:D:/pwl_workspace/TestSimRtp.vxe 启动vxworks simulator，查看运行结果，成功自动运行： -\u0026gt; Executing startup script \u0026#39;host:D:/pwl_workspace/autorun_cmd.sh\u0026#39;... rtp exec host:D:/pwl_workspace/TestSimRtp.vxe Launching process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; ... Process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; (process Id = 0x38d3a890) launched. Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks Done executing startup script \u0026#39;host:D:/pwl_workspace/autorun_cmd.sh\u0026#39;. -\u0026gt; 自动执行方式4 (RTP_APPL_USER) # 首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_USER选项： 在INCLUDE_RTP_APPL_USER选项被使能以后，vxworks启动时会调用usrRtpAppInit.c文件中的usrRtpAppInit()函数。我们可以在此函数中加入自己的rtp启动代码： void usrRtpAppInit (void) { /* TODO - add your own application launch code here */ /* (1) 使用代码调用rtpSpawn()函数来运行TestSimRtp.vxe文件 */ char * vxeName = \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34;; char * argv[5]; RTP_ID rtpId = NULL; /* set the application\u0026#39;s arguments */ argv[0] = vxeName; argv[1] = NULL; argv[2] = NULL; argv[3] = NULL; argv[4] = NULL; /* Spawn the RTP. No environment variables are passed */ if ((rtpId = rtpSpawn (vxeName, argv, NULL, 220, 0x10000, 0, 0)) == NULL) { printf (\u0026#34;Impossible to start %s application \u0026#34;, vxeName); } } 启动vxworks simulator，查看运行结果，成功自动运行： -\u0026gt; Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; ","date":"2024-10-20","externalUrl":null,"permalink":"/app/vxworks-7-app-auto-boot-method/","section":"Apps","summary":"\u003cp\u003e本文介绍了VxWorks 7系统下自启动应用程序的四种方法。\u003c/p\u003e\n\u003cp\u003e在开始之前我们先来了解一下一些vxworks的一些基础知识。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eVxWorks工程 \n    \u003cdiv id=\"vxworks%E5%B7%A5%E7%A8%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#vxworks%E5%B7%A5%E7%A8%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eVxWorks 7 可以创建以下几种典型的工程：\u003c/p\u003e","title":"VxWorks 7自启动应用程序的四种方法","type":"app"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/arinc429/","section":"Tags","summary":"","title":"ARINC429","type":"tags"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/avionics/","section":"Tags","summary":"","title":"Avionics","type":"tags"},{"content":"航电激励器在民用飞机航电系统半物理仿真平台中起着至关重要的作用。在航电系统开发过程中，航电激励器向航电仿真设备提供的激励数据是进行航电系统仿真验证的基础，所以在航电激励数据的获取和处理中，航电激励器的设计与实现是极其重要的一个环节。该文基于VxWorks 系统设计一款航电激励器，对航电激励器进行总体设计，从激励数据获取模块、激励数据转换模块等方面进行研究，完成软件设计以及硬件平台搭建。通过对设计的航电激励器进行仿真验证，实现飞机模拟飞行数据的获取以及航电系统中ARINC429 总线数据和AFDX 总线数据的相互转换，使得激励数据在传输过程中具有良好的实时性。\n航空电子系统是指飞机上所有电子系统的总和，其仿真验证在航电系统的设计与研发过程中起着重要的作用，对航电系统进行仿真验证，可以有效地降低航电系统集成过程中存在的风险和成本，缩短开发周期。在进行各种仿真验证时，需要航电激励器向仿真组件提供激励信号，所以航电激励器提供的激励信号的准确性和稳定性将对仿真验证的结果产生直接影响。\n目前，航电激励器主要是基于Windows 系统开发的，在数据传输的实时性、可靠性等方面略显不足，并且在向仿真组件提供激励信号时，常出现数据的延时、丢包等问题。VxWorks 系统采用优先级抢占和轮转调度的任务调度机制，具有良好的实时性。基于VxWorks系统开发的航电激励器可以很好地解决Windows 系统下开发的航电激励器所存在的不足。因此本文设计一款基于VxWorks 系统的航电激励器，能够为航电系统提供具有实时性、可靠性的激励信号。\n航电激励器总体设计 # 本文设计的航电激励器由软件和硬件两部分构成。软件部分主要包括激励数据获取模块和数据转换模块。其中，激励数据获取模块通过以太网接收飞机模拟飞行过程中的飞行数据，这些数据包括飞机的位置、姿态、通信导航系统的工作频率等参数。航电激励器数据转换模块主要实现AFDX 总线数据、ARINC429 总线数据的编解码，完成ARINC429 总线数据与AFDX 总线数据相互转化，并向各航电仿真组件传输激励数据。AFDX 数据总线协议见文献[4]，ARINC429 总线协议见文献[5]。硬件部分主要完成VxWorks 系统在MPC8270 上的移植，建立硬件开发平台。航电激励器总体设计如图1所示。\n图1 航电激励器总体设计 航电激励器的软件设计 # 激励数据获取模块 # 从实际应用的角度出发，激励数据获取模块所获取的激励数据主要来源于飞行仿真软件中的飞行数据，通过激励数据获取模块实现激励数据获取模块与飞行仿真软件的内存共享，从而实现飞行数据的实时获取。\n通过以太网发送的飞行数据格式是基于UDP 数据包格式，数据获取模块接收到1 帧数据包后，首先对该数据包的帧头进行判断，其次判断数据帧校验位的正确与否，然后对校验位正确的数据包进行确定报文类型并解析出报文所包含的信息。通过设计ARINC429 总线数据字编码的接口函数，调用ARINC429 数据字编码接口，对将UDP 格式的数据包解码后的飞行数据信息进行编码得到激励数据对应的ARINC429 数据字，确定周期和通道后将该ARINC429 数据字输出到航电仿真组件。激励数据获取流程如图2 所示。\n激励数据转换模块 # AFDX 总线凭借着卓越的传输效率以及高可靠性等特点，广泛地应用于B-787、A380 等先进机型中。目前，航电系统主干网络通常采用AFDX 总线将机载各个子系统连接成一个高效可靠的整体，而飞机很多子系统仍采用比较成熟的ARINC429 总线。因此，本文设计航电激励器的数据转换模块，实现AFDX 总线激励信号与ARINC429 总线激励信号之间的相互转换。上述两种数据格式总线信号的相互转换是互为逆过程，本节将通过设计航电激励器收发ARINC429 总线数据字对应的AFDX 总线数据包，从而实现总线数据间的编码转换。\n图2 激励数据获取流程 对AFDX 总线数据进行分析，将AFDX 总线报文设计成可由多个“消息”（Message）拼接而成的通用格式。AFDX 总线中的每条“消息”都分为三个部分，便于将ARINC429 总线的数据字结构填入AFDX 数据帧结构中。MsgType 指的是对消息类型的编码；LengthInBytes是表示PayLoad 字段的长度；PayLoad 是AFDX 总线的承载内容。PayLoad 长度是可变的，其具体承载的信息格式由MsgType 的值决定。AFDX 总线报文中消息的通用格式如图3 所示。\n图3 AFDX 总线报文中消息的通用格式 硬件平台设计 # VxWorks 系统为开发者提供大量板级支持包BSP（Board Support Packet），便于简化BSP 移植工作。在进行BSP 移植之前，需要根据CPU 型号选择相应BSP 包，同时参考硬件数据调整BSP 相关配置信息。在完成BSP 配置后，建立新的VxWorks Image Project 工程，同时创建映像所需的文件。\n图4 ARINC429 总线数据转换为AFDX 数据包 VxWorks 模块是根据目标板卡的性能需求完成VxWorks 系统内核模块的配置。VxWorks 系统映像经编译生成后，对FTP 环境进行调试。通过运行Workbench 3.3 中的FTP Server，完成FTP 环境中的用户信息配置。完成以上配置后，将VxWorks 映像下载至目标板卡MPC8270 运行。至此完成VxWorks 系统平台的搭建。\n航电激励器的仿真与测试 # 在航电激励器的功能实现之后需要对航电激励器进行验证测试，主要针对航电激励器所能提供的航电激励信号进行测试，即ARINC429 总线激励信号、AFDX 总线激励信号以及激励信号实时性测试。\nARINC429 总线激励信号数据测试 # 航电激励器对接收到的ARINC429 总线激励信号进行数据符合性测试。在飞行数据中获取其中5 种激励数据进行测试，如表1 所示。将航电激励器的一条ARINC429 输出通道连接到ARINC429 总线分析仪，将表1 中激励数据统一设置发送周期为200 ms，输出到ARINC429 总线分析仪。总线分析仪所显示的激励数据如图5 所示。\n表1 激励参量取值 图5 ARINC429 总线分析仪显示的数据 将表1 数据信息与图5 显示结果进行对比，结果显示二者所包含的数据信息一致，航电激励器输出的ARINC429 总线激励信号满足数据符合性要求。\nAFDX 总线激励信号数据测试 # 激励数据获取模块选择飞行仿真软件中模拟飞机的VOR1 频率飞行数据进行验证，激励数据VOR1 频率的相关信息如表2 所示。航电激励器将AFDX 总线激励信号通过AFDX 板卡发送至交换机，通过Wireshark 抓取AFDX 数据包，对应抓取数据包为十六进制数：3800DC84，结果如图6 所示。通过对比验证，航电激励器输出的AFDX 总线激励信号中的数据信息与ARINC429 负载数据一致，航电激励器实现了ARINC429 总线激励信号转化为AFDX 信号的预期功能。\n表2 航电激励器输出AFDX 信号配置信息 图6 VOR1 频率数据包 激励信号实时性测试 # 本文依靠VxWorks 系统的独特优势保证数据获取的实时性。“实时”并不意味着是“快”，而是指系统响应的时间确定性。时间确定性具体体现为航电激励器能否完全按照规定周期对激励信号进行收发。首先基于VxWorks 系统下的航电激励器对ARINC429 总线激励信号进行输出，配置输出数据信息如表3 所示。\n表3 输出ARINC429 总线信号配置信息 配置信息完成后，在低速（12.5 Kb/s）模式下，航电激励器输出ARINC429 总线激励信号，通过示波器对ARINC429 的8 号输出通道进行测试。同理，利用Windows 系统下的航电激励器完成表3 配置数据的发送，测试出每对相邻波形起始点间的时间间隔，测试结果如表4 所示。\n经测试验证，基于VxWorks 系统的航电激励器输出的2 组连续信号波形时间间隔与设定发送周期相同，为精确的30.00 ms，没有产生抖动延迟。然而Windows 系统下航电激励器在进行激励信号的周期性发送时，连续的两个信号间的时间间隔容易产生时间抖动，每组波形间的时间延迟在1 ms 以上。综上所述，基于VxWorks系统的航电激励器在时间确定性效果方面更能满足航电系统仿真验证的高实时性需求。\n表4 单通道时间确定性测试结果 ms 结 论 # 本文基于VxWorks 系统，以MPC8270 为目标平台，提出航电激励器的总体设计方案并进行详细设计，最终实现AFDX 总线数据与ARINC429 总线数据的相互转换，为实际的航电仿真系统提供良好的激励数据。通过仿真测试表明所设计的航电激励器达到预期效果。\n（本文来源于《现代电子技术》，作者：孙毅刚，迟文强，作者单位：中国民航大学航空工程学院）\n全文下载地址: 基于VxWorks系统的航电激励器设计与实现\n","date":"2024-10-20","externalUrl":null,"permalink":"/app/design-and-implementation-of-avionics-exciter-based-on-vxworks-system/","section":"Apps","summary":"\u003cp\u003e航电激励器在民用飞机航电系统半物理仿真平台中起着至关重要的作用。在航电系统开发过程中，航电激励器向航电仿真设备提供的激励数据是进行航电系统仿真验证的基础，所以在航电激励数据的获取和处理中，航电激励器的设计与实现是极其重要的一个环节。该文基于\u003ca href=\"https://www.vxworks6.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e 系统设计一款航电激励器，对航电激励器进行总体设计，从激励数据获取模块、激励数据转换模块等方面进行研究，完成软件设计以及硬件平台搭建。通过对设计的航电激励器进行仿真验证，实现飞机模拟飞行数据的获取以及航电系统中\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eARINC429\u003c/a\u003e 总线数据和AFDX 总线数据的相互转换，使得激励数据在传输过程中具有良好的实时性。\u003c/p\u003e\n\u003cp\u003e航空电子系统是指飞机上所有电子系统的总和，其仿真验证在航电系统的设计与研发过程中起着重要的作用，对航电系统进行仿真验证，可以有效地降低航电系统集成过程中存在的风险和成本，缩短开发周期。在进行各种仿真验证时，需要航电激励器向仿真组件提供激励信号，所以航电激励器提供的激励信号的准确性和稳定性将对仿真验证的结果产生直接影响。\u003c/p\u003e\n\u003cp\u003e目前，航电激励器主要是基于Windows 系统开发的，在数据传输的实时性、可靠性等方面略显不足，并且在向仿真组件提供激励信号时，常出现数据的延时、丢包等问题。VxWorks 系统采用优先级抢占和轮转调度的任务调度机制，具有良好的实时性。基于VxWorks系统开发的航电激励器可以很好地解决Windows 系统下开发的航电激励器所存在的不足。因此本文设计一款基于VxWorks 系统的航电激励器，能够为航电系统提供具有实时性、可靠性的激励信号。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e航电激励器总体设计 \n    \u003cdiv id=\"%E8%88%AA%E7%94%B5%E6%BF%80%E5%8A%B1%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E8%88%AA%E7%94%B5%E6%BF%80%E5%8A%B1%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e本文设计的航电激励器由软件和硬件两部分构成。软件部分主要包括激励数据获取模块和数据转换模块。其中，激励数据获取模块通过以太网接收飞机模拟飞行过程中的飞行数据，这些数据包括飞机的位置、姿态、通信导航系统的工作频率等参数。航电激励器数据转换模块主要实现AFDX 总线数据、ARINC429 总线数据的编解码，完成ARINC429 总线数据与AFDX 总线数据相互转化，并向各航电仿真组件传输激励数据。AFDX 数据总线协议见文献[4]，ARINC429 总线协议见文献[5]。硬件部分主要完成VxWorks 系统在MPC8270 上的移植，建立硬件开发平台。航电激励器总体设计如图1所示。\u003c/p\u003e","title":"基于VxWorks 系统的航电激励器设计与实现","type":"app"},{"content":" VxWorks The Leading RTOS The industry's most widely deployed RTOS. VxWorks has been used to ensure the security, safety, and reliability you need to design and build mission-critical embedded systems that simply must work.\n支持OCI容器，一键升级 # VxWorks是全球首个且唯一一个利用容器部署应用程序的实时操作系统。\n最新版的VxWorks 7支持OCI容器，利用类似IT的传统技术，即可更高效更优质地开发和部署智能边缘软件，且不会影响确定性和性能。了解为何研究机构VDC再次将VxWorks评为最佳边缘部署实时操作系统。\nVxWorks：现代设计，面向未来，始终实时 # VxWorks是一款确定性、基于优先级的抢占式实时操作系统，具有超低延迟和最小抖动。为应对未来挑战，VxWorks采用可升级架构，助力企业快速响应不断变化的市场需求，确保技术永不过时。\nVxWorks是唯一支持C ++ 17、Boost、Rust、Python、pandas等开发语言的实时操作系统，搭载边缘优化和OCI兼容的容器引擎，便于企业灵活选择开发语言、工具和技术，创新机要事务。\n超高信息安全 # 智能边缘中各设备、系统和行业的需求各不相同，信息安全威胁也在不断演进。VxWorks可提供超高信息安全，助力企业构建安全设备，应对当前威胁；此外，其灵活的模块化设计可积极应对未来挑战。同时，风河的检索数据库包括MITRE公共漏洞和暴露（CVEs）信息，可为客户提供最新的信息安全补丁。\nVxWorks 653和VxWorks 认证版 # VxWorks满足EN 50128、IEC 61508、ISO 26262、DO-178C和ED-12C等严苛的功能安全认证要求，可用于最具挑战性的安全关键型应用程序，且更便捷、更具成本效益。\n板级支持包 # 风河与芯片供应商和硬件制造商保持有密切联系，可提供开箱即用的板卡支持包，支持Arm、Power、英特尔和RISC-V等各类架构，降低企业开发成本，减少兼容组件的采购时间，可为客户预留更多时间用于产品研发。\n","date":"2024-10-04","externalUrl":null,"permalink":"/","section":"VxWorks Overview","summary":"\u003cblockquote\u003e\nVxWorks The Leading RTOS\u003c/br\u003e\nThe industry's most widely deployed RTOS.\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.vxworks6.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e has been used to ensure the security, safety, and reliability you need to design and build mission-critical embedded systems that simply must work.\u003c/p\u003e","title":"VxWorks Overview","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]