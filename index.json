
[{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/series/app/","section":"Series","summary":"","title":"App","type":"series"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/app/","section":"Apps","summary":"","title":"Apps","type":"app"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/vip/","section":"Tags","summary":"","title":"VIP","type":"tags"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/vsb/","section":"Tags","summary":"","title":"VSB","type":"tags"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/vxworks/","section":"Tags","summary":"","title":"VxWorks","type":"tags"},{"content":"本文介绍了VxWorks 7系统下自启动应用程序的四种方法。\n在开始之前我们先来了解一下一些vxworks的一些基础知识。\nVxWorks工程 # VxWorks 7 可以创建以下几种典型的工程：\nProject Type Output VSB (VxWorks Source Build) .a VIP (VxWorks Image Project) DKM (Downloadable Kernel Module) .out RTP(Real-Time Process) .vxe VSB: 基于某个特定的bsp，根据支持的cpu架构，把vxworks内核源码编译成静态库。 注意这里这是只是把内核源码编译成库，供后续创建的VIP工程使用，并不会产生任何的映像文件。 内核公共代码预先编译成库，也可以加速用户VIP工程的编译速度。另外也说明，如果你修改了内核代码，你需要重新编译VSB工程才会生效。 VIP: VxWorks 用户自定义的VxWorks映像工程。 把用户选择的各种内核组件(使用CDF文件描述)，根据vxworks的启动顺序编译链接起来，得到常用的VxWorks映像。 各种内核组件在VSB工程中已经预先编译好，供VIP工程挑选使用。 DKM: VxWorks内核态应用程序。可加载的内核模块，类似如linux下的ko文件。 对于跑在内核态的用户代码，即可以添加到VIP工程中，也可以使用DKM工程独立成内核模块。 在VxWorks启动完成后，使用`ld \u003c xxx.out`的命令来动态加载。 RTP: VxWorks用户态应用程序。 跑在用户态的用户代码，使用RTP工程编译成.vxe文件。 在vxworks启动完成后，使用“rtp exec xxx.vxe”命令来执行。 VxWorks shell # VxWorks拥有自己的命令行交互工具kernel shell，比较特殊的是shell有两种模式分别支持两种解析器：C Interpreter和Command Interpreter。\nMode 提示符 模式切换 C Interpreter -\u0026gt; 使用“cmd”命令切换到Command Interpreter模式 Command Interpreter # 使用“C”命令切换到C Interpreter模式 C Interpreter 设计的目的是用来监控、调试内核代码。它最大的特点是可以直接调用函数名来执行，非常方便调试 Command Interpreter 设计的目的是用来启动、监控、调试用户态的RTP应用程序。它提供了很多专门的调试命令，类似于linux shell 详细描述可以参考文档： “installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf” 内核应用程序(DKM)自启动 # 需求来源 # 用户有两个内核应用程序，已经使用DKM工程编译成了.out文件：pruss_eth.out，s24_DriveRotationCiA402.out，在shell的C Interpreter模式下可以动态加载和运行：\nstep 1: 手工加载pruss_eth.out，并调用prussStart()函数进行运行：\n-\u0026gt; ld \u0026lt; /mmc1:1/pruss_eth.out value = 541560848 = 0x20479010 -\u0026gt; prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 step 2: 手工加载s24_DriveRotationCiA402.out，并调用main()函数进行运行：\n-\u0026gt; ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerStop. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerCreate. Warning: module 0x20479874 holds reference to undefined symbol MasterStartPIClientProcessor. Warning: module 0x20479874 holds reference to undefined symbol MasterStopPIClientProcessor. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. value = 0 = 0x0 -\u0026gt; main Initialize Master ... Create Master instance ... Get network adapter name ... Network adapters count: Attach Master to adapter \u0026#39;kpa_pruss0\u0026#39; ... Create Configurator instance to load configuration ... Loading ENI \u0026#39;/master.xml\u0026#39; ... ... 用户希望在做硬件测试或者正式产品时，以上两步骤能够自动运行。\n方案1(失败) # VxWorks支持使用INCLUDE_RTP_APPL_INIT_BOOTLINE组件来配置系统启动时自动运行C Interpreter格式的脚本，我们尝试使用此方法来实现系统启动时自加载DKM并运行。\n首先我们在VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_BOOTLINE选项： VIP工程的SCRIPT_DEFAULT选项设置为我们需要运行的脚本“/mmc1:1/autorun_c.sh”： ** SCRIPT_DEFAULT **主要的作用是设置default bootline中的startup script选项。VxWorks在INCLUDE_RTP_APPL_INIT_BOOTLINE使能的情况下，会在启动阶段执行bootline中startup script选项描述的C脚本：\nusrRoot() -\u0026gt; usrToolsInit() -\u0026gt; usrShellInit(): void usrShellInit (void) { shellLibInit (); /* This component includes the shell core files. */ shellHistLibInit (); /* This component provides the histSave() and histLoad() functions for the C interpreter. */ dbgLibInit (DEBUG_STACK_TRACE_BUF_SIZE); /* This component includes the primary interactive functions for VxWorks. The following facilities are provided: task breakpoints, task single-stepping, symbolic disassembly, symbolic task stack tracing. */ vxdbgRtpLibInit (); /* This component includes the process debugging library. */ ledModeRegister (emacsLedLibInit); /* This component provides an editing mode similar to the Emacs editor. */ shellInterpRegister (shellInterpCInit); /* This component provides the C interpreter for the kernel shell. */ shellInterpRegister (shellInterpCmdInit); /* This component provides the command interpreter for the kernel shell. */ usrShellCmdInit (); /* The kernel shell commands initialization sequence */ /* (1) 从bootline参数的startupScript选项中解析出脚本名，并执行 */ usrStartupScript (startupScriptFieldSplit (sysBootParams.startupScript)); /* Including this component results in the execution of a kernel shell script at VxWorks startup. */ usrShell (); /* This component includes the target-resident kernel shell, which is spawned as a task. Any function that is invoked from the kernel shell, rather than spawned, runs in the shell\u0026#39;s context. The task name for a shell on the console is \u0026#34;tShell0\u0026#34;. The kernel shell is re-entrant, and more than one shell task can run at a time (hence the number suffix). In addition, if a user logs in remotely (using rlogin or telnet) to a VxWorks target, the name reflects that fact as well. For example, \u0026#34;tShellRem1\u0026#34;. The \u0026#34;tShell\u0026#34; basename is configurable, see the VxWorks 7 Kernel Shell User\u0026#39;s Guide. */ } 如果使用VxWorks自带的bootloader，可以在boot cmd命令行中配置bootline的startup script选项:\nstartup script (s) : /mmc1:1/autorun_c.sh 但是我们目前方案的bootloader使用的是uboot，所以我们只需配置好默认bootline中的startup script选项。\nautorun_c.sh脚本中的内容非常简单，就是我们手工执行时需要键入的4条指令： ld \u0026lt; /mmc1:1/pruss_eth.out prussStart ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out main 运行结果： 实际的运行结果，发现VxWorks启动后，卡住几分钟才能执行到autorun_c.sh脚本： Adding 11197 symbols for standalone. // vxworks启动完成 // 卡住了好几分钟 Waiting for device to mount // autorun_c.sh脚本才得到执行 Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541474832 = 0x20464010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 ... 初步分析卡住的原因： 在“usrRoot() -\u0026gt; usrToolsInit() -\u0026gt; usrShellInit()-\u0026gt;usrStartupScript()”这个时间点执行“/mmc1:1/autorun_c.sh”脚本时，“/mmc1:1/”设备并没有mount好，usrStartupScript()函数中重试机制在不停的重新尝试执行，但是这个重试机制又会阻止“/mmc1:1/”的mount进程，所以会卡死很久。\n因为没有深入研究VxWorks的初始化流程，我们先尝试使用别的方法，后续有时间可以研究卡住问题的解决方案。\n方案2(成功) # VxWorks执行自定义内核程序，还有一个公共的入口在usrAppInit()函数当中，函数调用关系如下：\nvoid usrRoot (char *pMemPoolStart, unsigned memPoolSize) { ... usrToolsInit (); // 这里进行usrShellInit()-\u0026gt;usrStartupScript()的调用 usrAppInit (); ... } 可以看到usrAppInit()调用点比方案1的usrShellInit()调用点靠后，我们尝试在usrAppInit()里面实现内核模块DKM的自加载。\n我们在usrAppInit()函数中直接调用usrStartupScript()来运行\u0026quot;/mmc1:1/autorun_c.sh\u0026quot;脚本： void usrAppInit (void) { #ifdef\tUSER_APPL_INIT USER_APPL_INIT;\t/* for backwards compatibility */ #endif /* TODO: add application specific code here */ ioDefPathSet(\u0026#34;/mmc1:1/\u0026#34;); usrStartupScript(\u0026#34;/mmc1:1/autorun_c.sh\u0026#34;); } autorun_c.sh脚本的内容还是和方案1一样： ld\u0026lt;/mmc1:1/pruss_eth.out prussStart ld\u0026lt;/mmc1:1/s24_DriveRotationCiA402.out main 运行结果： VxWorks启动后，没有卡住的现象，autorun_c.sh脚本能迅速得到执行：\nAdding 11197 symbols for standalone. Waiting for device to mount .-\u0026gt; Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541536272 = 0x20473010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStop. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerCreate. Warning: module 0x204735b8 holds reference to undefined symbol MasterStartPIClientProcessor. Warning: module 0x204735b8 holds reference to undefined symbol MasterStopPIClientProcessor. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. value = 0 = 0x0 Done executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;. -\u0026gt; 但细心的同学会发现autorun_c.sh脚本中的4条指令只执行了3条，最后一条\u0026quot;main\u0026quot;指令并没有得到执行，但是在shell下手工键入又可以得到执行，这是为什么呢？\n首先怀疑main这个符号和其他人重名，造成调用失败。但是查找符号表后，发现并没有重名情况：\n-\u0026gt; -\u0026gt; cmd [vxWorks *]# [vxWorks *]# lookup main ipnet_radvd_main 0x001b8988 text main 0x00c9976c text (s24_DriveRotationCiA402.out) ipftpc_cmd_main 0x001325bc text vxbClkDomainInit 0x003d5c00 text tiClkDomainDrv 0x004cf6fc data vxbClkDomainRegister 0x003d4af8 text ipnet_flow_spec_domain 0x0015bc78 text ipftps_main 0x001374a8 text __dataset__driver_tiClkDomainDrv 0x004ddaa4 data [vxWorks *]# 进一步分析运行log发现一个情况：同样是加载.out文件，“ld \u0026lt; /mmc1:1/pruss_eth.out”的返回值0x20473010其实是pruss_eth.out 加载后的MODULE ID，但是\u0026quot;ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out\u0026quot;的返回值却为0:\n-\u0026gt; cmd [vxWorks *]# module MODULE NAME MODULE ID GROUP # TEXT START DATA START BSS START --------------- ---------- ---------- ---------- ---------- ---------- pruss_eth.out 0x20473010 1 0x00b59010 0x00b5b0e4 NO SEGMENT s24_DriveRotati 0x20473874 2 0x00b5c010 0x00cade18 0x00cb4064 于是怀疑\u0026quot;ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out\u0026quot;的加载过程出错，autorun_c.sh脚本执行中断，造成了随后的\u0026quot;main\u0026quot;命令没有得到运行。 在\u0026quot;ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out\u0026quot;我们可以看到有几个人符号没有得到解析的告警，虽然module还是加载上了还能手工执行，但是这个出错可能会中断脚本的运行：\n... Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. 沿着这个分析方向，让用户编译一份没有符号解析错误的.out文件进行测试。\n没有符号解析错误的.out，运行结果： 用户编译了一份没有符号解析错误的newmaster.out，来替换之前出错的s24_DriveRotationCiA402.out。autorun_c.sh脚本中的4条指令能够完美的得到执行：\nAdding 11197 symbols for standalone. Waiting for device to mount .-\u0026gt; Instantiating /sd0:2 as rawFs, device = 0x50001 Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541560848 = 0x20479010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 ld \u0026lt; /mmc1:1/newmaster.out value = 541562996 = 0x20479874 = \u0026#39;t\u0026#39; main Initialize Master ... Create Master instance ... Get network adapter name ... Network adapters count: Attach Master to adapter \u0026#39;kpa_pruss0\u0026#39; ... Create Configurator instance to load configuration ... Loading ENI \u0026#39;/master.xml\u0026#39; ... Starting Master ... Master started. Start EtherCAT frames exchange ... Requesting Operational Master state ... ... 用户应用程序(RTP)自启动 # 在文档\u0026quot;installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf\u0026quot;的\u0026quot;Automatic Execution of RTP Applications\u0026quot;章节，对RTP自启动的几种方法有着详细的描述，感兴趣可以自行学习。\n我们以vxsim架构下的一个RTP程序为例来详细介绍这些方法。\n首先我们创建了基于vxsim架构的VSB、VIP工程，并且创建了一个测试使用的RTP工程。测试代码的内容很简单：\nrtp.c: #include \u0026lt;stdio.h\u0026gt; int main ( int\targc,\t/* number of arguments */ char * argv[]\t/* array of arguments */ ) { int i = 0; printf(\u0026#34;Hello World!\\nFrom your RTP application...\\nBy pwl.\\n\u0026#34;); while(i\u0026lt;3){ i++; taskDelay(100); printf(\u0026#34;%d ticks\\n\u0026#34;, i*100); } return 0; } 我们使用这个RTP工程编译出TestSimRtp.vxe映像文件。\n手工执行TestSimRtp.vxe文件有两种方式：\n在C shell下执行： -\u0026gt; -\u0026gt; rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; value = 941088064 = 0x3817dd40 = \u0026#39;@\u0026#39; -\u0026gt; Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; 在Command shell下执行： -\u0026gt; -\u0026gt; cmd [vxWorks *]# rtp exec host:D:/pwl_workspace/TestSimRtp.vxe Launching process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; ... Process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; (process Id = 0x38cfb358) launched. Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks [vxWorks *]# 自动执行方式1 (RTP_APPL_INIT_STRING) # 首先在vxsim的VIP工程中的配置选项中，使能INCLUDE_RTP_APPL_INIT_STRING选项： 配置其中的RTP_APPL_INIT_STRING参数： RTP_APPL_INIT_STRING参数的具体内容为：\n\u0026#34;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 这个字符串的详细语法可以参考 \"installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf\"中的\"Application Startup String Syntax\"小节。 启动vxworks simulator，查看运行结果，成功自动运行： Loading symbol table from host:D:/pwl_workspace/TestSimVip/default/vxWorks.sym ...done -\u0026gt; Spawning RTP: host:D:/pwl_workspace/TestSimRtp.vxe Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; 自动执行方式2 (RTP_APPL_INIT_BOOTLINE) # VxWorks支持使用INCLUDE_RTP_APPL_INIT_BOOTLINE组件来配置系统启动时自动运行C Interpreter格式的脚本，我们尝试使用此方法来实现系统启动时自动运行RTP程序。\n首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_BOOTLINE选项： vxsim VIP工程的SCRIPT_DEFAULT选项设置： startup script具体的配置如下：\n\u0026#34;host:D:/pwl_workspace/autorun_c.sh#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 需要注意的是startup script中可以配置两种不同的自启动方式，上述的参数可以分成两部分：\n“host:D:/pwl_workspace/autorun_c.sh”这部分配置的是vxworks在启动阶段执行一个C Interpreter格式的脚本。autorun_c.sh脚本的具体内容如下： rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 需要特别注意的是，这里调用的是C Interpreter格式的脚本，后面的`RTP_APPL_INIT_CMD_SHELL_SCRIPT`方式调用的是Command Interpreter格式的脚本。 \u0026ldquo;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026quot;这部分配置的语法和INCLUDE_RTP_APPL_INIT_STRING选项一样。 上述参数分别运行了一次TestSimRtp.vxe，所以TestSimRtp.vxe会被运行两次。\n启动vxworks simulator，查看运行结果，成功自动运行两次： Loading symbol table from host:D:/pwl_workspace/TestSimVip/default/vxWorks.sym ...done // (1) 第一次执行，使用autorun_c.sh脚本的执行 Executing startup script \u0026#39;host:D:/pwl_workspace/autorun_c.sh\u0026#39;... rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; value = 950476976 = 0x38a720b0 Hello World! From your RTP application... By pwl. Done executing startup script \u0026#39;host:D:/pwl_workspace/autorun_c.sh\u0026#39;. // (2) 第二次执行，使用\u0026#34;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34;选项配置的执行 -\u0026gt; Spawning RTP: host:D:/pwl_workspace/TestSimRtp.vxe Hello World! From your RTP application... By pwl. 100 ticks 100 ticks 200 ticks 200 ticks 300 ticks 300 ticks -\u0026gt; 自动执行方式3 (RTP_APPL_INIT_CMD_SHELL_SCRIPT) # 首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_CMD_SHELL_SCRIPT选项，并配置其中的RTP_APPL_CMD_SCRIPT_FILE参数： 参数的具体内容为：\u0026ldquo;host:D:/pwl_workspace/autorun_cmd.sh\u0026rdquo; 系统启动时自动运行配置的Command Interpreter格式的脚本autorun_cmd.sh,autorun_cmd.sh脚本的具体内容为：\nrtp exec host:D:/pwl_workspace/TestSimRtp.vxe 启动vxworks simulator，查看运行结果，成功自动运行： -\u0026gt; Executing startup script \u0026#39;host:D:/pwl_workspace/autorun_cmd.sh\u0026#39;... rtp exec host:D:/pwl_workspace/TestSimRtp.vxe Launching process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; ... Process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; (process Id = 0x38d3a890) launched. Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks Done executing startup script \u0026#39;host:D:/pwl_workspace/autorun_cmd.sh\u0026#39;. -\u0026gt; 自动执行方式4 (RTP_APPL_USER) # 首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_USER选项： 在INCLUDE_RTP_APPL_USER选项被使能以后，vxworks启动时会调用usrRtpAppInit.c文件中的usrRtpAppInit()函数。我们可以在此函数中加入自己的rtp启动代码： void usrRtpAppInit (void) { /* TODO - add your own application launch code here */ /* (1) 使用代码调用rtpSpawn()函数来运行TestSimRtp.vxe文件 */ char * vxeName = \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34;; char * argv[5]; RTP_ID rtpId = NULL; /* set the application\u0026#39;s arguments */ argv[0] = vxeName; argv[1] = NULL; argv[2] = NULL; argv[3] = NULL; argv[4] = NULL; /* Spawn the RTP. No environment variables are passed */ if ((rtpId = rtpSpawn (vxeName, argv, NULL, 220, 0x10000, 0, 0)) == NULL) { printf (\u0026#34;Impossible to start %s application \u0026#34;, vxeName); } } 启动vxworks simulator，查看运行结果，成功自动运行： -\u0026gt; Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; ","date":"2024-10-20","externalUrl":null,"permalink":"/app/vxworks-7-app-auto-boot-method/","section":"Apps","summary":"\u003cp\u003e本文介绍了VxWorks 7系统下自启动应用程序的四种方法。\u003c/p\u003e\n\u003cp\u003e在开始之前我们先来了解一下一些vxworks的一些基础知识。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eVxWorks工程 \n    \u003cdiv id=\"vxworks%E5%B7%A5%E7%A8%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#vxworks%E5%B7%A5%E7%A8%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eVxWorks 7 可以创建以下几种典型的工程：\u003c/p\u003e","title":"VxWorks 7自启动应用程序的四种方法","type":"app"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/arinc429/","section":"Tags","summary":"","title":"ARINC429","type":"tags"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/avionics/","section":"Tags","summary":"","title":"Avionics","type":"tags"},{"content":"航电激励器在民用飞机航电系统半物理仿真平台中起着至关重要的作用。在航电系统开发过程中，航电激励器向航电仿真设备提供的激励数据是进行航电系统仿真验证的基础，所以在航电激励数据的获取和处理中，航电激励器的设计与实现是极其重要的一个环节。该文基于VxWorks 系统设计一款航电激励器，对航电激励器进行总体设计，从激励数据获取模块、激励数据转换模块等方面进行研究，完成软件设计以及硬件平台搭建。通过对设计的航电激励器进行仿真验证，实现飞机模拟飞行数据的获取以及航电系统中ARINC429 总线数据和AFDX 总线数据的相互转换，使得激励数据在传输过程中具有良好的实时性。\n航空电子系统是指飞机上所有电子系统的总和，其仿真验证在航电系统的设计与研发过程中起着重要的作用，对航电系统进行仿真验证，可以有效地降低航电系统集成过程中存在的风险和成本，缩短开发周期。在进行各种仿真验证时，需要航电激励器向仿真组件提供激励信号，所以航电激励器提供的激励信号的准确性和稳定性将对仿真验证的结果产生直接影响。\n目前，航电激励器主要是基于Windows 系统开发的，在数据传输的实时性、可靠性等方面略显不足，并且在向仿真组件提供激励信号时，常出现数据的延时、丢包等问题。VxWorks 系统采用优先级抢占和轮转调度的任务调度机制，具有良好的实时性。基于VxWorks系统开发的航电激励器可以很好地解决Windows 系统下开发的航电激励器所存在的不足。因此本文设计一款基于VxWorks 系统的航电激励器，能够为航电系统提供具有实时性、可靠性的激励信号。\n航电激励器总体设计 # 本文设计的航电激励器由软件和硬件两部分构成。软件部分主要包括激励数据获取模块和数据转换模块。其中，激励数据获取模块通过以太网接收飞机模拟飞行过程中的飞行数据，这些数据包括飞机的位置、姿态、通信导航系统的工作频率等参数。航电激励器数据转换模块主要实现AFDX 总线数据、ARINC429 总线数据的编解码，完成ARINC429 总线数据与AFDX 总线数据相互转化，并向各航电仿真组件传输激励数据。AFDX 数据总线协议见文献[4]，ARINC429 总线协议见文献[5]。硬件部分主要完成VxWorks 系统在MPC8270 上的移植，建立硬件开发平台。航电激励器总体设计如图1所示。\n图1 航电激励器总体设计 航电激励器的软件设计 # 激励数据获取模块 # 从实际应用的角度出发，激励数据获取模块所获取的激励数据主要来源于飞行仿真软件中的飞行数据，通过激励数据获取模块实现激励数据获取模块与飞行仿真软件的内存共享，从而实现飞行数据的实时获取。\n通过以太网发送的飞行数据格式是基于UDP 数据包格式，数据获取模块接收到1 帧数据包后，首先对该数据包的帧头进行判断，其次判断数据帧校验位的正确与否，然后对校验位正确的数据包进行确定报文类型并解析出报文所包含的信息。通过设计ARINC429 总线数据字编码的接口函数，调用ARINC429 数据字编码接口，对将UDP 格式的数据包解码后的飞行数据信息进行编码得到激励数据对应的ARINC429 数据字，确定周期和通道后将该ARINC429 数据字输出到航电仿真组件。激励数据获取流程如图2 所示。\n激励数据转换模块 # AFDX 总线凭借着卓越的传输效率以及高可靠性等特点，广泛地应用于B-787、A380 等先进机型中。目前，航电系统主干网络通常采用AFDX 总线将机载各个子系统连接成一个高效可靠的整体，而飞机很多子系统仍采用比较成熟的ARINC429 总线。因此，本文设计航电激励器的数据转换模块，实现AFDX 总线激励信号与ARINC429 总线激励信号之间的相互转换。上述两种数据格式总线信号的相互转换是互为逆过程，本节将通过设计航电激励器收发ARINC429 总线数据字对应的AFDX 总线数据包，从而实现总线数据间的编码转换。\n图2 激励数据获取流程 对AFDX 总线数据进行分析，将AFDX 总线报文设计成可由多个“消息”（Message）拼接而成的通用格式。AFDX 总线中的每条“消息”都分为三个部分，便于将ARINC429 总线的数据字结构填入AFDX 数据帧结构中。MsgType 指的是对消息类型的编码；LengthInBytes是表示PayLoad 字段的长度；PayLoad 是AFDX 总线的承载内容。PayLoad 长度是可变的，其具体承载的信息格式由MsgType 的值决定。AFDX 总线报文中消息的通用格式如图3 所示。\n图3 AFDX 总线报文中消息的通用格式 硬件平台设计 # VxWorks 系统为开发者提供大量板级支持包BSP（Board Support Packet），便于简化BSP 移植工作。在进行BSP 移植之前，需要根据CPU 型号选择相应BSP 包，同时参考硬件数据调整BSP 相关配置信息。在完成BSP 配置后，建立新的VxWorks Image Project 工程，同时创建映像所需的文件。\n图4 ARINC429 总线数据转换为AFDX 数据包 VxWorks 模块是根据目标板卡的性能需求完成VxWorks 系统内核模块的配置。VxWorks 系统映像经编译生成后，对FTP 环境进行调试。通过运行Workbench 3.3 中的FTP Server，完成FTP 环境中的用户信息配置。完成以上配置后，将VxWorks 映像下载至目标板卡MPC8270 运行。至此完成VxWorks 系统平台的搭建。\n航电激励器的仿真与测试 # 在航电激励器的功能实现之后需要对航电激励器进行验证测试，主要针对航电激励器所能提供的航电激励信号进行测试，即ARINC429 总线激励信号、AFDX 总线激励信号以及激励信号实时性测试。\nARINC429 总线激励信号数据测试 # 航电激励器对接收到的ARINC429 总线激励信号进行数据符合性测试。在飞行数据中获取其中5 种激励数据进行测试，如表1 所示。将航电激励器的一条ARINC429 输出通道连接到ARINC429 总线分析仪，将表1 中激励数据统一设置发送周期为200 ms，输出到ARINC429 总线分析仪。总线分析仪所显示的激励数据如图5 所示。\n表1 激励参量取值 图5 ARINC429 总线分析仪显示的数据 将表1 数据信息与图5 显示结果进行对比，结果显示二者所包含的数据信息一致，航电激励器输出的ARINC429 总线激励信号满足数据符合性要求。\nAFDX 总线激励信号数据测试 # 激励数据获取模块选择飞行仿真软件中模拟飞机的VOR1 频率飞行数据进行验证，激励数据VOR1 频率的相关信息如表2 所示。航电激励器将AFDX 总线激励信号通过AFDX 板卡发送至交换机，通过Wireshark 抓取AFDX 数据包，对应抓取数据包为十六进制数：3800DC84，结果如图6 所示。通过对比验证，航电激励器输出的AFDX 总线激励信号中的数据信息与ARINC429 负载数据一致，航电激励器实现了ARINC429 总线激励信号转化为AFDX 信号的预期功能。\n表2 航电激励器输出AFDX 信号配置信息 图6 VOR1 频率数据包 激励信号实时性测试 # 本文依靠VxWorks 系统的独特优势保证数据获取的实时性。“实时”并不意味着是“快”，而是指系统响应的时间确定性。时间确定性具体体现为航电激励器能否完全按照规定周期对激励信号进行收发。首先基于VxWorks 系统下的航电激励器对ARINC429 总线激励信号进行输出，配置输出数据信息如表3 所示。\n表3 输出ARINC429 总线信号配置信息 配置信息完成后，在低速（12.5 Kb/s）模式下，航电激励器输出ARINC429 总线激励信号，通过示波器对ARINC429 的8 号输出通道进行测试。同理，利用Windows 系统下的航电激励器完成表3 配置数据的发送，测试出每对相邻波形起始点间的时间间隔，测试结果如表4 所示。\n经测试验证，基于VxWorks 系统的航电激励器输出的2 组连续信号波形时间间隔与设定发送周期相同，为精确的30.00 ms，没有产生抖动延迟。然而Windows 系统下航电激励器在进行激励信号的周期性发送时，连续的两个信号间的时间间隔容易产生时间抖动，每组波形间的时间延迟在1 ms 以上。综上所述，基于VxWorks系统的航电激励器在时间确定性效果方面更能满足航电系统仿真验证的高实时性需求。\n表4 单通道时间确定性测试结果 ms 结 论 # 本文基于VxWorks 系统，以MPC8270 为目标平台，提出航电激励器的总体设计方案并进行详细设计，最终实现AFDX 总线数据与ARINC429 总线数据的相互转换，为实际的航电仿真系统提供良好的激励数据。通过仿真测试表明所设计的航电激励器达到预期效果。\n（本文来源于《现代电子技术》，作者：孙毅刚，迟文强，作者单位：中国民航大学航空工程学院）\n全文下载地址: 基于VxWorks系统的航电激励器设计与实现\n","date":"2024-10-20","externalUrl":null,"permalink":"/app/design-and-implementation-of-avionics-exciter-based-on-vxworks-system/","section":"Apps","summary":"\u003cp\u003e航电激励器在民用飞机航电系统半物理仿真平台中起着至关重要的作用。在航电系统开发过程中，航电激励器向航电仿真设备提供的激励数据是进行航电系统仿真验证的基础，所以在航电激励数据的获取和处理中，航电激励器的设计与实现是极其重要的一个环节。该文基于\u003ca href=\"https://www.vxworks6.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e 系统设计一款航电激励器，对航电激励器进行总体设计，从激励数据获取模块、激励数据转换模块等方面进行研究，完成软件设计以及硬件平台搭建。通过对设计的航电激励器进行仿真验证，实现飞机模拟飞行数据的获取以及航电系统中\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eARINC429\u003c/a\u003e 总线数据和AFDX 总线数据的相互转换，使得激励数据在传输过程中具有良好的实时性。\u003c/p\u003e\n\u003cp\u003e航空电子系统是指飞机上所有电子系统的总和，其仿真验证在航电系统的设计与研发过程中起着重要的作用，对航电系统进行仿真验证，可以有效地降低航电系统集成过程中存在的风险和成本，缩短开发周期。在进行各种仿真验证时，需要航电激励器向仿真组件提供激励信号，所以航电激励器提供的激励信号的准确性和稳定性将对仿真验证的结果产生直接影响。\u003c/p\u003e\n\u003cp\u003e目前，航电激励器主要是基于Windows 系统开发的，在数据传输的实时性、可靠性等方面略显不足，并且在向仿真组件提供激励信号时，常出现数据的延时、丢包等问题。VxWorks 系统采用优先级抢占和轮转调度的任务调度机制，具有良好的实时性。基于VxWorks系统开发的航电激励器可以很好地解决Windows 系统下开发的航电激励器所存在的不足。因此本文设计一款基于VxWorks 系统的航电激励器，能够为航电系统提供具有实时性、可靠性的激励信号。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e航电激励器总体设计 \n    \u003cdiv id=\"%E8%88%AA%E7%94%B5%E6%BF%80%E5%8A%B1%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E8%88%AA%E7%94%B5%E6%BF%80%E5%8A%B1%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e本文设计的航电激励器由软件和硬件两部分构成。软件部分主要包括激励数据获取模块和数据转换模块。其中，激励数据获取模块通过以太网接收飞机模拟飞行过程中的飞行数据，这些数据包括飞机的位置、姿态、通信导航系统的工作频率等参数。航电激励器数据转换模块主要实现AFDX 总线数据、ARINC429 总线数据的编解码，完成ARINC429 总线数据与AFDX 总线数据相互转化，并向各航电仿真组件传输激励数据。AFDX 数据总线协议见文献[4]，ARINC429 总线协议见文献[5]。硬件部分主要完成VxWorks 系统在MPC8270 上的移植，建立硬件开发平台。航电激励器总体设计如图1所示。\u003c/p\u003e","title":"基于VxWorks 系统的航电激励器设计与实现","type":"app"},{"content":" VxWorks The Leading RTOS The industry's most widely deployed RTOS. VxWorks has been used to ensure the security, safety, and reliability you need to design and build mission-critical embedded systems that simply must work.\n支持OCI容器，一键升级 # VxWorks是全球首个且唯一一个利用容器部署应用程序的实时操作系统。\n最新版的VxWorks 7支持OCI容器，利用类似IT的传统技术，即可更高效更优质地开发和部署智能边缘软件，且不会影响确定性和性能。了解为何研究机构VDC再次将VxWorks评为最佳边缘部署实时操作系统。\nVxWorks：现代设计，面向未来，始终实时 # VxWorks是一款确定性、基于优先级的抢占式实时操作系统，具有超低延迟和最小抖动。为应对未来挑战，VxWorks采用可升级架构，助力企业快速响应不断变化的市场需求，确保技术永不过时。\nVxWorks是唯一支持C ++ 17、Boost、Rust、Python、pandas等开发语言的实时操作系统，搭载边缘优化和OCI兼容的容器引擎，便于企业灵活选择开发语言、工具和技术，创新机要事务。\n超高信息安全 # 智能边缘中各设备、系统和行业的需求各不相同，信息安全威胁也在不断演进。VxWorks可提供超高信息安全，助力企业构建安全设备，应对当前威胁；此外，其灵活的模块化设计可积极应对未来挑战。同时，风河的检索数据库包括MITRE公共漏洞和暴露（CVEs）信息，可为客户提供最新的信息安全补丁。\nVxWorks 653和VxWorks 认证版 # VxWorks满足EN 50128、IEC 61508、ISO 26262、DO-178C和ED-12C等严苛的功能安全认证要求，可用于最具挑战性的安全关键型应用程序，且更便捷、更具成本效益。\n板级支持包 # 风河与芯片供应商和硬件制造商保持有密切联系，可提供开箱即用的板卡支持包，支持Arm、Power、英特尔和RISC-V等各类架构，降低企业开发成本，减少兼容组件的采购时间，可为客户预留更多时间用于产品研发。\n","date":"2024-10-04","externalUrl":null,"permalink":"/","section":"VxWorks Overview","summary":"\u003cblockquote\u003e\nVxWorks The Leading RTOS\u003c/br\u003e\nThe industry's most widely deployed RTOS.\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.vxworks6.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e has been used to ensure the security, safety, and reliability you need to design and build mission-critical embedded systems that simply must work.\u003c/p\u003e","title":"VxWorks Overview","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]