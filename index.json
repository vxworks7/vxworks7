
[{"content":"","date":"2025-01-04","externalUrl":null,"permalink":"/series/book/","section":"Series","summary":"","title":"Book","type":"series"},{"content":"","date":"2025-01-04","externalUrl":null,"permalink":"/book/","section":"Books","summary":"","title":"Books","type":"book"},{"content":"","date":"2025-01-04","externalUrl":null,"permalink":"/tags/bsp/","section":"Tags","summary":"","title":"BSP","type":"tags"},{"content":"","date":"2025-01-04","externalUrl":null,"permalink":"/tags/device-driver/","section":"Tags","summary":"","title":"Device Driver","type":"tags"},{"content":"","date":"2025-01-04","externalUrl":null,"permalink":"/tags/kernel/","section":"Tags","summary":"","title":"Kernel","type":"tags"},{"content":"","date":"2025-01-04","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2025-01-04","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-01-04","externalUrl":null,"permalink":"/tags/vxworks/","section":"Tags","summary":"","title":"VxWorks","type":"tags"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! VxWorks内核、设备驱动与BSP开发详解(第2版) 内容简介：\n在嵌入式行业飞速发展的今天，嵌入式操作系统的应用越来越广泛，VxWorks具有良好的实时性，被大量应用于航空、通信、国防、工业控制、网络设备、医疗设备、消费电子等嵌入式实时应用领域。\n《VxWorks内核、设备驱动与BSP开发详解(第2版)》共24章，按照初学者学习的一般步骤，详细介绍了VxWorks的开发环境、内核分析和应用程序开发、驱动程序开发与原理和板级支持包流程与移植，每章均配以实例进行讲解。\n《VxWorks内核、设备驱动与BSP开发详解(第2版)》语言通俗、实例丰富、代码分析详尽，有较强的实用性和参考价值，适合大专院校嵌入式相关专业学生学习参考，也可供嵌入式开发人员和系统设计人员参考使用。\n","date":"2025-01-04","externalUrl":null,"permalink":"/book/vxworks-kernel-device-driver-and-bsp-development-detailed-explanation-2nd-edition/","section":"Books","summary":"\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./vxworks-kernel-device-driver-bsp.png\" alt=\"VxWorks内核、设备驱动与BSP开发详解(第2版)\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://app.filemail.com/d/hjdaraaaapoiauz\" target=\"_blank\" download\u003eVxWorks内核、设备驱动与BSP开发详解(第2版)\u003c/a\u003e\n\u003cp\u003e内容简介：\u003c/p\u003e","title":"VxWorks内核、设备驱动与BSP开发详解(第2版)","type":"book"},{"content":"","date":"2025-01-02","externalUrl":null,"permalink":"/tags/development-tutorial/","section":"Tags","summary":"","title":"Development Tutorial","type":"tags"},{"content":"","date":"2025-01-02","externalUrl":null,"permalink":"/tags/vxworks-7/","section":"Tags","summary":"","title":"VxWorks 7","type":"tags"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! VxWorks 7.0 中文教程 欢迎来到VXWorks 7.0中文文档资源页面。本资源是针对Wind River VXWorks实时操作系统7.0版本的详细中文翻译文档。VXWorks作为嵌入式系统开发领域内广泛使用的高性能RTOS（实时操作系统），其强大的功能和灵活性深受工程师们的青睐。\n资源简介 # 此份中文文档是由社区贡献者投入大量时间和精力精心翻译而成，旨在帮助国内开发者更好地理解和应用VXWorks 7.0的各项功能和技术。对于那些英语阅读感到不便或希望更快获取信息的开发者来说，这一资源无疑是一大福音。翻译过程中不仅力求准确无误，还尽可能保持了原版文档的结构和清晰度，使得学习和参考更加便捷。\n使用目的 # 自学与研究：适合自学VXWorks 7.0的新手及需要深入研究该系统的开发者。 项目参考：在进行VXWorks相关的项目开发时，提供快速查找和理解系统特性的途径。 教学辅助：可作为高校或培训机构在教授嵌入式系统课程时的教学补充材料。 注意事项 # 请确保您已拥有VXWorks 7.0的合法使用权，以便与文档配套实践。 由于是社区个人翻译作品，虽然努力追求高质量，但仍可能存在翻译上的不准确之处，使用时仅供参考。 鼓励用户提供反馈和修正建议，以不断完善文档质量。 如何获取 # 直接下载提供的vxworks-7.0中文文档.7z压缩文件即可开始您的VXWorks学习之旅。解压后，根据目录结构查阅相应章节，开始探索VXWorks的强大世界。\n通过这份宝贵的中文资料，愿每位开发者都能在嵌入式技术的探索之路上更进一步。如果你发现这份文档对你有所帮助，不妨分享给更多有需要的朋友，共同促进技术交流与发展。\ngit直接下载 # git clone https://gitcode.com/open-source-toolkit/4bd57.git 大文件分享直接下载 # VxWorks 7.0 中文教程\n","date":"2025-01-02","externalUrl":null,"permalink":"/book/vxworks-7-user-guide-in-chinese/","section":"Books","summary":"\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://app.filemail.com/d/kjygbkqsgypopfz\" target=\"_blank\" download\u003eVxWorks 7.0 中文教程\u003c/a\u003e\n\u003cp\u003e欢迎来到VXWorks 7.0中文文档资源页面。本资源是针对Wind River VXWorks实时操作系统7.0版本的详细中文翻译文档。VXWorks作为嵌入式系统开发领域内广泛使用的高性能RTOS（实时操作系统），其强大的功能和灵活性深受工程师们的青睐。\u003c/p\u003e","title":"VxWorks 7.0 中文教程","type":"book"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! VxWorks开发教程(中文版) 内容索引\n第一章 Wind River............................... 4 1.1 风河系统公司简介 ............................. 4 1.2 实时操作系统 Vxworks 简介..................... 4 第二章 Tornado.................................. 6 2.1 安装开发环境 ................................ 6 2.2 Tornado 集成开发环境简述 ..................... 6 2.2.1 Tomado 编辑器 ............................. 6 2.2.2 工程管理 ................................... 7 2.2.3 编译 ...................................... 7 2.2.4 目标机系统状走浏览器 Browser.................. 8 2.2.5 文叉调试器——Crosswind ...................... 8 2.2.6 C 语言命令 shell 工具 WindSh................ 9 2.2.7 VxWorks 仿真器——VxSim ..................... 9 2.2.8 目标机软件逻辑分析——WindView ................ 9 2.2.9 用户定制功能 ............................... 10 2.3 一个基于 VxSim 的简单工程 ..................... 10 2.3.1 开始 tornado............................... 10 2.3.2 创建工程 ................................... 11 2.3.3 向工程加例子源代码 ........................... 13 2.3.4 编译工程 ................................... 15 2.3.5 下载工程到 vxworks 目标模拟器 ................ 17 2.3.6 从 Tornado Shell 运行应用程序 ............... 20 2.3.7 查看目标内存使用情况 ......................... 21 2.3.8 查看任务.................................... 22 2.3.9 修改任务的优先级和查找错误 .................... 24 第三章 基本工程实践 ................................ 26 3.1 Bootable 工程实践 ............................. 26 3.2 Downloadable 工程实践 ......................... 30 第四章 驱动实验..................................... 35 WindML 3.0.3 开发................................. 35 4.1、WindML 简介 .................................. 35 4.2、安装和配置..................................... 39 4.3、WindML 体系 .................................. 39 4.4、WindML 开发流程简介 ........................... 40 4.5、UPTECH2410 的 LCD 开发流程详解 ................. 41 4.5.1 WindML 的 BSP 修改 .......................... 41 4.5.2 LCD 配置文件的建立 ........................... 44 4.5.3 LCD 驱动程序开发 ............................. 51 4.6、WindML 例程分析 ............................... 57 4.6.1 wexbasic 实例分析 ............................ 57 4.6.2 ugldemo 实例分析 ............................. 67 4.7、2410 LCD WindML 软件使用方法 ................... 70 第五章 应用实验...................................... 71 5.1 串口 ........................................... 71 5.1.1 串口概述....................................... 71 5.1.2 串口操作....................................... 71 5.1.2.1 open........................................ 72 5.1.2.2 close....................................... 72 5.1.2.3 read........................................ 73 5.1.2.4 write....................................... 73 5.1.2.5 ioctl....................................... 73 5.1.3 实验........................................... 74 5.1.3.1 使用 wirte 函数对串口进行写操作.................. 74 5.1.3.2 使用 read 函数对串口进行读操作................... 77 5.1.3.3 使用 ioctl 函数对串口进行控制.................... 78 5.2 基于块设备的文件系统................................. 80 5.2.1 VxWorks 支持的文件系统 ........................... 80 5.2.2 文件系统的配置.................................... 81 5.2.3 ramDrv.......................................... 82 5.3 网络通信........................................... 87 5.3.1 概述............................................ 87 5.3.2 VxWorks 套接字 ................................. 88 5.3.3 Socket 函数 .................................... 88 5.3.3.1 socket....................................... 88 5.3.3.2 bind......................................... 89 5.3.3.3 listen....................................... 91 5.3.3.4 accept....................................... 91 5.3.3.5 connect...................................... 92 5.3.3.6 send 和 recv.................................. 92 5.3.3.7 sendto 和 recvfrom............................ 94 5.3.4 实验............................................ 95 5.3.4.1 Ping.......................................... 95 5.3.4.2 流套接字（基于 TCP） ............................ 99 5.3.4.3 数据报套接字（基于 UDP） ........................ 102 5.3.4.4 FTP.......................................... 104 5.3.4.5 以太网包的截取与解析............................ 111 5.4 多任务环境........................................ 115 5.4.1 任务........................................... 115 5.4.1.1 概述.......................................... 115 5.4.1.2 任务函数库..................................... 116 5.4.2 任务间的通信机制.................................. 116 5.4.2.1 信号量........................................ 116 5.4.2.2 消息队列...................................... 120 5.4.2.3 管道.......................................... 122 5.4.2.4 信号.......................................... 122 5.4.4 实验............................................ 124 5.4.4.1 创建任务，利用 WindView 观察任务调度.............. 124 5.4.4.2 利用二进制信号量同步任务.......................... 126 ","date":"2025-01-02","externalUrl":null,"permalink":"/book/vxworks-system-development-tutorial/","section":"Books","summary":"\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://www.vxworks.net/bsp/916-vxworks-development-guide\" target=\"_blank\" download\u003eVxWorks开发教程(中文版)\u003c/a\u003e\n\u003cp\u003e内容索引\u003c/p\u003e","title":"VxWorks开发教程(中文版)","type":"book"},{"content":"","date":"2024-12-31","externalUrl":null,"permalink":"/series/app/","section":"Series","summary":"","title":"App","type":"series"},{"content":"","date":"2024-12-31","externalUrl":null,"permalink":"/app/","section":"Apps","summary":"","title":"Apps","type":"app"},{"content":"","date":"2024-12-31","externalUrl":null,"permalink":"/tags/telnet-client/","section":"Tags","summary":"","title":"Telnet Client","type":"tags"},{"content":" Telnet client连接过程 # TCP连接telnet server 23端口 NVT扩展自动协商 用户名+密码登录 通过telnet server端命令行交互 退出登录 概述 # Telnet 协议是 TCP/IP 协议族中 应用最广泛的协议。\n它允许用户(Telnet 客户端)通过一个协商过程来与一个远程设备进行通信。\nTelnet 协议是基于网络虚拟终端 NVT(Network Virtual Termina1)的实现，NVT 是虚拟设备，连接双方(客户机和服务器)都必须把它们的物理终端和 NVT 进行相互转换。\n操作协商 # 只要客户机或服务器要发送命令序列而不是数据流，它就在数据流中插入一个特殊的保留字符，该保留字符叫做“解释为命令”(IAC ，Interpret As Command) 字符。当接收方在一个入数据流中发现 IAC 字符时，它就把后继的字节处理为一个命令序列。\n双方在进行Telnet连接时，要进行选项协商。\n比如：使用字符方式、窗口的大小，终端的类型都要进行协商。而协商是通过TELNET所支持的命令来实现的。\n协商完成，telnet server才返回登录信息，否则无法登录。\n本文协商过程通过程序的一个函数实现自动化。\nVxWorks下telnet client实现代码\n#include \u0026#34;string.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;vxWorks.h\u0026#34; #include \u0026#34;sockLib.h\u0026#34; //#include \u0026#34;telnetLib.h\u0026#34; #include \u0026#34;inetLib.h\u0026#34; #include \u0026#34;stdioLib.h\u0026#34; #include \u0026#34;strLib.h\u0026#34; #include \u0026#34;hostLib.h\u0026#34; #include \u0026#34;ioLib.h\u0026#34; // telnet server 地址及端口 #define TELNET_SERVER_NAME \u0026#34;172.18.101.193\u0026#34; #define TELNET_SERVER_PORT 23 // telnet NVT扩展选项协商，常用命令定义，命令与数值的对应关系 #define DO \u0026#39;\\xFD\u0026#39; #define WONT \u0026#39;\\xFC\u0026#39; #define WILL \u0026#39;\\xFB\u0026#39; #define DONT \u0026#39;\\xFE\u0026#39; #define IAC \u0026#39;\\xFF\u0026#39; #define SB \u0026#39;\\xFA\u0026#39; #define SE \u0026#39;\\xF0\u0026#39; #define CMD_WINDOW_SIZE 31 // 定义缓冲buffer长度，最大message长度，字符串最大长度 #define BUFFER_SIZE 20480 #define MAX_MSG_LENGTH 20480 #define STRING_MAX_SIZE 20480 // 全局变量 char go_string[STRING_MAX_SIZE]; char dealed_string[STRING_MAX_SIZE]; char back_string[STRING_MAX_SIZE]; // TCP client 主动连接：输入TCP服务端地址和端口，返回client_socket int tcp_client_conn(char *server_name, int port) { struct sockaddr_in server_addr; int client_socket; /*创建套接字*/ client_socket = socket(AF_INET, SOCK_STREAM, 0); if (client_socket \u0026lt; 0) { printf(\u0026#34;Create Socket Failed! \\n\u0026#34;); return -1; } // 填充server地址信息 bzero((char *)\u0026amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; if (((server_addr.sin_addr.s_addr = inet_addr(server_name)) == ERROR) \u0026amp;\u0026amp; ((server_addr.sin_addr.s_addr = hostGetByName(server_name)) == ERROR)) { printf(\u0026#34;Get Server Address Error! \\n\u0026#34;); return -1; } server_addr.sin_port = htons(port); server_addr.sin_len = sizeof(server_addr); /* connect to server */ if (connect(client_socket, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) == ERROR) { printf(\u0026#34;Connet to Server Error! \\n\u0026#34;); return -1; } return client_socket; } // 连接telnet server，自动协商过程 void negotiate(int client_socket) { char buffer[BUFFER_SIZE]; int count = 0; while (1) { bzero(buffer, BUFFER_SIZE); // 读一个字节 if (recv(client_socket, buffer, 1, 0) \u0026lt; 0) { printf(\u0026#34;Receive Data Failed! \\n\u0026#34;); return; } if (buffer[0] == IAC) { // read 2 more bytes if (recv(client_socket, buffer + 1, 2, 0) \u0026lt; 0) { printf(\u0026#34;Receive Data Failed! \\n\u0026#34;); return; } // TAC协商窗口大小 if (buffer[1] == DO \u0026amp;\u0026amp; buffer[2] == CMD_WINDOW_SIZE) { char tmp1[10] = {IAC, WILL, CMD_WINDOW_SIZE}; if (send(client_socket, tmp1, 3, 0) \u0026lt; 0) { printf(\u0026#34;Send Data Failed! \\n\u0026#34;); return; } char tmp2[10] = {IAC, SB, CMD_WINDOW_SIZE, 0, 80, 0, 24, IAC, SE}; if (send(client_socket, tmp2, 9, 0) \u0026lt; 0) { printf(\u0026#34;Send Data Failed! \\n\u0026#34;); return; } continue; } // 处理一个IAC协商命令 int i; for (i = 0; i \u0026lt; 3; i++) { if (buffer[i] == DO) { buffer[i] = WONT; } else if (buffer[i] == WILL) { buffer[i] = DO; } } if (send(client_socket, buffer, 3, 0) \u0026lt; 0) { printf(\u0026#34;Send Data Failed! \\n\u0026#34;); return; } } //结束循环条件，IAC协商结束 if (buffer[0] == \u0026#39;\\n\u0026#39;) { count += 1; } if (count == 2) { break; } } } // TCP client 接收服务端返回的数据 void tcp_client_receive_data(int client_socket) { char receive_buffer[BUFFER_SIZE]; int length; // 接受服务器返回的状态信息 bzero(receive_buffer, BUFFER_SIZE); if ((length = recv(client_socket, receive_buffer, MAX_MSG_LENGTH, 0)) == ERROR) { printf(\u0026#34;Client Recieve Data Failed! \\n\u0026#34;); return; } bzero(back_string, STRING_MAX_SIZE); strncpy(back_string, receive_buffer, (strlen(receive_buffer) \u0026gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(receive_buffer))); printf(\u0026#34;receive data from equipment: %s \\n\u0026#34;, back_string); } // TCP client 发送处理后的数据到目标TCP void tcp_client_send_data(int client_socket) { char send_buffer[BUFFER_SIZE]; /* send request to server */ bzero(send_buffer, BUFFER_SIZE); strncpy(send_buffer, dealed_string, strlen(dealed_string)); // buffer发送长度+1，目的带上\u0026#39;\\0\u0026#39;结束符，strlen()函数读取到\u0026#39;\\0\u0026#39;结束 int ret = send(client_socket, send_buffer, (strlen(send_buffer) + 1), 0); if (ret == ERROR) { printf(\u0026#34;Send Data to Server Error! \\n\u0026#34;); return; } printf(\u0026#34;send data to equipment: %s \\n\u0026#34;, send_buffer); } // telnet操作，命令数据处理 void telnet_deal_data(char *go_string, char *dealed_string) { bzero(dealed_string, STRING_MAX_SIZE); strncpy(dealed_string, go_string, (strlen(go_string) \u0026gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(go_string))); // 命令结尾增加\\n dealed_string[strlen(dealed_string)] = \u0026#39;\\n\u0026#39;; } // telnet登录，输入用户名，接收password void telnet_login_receive_password(int telnet_socket) { // recv当次接收的数据长度 int filled = 0; // recv接收的全部数据的长度 int length = 0; char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); // telnet登录：输入用户名后，接收全部返回数据 // 网络环境不同，执行情况不同，全部数据有可能一次接收到，也有可能两次才能全部接收到 while (1) { if ((filled = recv(telnet_socket, buffer + length, MAX_MSG_LENGTH, 0)) == ERROR) { printf(\u0026#34;Accept Data Failed! \\n\u0026#34;); return; } length += filled; // 判断是否全部接收完返回数据 // 接收完全部数据，结束循环，即结束接收数据 if (buffer[length - 2 \u0026lt; 0 ? 0 : length - 2] == \u0026#39;:\u0026#39;) { break; } } bzero(back_string, STRING_MAX_SIZE); strncpy(back_string, buffer, (strlen(buffer) \u0026gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(buffer))); printf(\u0026#34;receive data from equipment: %s \\n\u0026#34;, buffer); } // telnet 登录成功，接收telnet server返回数据 // 环境不同，执行情况也会不同，全部数据可能一次接收完，也可能两次接收完，或者三次接收完 int telnet_login_whether_success_receive_data(int telnet_socket) { // 登录成功接收三次数据，telnet server连续三次send // recv单次接收字节流长度filled int filled = 0; // recv接收的全部数据的长度length int length = 0; // telnet server 是否登录成功 int whether; char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); while (1) { if ((filled = recv(telnet_socket, buffer + length, MAX_MSG_LENGTH, 0)) == ERROR) { printf(\u0026#34;Accept Data Failed! \\n\u0026#34;); return -1; } length += filled; // 判断是否全部接收完返回数据 // 数据结尾部分：[xxxx@localhost ~]$ if (buffer[length - 3 \u0026lt; 0 ? 0 : length - 3] == \u0026#39;]\u0026#39;) { // 接收完全部数据，结束接收 // 收到登录成功的全部数据，whether=1 whether = 1; break; } if (buffer[length - 2 \u0026lt; 0 ? 0 : length - 2] == \u0026#39;:\u0026#39;) { // 接收完全部数据，结束接收 // 收到登录失败的全部数据，whether=0 whether = 0; break; } // 只接收最后一次send的全部数据 // bzero(buffer, BUFFER_SIZE); } bzero(back_string, STRING_MAX_SIZE); strncpy(back_string, buffer, (strlen(buffer) \u0026gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(buffer))); printf(\u0026#34;receive data from equipment: %s \\n\u0026#34;, buffer); return whether; } // telnet发送命令到telnet server，命令结尾必须带\u0026#39;\\n\u0026#39; void send_cmd(int telnet_socket, char *cmd) { char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); strncpy(buffer, cmd, (strlen(cmd) \u0026gt; BUFFER_SIZE ? BUFFER_SIZE : strlen(cmd))); if (send(telnet_socket, buffer, (strlen(buffer) + 1), 0) \u0026lt; 0) { printf(\u0026#34;Send cmd Failed! \\n\u0026#34;); return; } } // telnet login 登录到server void telnet_login(int telnet_socket) { // 是否登录成功，用户名和密码是否正确 int whether; // localhost login: tcp_client_receive_data(telnet_socket); while (1) { // 控制端的用户名 strcpy(go_string, \u0026#34;username\u0026#34;); telnet_deal_data(go_string, dealed_string); tcp_client_send_data(telnet_socket); // calos@Password: telnet_login_receive_password(telnet_socket); // 控制端的密码 strcpy(go_string, \u0026#34;password\u0026#34;); telnet_deal_data(go_string, dealed_string); tcp_client_send_data(telnet_socket); // 判断是否登录成功 whether = telnet_login_whether_success_receive_data(telnet_socket); if (whether) { // 登录成功 [xxxx@localhost ~]$ break; } // 登录失败，继续登录 } } // telnet返回数据处理，telnet server有时候一次返回全部数据，有时候两次甚至多次返回全部数据 void telnet_receive_data_add_deal(int telnet_socket) { char receive_buffer[BUFFER_SIZE]; // 做数据处理的temp_buffer char temp_buffer[BUFFER_SIZE]; // 第一次出现某字符的位置location=\u0026amp;receive_buffer+字符的偏移地址 char *location; // 第一次出现某字符的偏移地址 int location_number; // 当次recv数据的长度 int filled = 0; // recv全部数据的长度 int length = 0; // 循环接收全部的返回数据 bzero(receive_buffer, BUFFER_SIZE); while (1) { // 接受telnet server返回数据 if ((filled = recv(telnet_socket, receive_buffer + length, MAX_MSG_LENGTH, 0)) == ERROR) { printf(\u0026#34;Client Recieve Data Failed! \\n\u0026#34;); return; } length += filled; // 判断telnet server返回数据是否全部收到 if (receive_buffer[length - 3 \u0026lt; 0 ? 0 : length - 3] == \u0026#39;]\u0026#39;) { break; } } // 只取第二次返回数据，针对一次性接收完数据的，需要去除第一次send的数据 // 第一次send的数据：xxxx\\r\\n location = strchr(receive_buffer, \u0026#39;\\n\u0026#39;); // 计算偏移地址 location_number = location - receive_buffer + 1; bzero(temp_buffer, BUFFER_SIZE); strncpy(temp_buffer, receive_buffer + location_number, BUFFER_SIZE); bzero(receive_buffer, BUFFER_SIZE); strncpy(receive_buffer, temp_buffer, BUFFER_SIZE); bzero(back_string, STRING_MAX_SIZE); strncpy(back_string, receive_buffer, (strlen(receive_buffer) \u0026gt; STRING_MAX_SIZE ? STRING_MAX_SIZE : strlen(receive_buffer))); printf(\u0026#34;receive data from equipment: %s \\n\u0026#34;, back_string); } // 当前设备操作结束条件：控制端输入END，结束当前设备操作 int finish_equipment_operation(int sock) { char buffer[BUFFER_SIZE]; bzero(buffer, BUFFER_SIZE); strncpy(buffer, go_string, (strlen(go_string) \u0026gt; BUFFER_SIZE ? BUFFER_SIZE : strlen(go_string))); if (strcmp(buffer, \u0026#34;END\u0026#34;) == 0) { close(sock); return 1; } else { return 0; } } int main(void) { int telnet_socket = tcp_client_conn(TELNET_SERVER_NAME, TELNET_SERVER_PORT); if (telnet_socket \u0026lt; 0) { return -1; } // telnet 自动协商 negotiate(telnet_socket); // 登录 telnet_login(telnet_socket); //命令回显 while (1) { // 输入需要执行的命令到go_string strcpy(go_string, \u0026#34;ll\u0026#34;); telnet_deal_data(go_string, dealed_string); send_cmd(telnet_socket, dealed_string); telnet_receive_data_add_deal(telnet_socket); // 设备操作结束条件 if (finish_equipment_operation(telnet_socket)) { break; } } // 异常退出，关闭socket close(telnet_socket); return 0; } 原文地址: VxWorks下Telnet客户端的C语言实现代码\n","date":"2024-12-31","externalUrl":null,"permalink":"/app/c-code-to-implement-telnet-client-in-vxworks/","section":"Apps","summary":"\u003ch2 class=\"relative group\"\u003eTelnet client连接过程 \n    \u003cdiv id=\"telnet-client%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#telnet-client%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTCP连接telnet  server 23端口\u003c/li\u003e\n\u003cli\u003eNVT扩展自动协商\u003c/li\u003e\n\u003cli\u003e用户名+密码登录\u003c/li\u003e\n\u003cli\u003e通过telnet server端命令行交互\u003c/li\u003e\n\u003cli\u003e退出登录\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e概述 \n    \u003cdiv id=\"%E6%A6%82%E8%BF%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%A6%82%E8%BF%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eTelnet 协议是 TCP/IP 协议族中 应用最广泛的协议。\u003c/p\u003e","title":"VxWorks下Telnet客户端的C语言实现代码","type":"app"},{"content":"","date":"2024-12-31","externalUrl":null,"permalink":"/tags/etx/","section":"Tags","summary":"","title":"ETX","type":"tags"},{"content":" 作者：屈继楠 付梦印 刘华 邓志红\n引言 # 车辆导航是一门融合了汽车、计算机、通信、交通、系统科学等领域技术的课题，一直是国内外众多高科技公司和高校研究的重点。对比而言，国内的导航系统发展比较缓慢，在硬件制造、软件功能、电子地图等方面与国外都有较大差距，迄今为止，真正实用的高质量导航产品寥寥无几；而国外的导航系统虽然软硬件水平先进，但受电子地图数据库等因素的制约，也没有大规模进入国内市场。\n近年来，嵌入式系统凭借强大的功能、小巧的体积、极低的功耗等优良特性得以突飞猛进的发展，逐渐渗透到了生活的各个方面，为车辆导航系统的发展带来了新的动力。本文介绍了一种嵌入式车辆导航系统的设计方案，采用基于X86架构的ETX（Embedded Technology Extended）硬件平台和VxWorks嵌入式操作系统，在软硬件方面都能较好的满足导航系统的要求，具有良好的应用前景。\n车辆导航系统的组成 # 本系统的功能框图如图-1所示，对各部分简要介绍如下：\n电子地图数据库：包含以预定格式存贮的数字地图信息，是系统的软件平台 定位模块：通过GPS、惯性导航系统或移动通信等方法对车辆进行定位 地图匹配模块：通过适当的匹配和识别过程来确定车辆在地图上的位置 路径规划：根据地图数据库及实时定位信息帮助驾驶员规划路线 路径引导：引导用户沿着所规划的路径行驶 人机接口：提供友好的界面允许用户与系统进行人机交互 无线通讯模块：允许用户与监控中心等部门实时交换信息 结合实际的软硬件结构，本系统具体的框图如图-2所示，分成了四个层：最底层为硬件平台层，包含了ETX嵌入式CPU模块以及必要的传感器/子模块。上面三层为软件层，其中设备驱动层在硬件平台和操作系统之间充当桥梁的作用，为上一层提供了与硬件设备无关的统一接口；VxWorks系统层提供库函数、应用程序接口、任务调度机制等为用户程序提供支持；应用软件层是用户自行开发的程序，这里主要包括电子地图和导航应用程序，也是本系统的核心部分。下面从硬件和软件两方面来对系统进行介绍。\n系统的硬件结构 # （1）CPU模块\n车辆导航系统对硬件平台的要求为：小型化、低功耗、接口丰富，并能适应复杂的环境。本系统选用的ETX嵌入式CPU模块能够完全满足这些要求。它采用了Intel Pentium III处理器，使用ACPI，APM1.2电源管理减低了功耗，使系统无需风扇装置散热。此外它采用了VIA VT8603/VT82C686A芯片组、S3 Savage 4显卡和VIA-enhanced 声卡，具有2个EIDE 接口, 支持Ultra DMA/33，以及4个USB 1.1，2个串口，1个EPP并口等。ETX还提供了ISA总线接口和PCI总线接口，并具有看门狗，可以有效的解决死机问题。背面的4×100pin总线定义了各种标准接口信号，使用时只需在母板设计对应的插座即可，开发起来非常方便\n（2）串口扩展模块\n考虑到系统需要多个串口（与上位机通信、接收GPS信息、收发短消息、与语音模块通信等），而ETX模块只自带了两个串口，故采用了 TL16C554进行串口扩展。它内部带有16字节收发FIFO的通用异步收发器，具有独立的收发控制电路控制4路标准的串行接口，通过软件可分别设置每一路的中断允许、波特率、数据帧格式等信息。TL16C554与ETX的ISA总线相连，通过一片CPLD完成两者时序的转换。由于系统的中断资源比较紧张，而且考虑到各子模块的数据不是很频繁，因此采用了4个扩展串口共享中断的方案。\n（3）路径引导模块\n本系统通过语音方式进行路径引导，采用了安徽科大讯飞公司生产的XF-S3111中文语音合成芯片。它是利用嵌入式中文语音合成领域的最新研究成果 ——InterSound3.0中文语音合成系统设计的一款中文语音合成芯片，通过异步串口接收待合成的文本，直接合成为语音输出，体积较小，使用方便，是一种完整的物美价廉的语音解决方案。\n（4）无线通讯模块\n本系统的无线通讯部分采用了短消息方式，选用了深圳科灵通科技有限公司生产的短消息模块DTR2000。它主要由西门子公司生产的工业级GSM模块和一款高性能的处理器组成，可通过短消息功能实现无线数据传送的功能，且支持中文传输。其传输数据透明，协议简单，能够方便的进行模块之间以及模块与手机之间的通讯。\n（5）其它\n本系统采用了GPS定位方式，通过彩色LCD进行电子地图及定位点的显示，并采用了可与ETX直接相连的CF卡作为存储设备。\n系统的软件设计 # 由于车辆导航系统对多任务性、实时性、稳定性的要求比较高，因此本系统采用了VxWorks嵌入式操作系统。它包括了进程管理、存储管理、设备管理、文件系统管理、网络协议及系统应用等几个部分，而且高度可裁减，只占用很小的存储空间，保证了其能以较高的效率运行于导航系统中。VxWorks包括微内核wind、高级的网络支持、强有力的文件系统和I/O管理、C++和其他标准支持等核心功能。微内核wind处于VxWorks操作系统的核心，支持所有的实时特征：快速任务切换、中断支持、抢占式和时间片轮转调度等，能够很好的满足导航系统对实时性和多任务的要求。\n本系统的软件功能框图如图-3所示，分为VxWorks环境下的驱动程序和应用软件两部分。前者主要是对TL16C554驱动的开发，而其它设备（如显卡，网卡等）由于VxWorks自带了X86的相关驱动而不必涉及。TL16C554的驱动开发可参照VxWorks自带的串行驱动模板来进行,这里只简单描述一下开发步骤。VxWorks系统的串行设备驱动不是直接挂在IO系统中，而是由虚拟设备ttyDrv在中间充当转换层。因此驱动需要根据系统接口实现驱动并挂到ttyDrv上。首先需要修改config.h、sysSerial.c等文件中的相关参数，然后再编写具体的驱动程序实现设备的 I/O操作，包括TL16C554的初始化函数、I/O控制函数、中断处理函数等。这样，系统在初始化时就会将设备和驱动程序安装好，应用程序就可以按照与设备无关的统一方式进行I/O操作了。\n应用软件的开发包括电子地图和导航应用程序设计两部分的设计：\n（1）电子地图的设计\n电子地图的设计包括图形界面和地图数据库两部分。本系统通过VxWorks的WindML（Wind River Multimedia Library）实现了电子地图的图形界面。WindML主要是用来实现基本的图形、视频和音频技术以及设计标准设备驱动程序框架，它提供了一个统一的图形硬件接口以及处理输入设备和输入设备事件的能力。电子地图数据库的数据结构采用了Arc—Node结构。该结构的基本原理是采用“以直代曲”的思想，即在允许的精度范围内，通过加入多个节点将现实中的真实道路用一系列线段来模拟或近似表示，整个道路网络就是由Arc（小段的线段）和Node（Arc的两个端点）组成，并具有明确的拓扑关系，可以实现路径规划。本系统实现了北京市四环以内的电子地图，并实现了地图浏览、地点查询、路径规划等功能。\n（2）导航应用程序的设计\n导航应用程序包括了对电子地图的操作、GPS定位、收发短消息、语音提示、人机接口等功能的实现。在设计中，根据VxWorks提供的良好的多任务特性，将不同的导航功能模块分给了不同任务去执行，通过任务间通信机制保证多任务的同步。其中系统的主任务负责实现硬件设备的初始化（如串口、看门狗的配置等）、电子地图的初始化和首次显示、发起子任务等功能，其流程图可如图-4所示。\n主任务中发起了四个子任务，分别负责响应用户的输入、标准串口的数据输入、ISA总线16C554的数据输入以及实现路径规划算法。前三个功能独立出来是因为这些功能的触发时间都是不确定的，需要单独监视；最后一个则因为需要较大的运算量。这里只以接收串口数据的子任务为例进行分析。该任务需要监视两个串口的信息：GPS数据和从语音模块返回的状态信息。VxWorks将I/O系统设计成为与设备无关的接口，因此对串口的操作可以视为对文件的操作。串口的打开，关闭和写操作均比较简单，而串口的读操作采用了select函数，利用其触发机制阻塞任务。有数据到来时，任务才会被激活并从串口读取数据，然后通过任务间通信机制，通知主任务进行相应的处理，如进行地图更新、输出语音提示等操作。\n结束语 # 经过实验，本系统能够稳定可靠的运行。系统的实验结果可如图-5所示，展示了其GPS定位和路径规划的功能。本系统功能的实现证明了ETX平台以及VxWorks操作系统的优良性能，表明两者的结合具有开发简单、性能可靠等优点，有着良好的应用前景。\n","date":"2024-12-31","externalUrl":null,"permalink":"/app/design-of-embedded-vehicle-navigation-system-based-on-etx-and-vxworks/","section":"Apps","summary":"\u003cblockquote\u003e\n\u003cp\u003e作者：屈继楠 付梦印 刘华 邓志红\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e引言 \n    \u003cdiv id=\"%E5%BC%95%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%BC%95%E8%A8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e车辆导航是一门融合了汽车、计算机、通信、交通、系统科学等领域技术的课题，一直是国内外众多高科技公司和高校研究的重点。对比而言，国内的导航系统发展比较缓慢，在硬件制造、软件功能、电子地图等方面与国外都有较大差距，迄今为止，真正实用的高质量导航产品寥寥无几；而国外的导航系统虽然软硬件水平先进，但受电子地图数据库等因素的制约，也没有大规模进入国内市场。\u003c/p\u003e","title":"基于ETX与VxWorks的嵌入式车辆导航系统的设计","type":"app"},{"content":"","date":"2024-12-31","externalUrl":null,"permalink":"/tags/embedded/","section":"Tags","summary":"","title":"Embedded","type":"tags"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! 基于VxWorks的嵌入式软件设计 ","date":"2024-12-31","externalUrl":null,"permalink":"/book/embedded-software-design-based-on-vxworks/","section":"Books","summary":"\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./embedded-software-design-based-on-vxworks.png\" alt=\"基于VxWorks的嵌入式软件设计\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://app.filemail.com/d/lzqkbgelmaraxjg\" target=\"_blank\" download\u003e基于VxWorks的嵌入式软件设计\u003c/a\u003e","title":"基于VxWorks的嵌入式软件设计","type":"book"},{"content":"","date":"2024-12-31","externalUrl":null,"permalink":"/tags/guide/","section":"Tags","summary":"","title":"Guide","type":"tags"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! VxWorks 操作系统指南 电子书内容：\n1. VxWorks操作系统概述 1.1.VxWorks 操作系统简介 1.2.VxWorks操作系统内核 1.3.任务管理 1.4.通信、同步和互斥机制 1.5.网络通信 1.6.中断服务程序 1.7.时间管理器 2.VxWorks应用指导 2.1.系统启动 2.2.应用系统配置 2.3.板级支持包BSP 2.4.VxWorks系统任务 2.5.应用软件开发指导 2.6.应用示例分析 ","date":"2024-12-31","externalUrl":null,"permalink":"/book/vxworks-operating-system-guide/","section":"Books","summary":"\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://www.vxworks.net/app/883-vxworks-operating-system-guide\" target=\"_blank\" download\u003eVxWorks 操作系统指南\u003c/a\u003e\n\u003cp\u003e电子书内容：\u003c/p\u003e","title":"VxWorks 操作系统指南","type":"book"},{"content":"","date":"2024-12-30","externalUrl":null,"permalink":"/bsp/","section":"Bsps","summary":"","title":"Bsps","type":"bsp"},{"content":"","date":"2024-12-30","externalUrl":null,"permalink":"/tags/nand/","section":"Tags","summary":"","title":"Nand","type":"tags"},{"content":" 引 言 # 目前，随着电子技术的不断发展，计算机技术也得到飞速的发展，产生了很多新技术。但就计算机的基本结构来说，还是基本采用了冯·诺依曼结构。然而冯·诺依曼结构的一个中心点就是存储一控制，所以存储器在计算机系统中的作用是非常重要的。嵌入式计算机作为计算机中的一个类别，对执行速度和系统可靠性都有较强的要求，这也决定了嵌入式系统不仅要有实时性很强的操作系统，同时也需要一种安全、快速的存储设备。同时，嵌入式系统经常会涉及到海量数据的存储，这就要求存储设备必须具有可靠性高，功耗低，容量大，掉电数据不丢失等特点，而NAND FLASH芯片正好具有这些优点。\nVxWorks是嵌入式领域内公认的最有特色的高性能实时操作系统之一。它以其良好的可靠性和卓越的实时性，被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通信、军事演习、弹道制导、飞机导航等。\n目前，在VxWorks实现上，涉及文件系统的文章不少，但一般都是针对容量较小，操作相对简单的NORFLASH实现的。本文讨论了如何在以AMCC公司的Power PC芯片PPC440epx为核心的嵌入式平台上，利用三星公司的大容量NAND FLASH实现文件系统的具体办法。\n三星NAND FLASH芯片K9F2G08QOM # K9F2G08QOM芯片的容量为256 M×8 b=\u0026ldquo;2\u0026rdquo; Gb的数据区，再加上64 Mb的备用区。一块这种芯片被分为2 048个块，每个块又分为64页，每页由2 KB的数据区加上64 B的备用区组成。如图1所示，列地址为12 b(A11～A0)。当A12为0时，A10～A0确定对每页中2 KP；数据的访问；当A12为1时，访问的是64 B的备用区。由于NANDFLASH芯片在出厂时就可能出现坏块(块中的某个或多个bit不能有效的进行读写)，为了将其标注出来，三星公司保证每个坏块的第一页和第二页备用区第一个byte的数据没有被初始化为0xFF。设计人员要确保在对该芯片进行擦除之前，先将这个信息保留起来(建一个坏块表)。行地址为17 b(A28～A12)。它确定了对2 048块×64页=128 K个页中的某一页进行访问。为了简化NAND FLASH芯片的管脚，其地址和数据信息共享8个I／O管脚，因此，其29 B的地址信息被设计为5个周期进行传输。具体操作如表1所示。\n注：起始地址是列地址；L表示必须置为低电平\n对NAND FLASH的操作流程比较简单，即在第一个周期里送操作相关的命令字，然后送地址，以及相应的数据，最后送确认字。需要说明的是，由于地址、命令和数据都共用8个I／O管脚来进行传输，因此在硬件上必须要有专用的管脚来区分传输类型(在传输命令的时候，命令锁存使能信号CLE有效；在传输地址的时候，地址锁存使能信号ALE有效)。具体的命令字、时序和操作流程在K9F2G08Q0M的数据手册上有较详细的描述，在此不一一详述。\nPPC440epx的NAND FLASH接口 # AMCC公司的PPC440epx芯片是一款性能指标较高的嵌入式CPU芯片，其主频可以达到667 MHz，拥有DDR2接口，可支持千兆以太网，USB 2．0接口，支持浮点运算，同时还支持NAND FLASH芯片。\nPPC440epx使用一个NAND FLASH Controller作为外部NAND FLASH与其外部总线通信的接口电路，该控制器最多可以支持4个NAND FLASH芯片，每个芯片的容量可以为4～256 MB，每页的大小可以为512 B+16 B或者2 KB+64 B。NDFC(NANDFLASH Controller)的存在使得对NAND FLASH的操作变的非常简单。根据前面对K9F2G08Q0M的介绍可知，对NAND FLASH的操作需要在硬件上产生ALE，CLE信号来区分传输类型。NDFC给程序设计人员提供两种实现时序的方法：硬件实现，软件实现。如果是前者， NDFC提供了几个寄存器：命令寄存器、地址寄存器、数据寄存器、配置寄存器和状态寄存器。通过对这几个寄存器执行相应的读／写操作就可以产生相应的时序。例如，如果需要对NAND FLASH写命令字80H，则只需将80H写人命令寄存器即可。NDFC自动将80H送到I／O7～I／O0上，同时置CLE为有效状态。而软件实现方法是根据K9F2G08Q0M的时序要求，通过对硬件控制寄存器中相应的bit写1或者0，使得对应的控制信号为高电平或者低电平。设计人员可以根据自己的情况，选择实现方法。这里推荐采用硬件实现的方法。不过，在有问题时，可采用软件实现的方法来进行调试。\nTrueFFS简介 # TureFFS(Ture Flash File System)是M-Systems公司为VxWorks操作系统定制的实现FLASH块设备的接口。通过使用TFFS，应用程序对FLASH的读写就像对拥有MS-DOS文件系统的磁盘设备操作一样。对于上层设计人员，TFFS屏蔽了底层多种多样FLASH设备的具体细节。同时，由于FLASH存储芯片自身的一些特性(如擦除、编程次数有限并且操作时间较长；容易进入过度编程状态等)，TFFS采用虚拟块、损耗均衡、碎片回收、错误恢复等机制来提高 FLASH的使用寿命，确保数据完整，优化性能。\nTrueFFS的实现 # TrueFFS的基本结构 # TrueFFS由1个核心层和3个功能层组成，它们是翻译层(Translation Layer)、MTD(Memory Tech-nology Drivers Layer)层和Socket层，其结构框图如图2所示。\n交互功能。它包含了控制FLASH映射到块、wear-lev-eling、碎片回收和数据完整性所需的智能化处理功能。目前，有三种不同的翻译层模块可供选择。选择哪一种层需要看所用的FLASH介质是采用NOR-based，还是NAND-based，或者SSFDC-based技术而定。\nMTD(Memory Technology Driver)层实现具体的FLASH芯片底层程序设计，包括读、写、擦、ID识别、映射等功能，以及一些与FLASH芯片相关的参数设置。\nSocket层提供了TrueFFS和硬件之间的接口服务，负责电源管理、检测设备插拔、硬件写保护、窗口管理和向系统注册Socket等；\n核心层将其他3层有机结合起来，另外还处理全局问题，如信号量、碎片回收、计时器和其他系统资源等。\n在VxWorks中，由于翻译层和核心层以二进制形式提供给设计人员的，因此实现TFFS的主要工作集中在对MTD层和Socket层的设计上。\nSocket层的实现 # 如果VxWorks中包含TFFS，在系统启动后，先完成内核的初始化，之后开始进行I/O的初始化操作。系统调用UsrRoot()函数，该函数再调用 tffsDrv()函数，这样就产生如图3所示的调用流程。调用这些函数的目的之一就是注册socket驱动函数。最后的注册操作都是由 xxxRegister()函数完成(这个函数和sysTff-sInit()函数的定义都在sysTffs．c中)的。该函数是通过更新 FLSocket结构体来完成注册操作的。该结构体的定义以及相关细节可以通过阅读VxWorks的帮助文件获得，在此不详述。\nsysTffs．C文件的编写，可以参考其他的BSP来完成。config目录下的任何一个BSP都有该文件，设计人员可以复制其中一个到自己的BSP目录下。例如：复制wrPpmc440gp目录下的sysTffs．c文件，再根据自己的硬件电路修改FLASH BASE ADRS以及FLASHSIZE的宏定义，同时添加宏定义：#define INCLUDE_MTD_NAND。其他地方一般不需要改动。\nMTD层驱动程序的实现 # 要创建一个TFFS块设备，首先应该调用函数tffsDevCreate()，这样就产生了如图4所示的一系列的调用函数。系统通过这一系列的调用函数来确认具体的MTD层程序。确认过程在flIdentifyFlash()函数中完成。flIdentifyFlash()通过逐个执行 xxxIdentify()表中的程序来确定合适的MTD。如果系统只有一种FLASH，则只需写一个Identify()函数可。与Socket层类似，MTD层的核心工作也是针对一个数据结构(FLFLASH)而进行的初始化操作。通过初始化操作来注册FLASH芯片的处理函数，具体的实现是在函数 xxxldentify()中完成的。\n根据前面的介绍知道，MTD层的主要功能是实现对FLASH芯片的读、写、擦、ID识别、映射等操作。而对不同FLASH芯片的相应操作是有一定差别的，所以使用不同的FLASH芯片时，MTD层的程序设计也是不一样的。开发人员的工作是根据系统使用的具体FLASH芯片来完成相应的程序设计。\nTornado提供了几种FLASH的TrueFFS MTD层驱动的参考设计。在installDir＼target＼src＼drv＼tffs中，主要包括Intel，AMD等公司的几种FLASH的 TrueFFS MTD层驱动。虽然没有需要的K9F2G08驱动程序，但可以根据其结构来设计自己的MTD程序。具体做法是在BSP目录下建立一个MTD层驱动文件，将其取名为K9F2G08Mtd．C。在该文件中首先编写函数nandMTDIdentify()，如下所示为程序片段：\n完成上述代码后，剩下的工作就是完成在函数nandMTDIdentify()中引用的readFlashID()，nand-MTDRead()。 nandMTDWrite()，nandMTDErase()，nandMTDMap()这几个函数的代码编写。由于不同的FLASH芯片，时序不同，因此这几个函数的实现也不同。必须根据芯片K9F2G08的数据手册上时序的要求，对PPC440epx的相应寄存器进行读／写操作，以完成这些功能。由于篇幅原因，这几个函数的具体代码就不再赘述。建议在Boot Loader工作正常后，先在应用程序中对这些函数进行调试。这样就可以利用单步和断点等工具进行调试，并且在修改后可立即通过网络下载程序。\nTrueFFS的配置 # 在完成上述代码的编写后，还要做如下工作：在配置文件config．h中增加定义INCLUDE_TFFS和IN-CLUDE_DOSFS，使得 TrueFFS组件和DOS文件系统被包含进来。并且要在MakeFile文件MACH_EXTRA一项中添加K9F2G08Mtd．o，这样可将 TureFFS文件驱动程序加入系统。另外，还要在tffsConfig．c文件中的mtdTable[]表中添加上述的函数nandMTDI- dentify。\n结 语 # 在此介绍如何在由AMCC公司的CPU芯片PPC440epx、三星公司的NAND FLASH构成的硬件平台上和VxWorks软件平台上，实现TrueFFS。按照上述设计流程，实现了NAND FLASH的驱动程序设计。能够对K9F2G08进行正常的读、写、擦、ID识别、映射等操作。同时，在VxWorks操作系统上，实现了 TrueFFS。这样就提高FLASH使用寿命，确保数据完整，优化了FLAsH的性能。以此为基础的系统在某机载设备上得到成功运用。\n原文以及PDF下载地址: 基于VxWorks的NAND FLASH驱动程序设计\n","date":"2024-12-30","externalUrl":null,"permalink":"/bsp/design-of-nand-flash-driver-based-on-vxworks/","section":"Bsps","summary":"\u003ch2 class=\"relative group\"\u003e引 言 \n    \u003cdiv id=\"%E5%BC%95-%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%BC%95-%E8%A8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e目前，随着电子技术的不断发展，计算机技术也得到飞速的发展，产生了很多新技术。但就计算机的基本结构来说，还是基本采用了冯·诺依曼结构。然而冯·诺依曼结构的一个中心点就是存储一控制，所以存储器在计算机系统中的作用是非常重要的。嵌入式计算机作为计算机中的一个类别，对执行速度和系统可靠性都有较强的要求，这也决定了嵌入式系统不仅要有实时性很强的操作系统，同时也需要一种安全、快速的存储设备。同时，嵌入式系统经常会涉及到海量数据的存储，这就要求存储设备必须具有可靠性高，功耗低，容量大，掉电数据不丢失等特点，而NAND FLASH芯片正好具有这些优点。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e是嵌入式领域内公认的最有特色的高性能实时操作系统之一。它以其良好的可靠性和卓越的实时性，被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通信、军事演习、弹道制导、飞机导航等。\u003c/p\u003e\n\u003cp\u003e目前，在VxWorks实现上，涉及文件系统的文章不少，但一般都是针对容量较小，操作相对简单的NORFLASH实现的。本文讨论了如何在以AMCC公司的Power PC芯片PPC440epx为核心的嵌入式平台上，利用三星公司的大容量NAND FLASH实现文件系统的具体办法。\u003c/p\u003e","title":"基于VxWorks的NAND FLASH驱动程序设计","type":"bsp"},{"content":"","date":"2024-12-23","externalUrl":null,"permalink":"/tags/aircraft/","section":"Tags","summary":"","title":"Aircraft","type":"tags"},{"content":"","date":"2024-12-23","externalUrl":null,"permalink":"/tags/simulation/","section":"Tags","summary":"","title":"Simulation","type":"tags"},{"content":" 摘要: 结合某新型飞机，介绍了一种基于嵌入式实时操作系统VxWorks的总线仿真系统设计方法。使用航空机载总线技术，计算机局域网技术，重点是VxWorks技术，论证并设计了虚实结合的机载数据总线的通信仿真系统，构造了具有远程通信能力的飞机内部设备连接、分析、研究、实验、测试的通用平台。\n关键字: VxWorks、实时系统、航空电子、总线、仿真系统\n引言 # 现代航空工业中，机载航空电子总线系统是连接机载设备的神经中枢，它关系到机载设备之间能否进行正常的通信和共同完成对飞机的控制、操纵、信息综合和通信、导航的任务。因此，对于高可靠性的机载总线系统，要保证飞机机载设备通信的正确性，就必须首先研制总线仿真系统，通过仿真系统的研制和仿真软件的运行，在地面上全面仿真航空电子设备之间的通信，可以缩短航空电子总线研制周期，提高飞机性能。\nVxWorks是由美国WRS (Wind River System)公司开发的微内核高性能可裁剪的可用于机载计算机的一种新型嵌入式实时操作系统。它以其良好的可靠性和卓越的实时性被应用在美国的F-16、FA-18战斗机、B-2隐形轰炸机等飞机上。为了提高国家作战飞机的机载计算机水平，与国际接轨达到国际先进水平，我国已经开始进行开发研制并取得一定成绩。本文采用VxWorks开发研制的，基于某型飞机机载总线仿真系统也已获得成功。\n实时操作系统与VxWorks # 实时性与实时操作系统 # 实时操作系统是能够在限定的时间内执行完指定的功能，并能在限定的时间内对外部的异步事件做出响应的操作系统。对一个实时操作系统来讲，系统本身的中断延迟、同步时间和上下文切换时间是3个决定性的因素。\nVxWorks简介 # VxWorks是以高可靠性标准设计的实时操作系统，系统响应时间达微秒，是目前世界上应用最为广泛的实时操作系统之一。VxWorks可以处理多发的而且是并发的随机事件，这是通过多进程（多任务）运行机制来完成的。其高性能的微内核Wind包括多任务调度（采用优先级抢占方式）任务间的同步和进程间通信机制。以及中断处理。看门狗和内存管理机制。Wind使用中断驱动和优先级的方式，它缩短了上下文转换的时间开销和中断的延时，满足更强的实时性要求。\n作为嵌入式系统开发，VxWorks开发过程采用主机、目标机体系结构，如图1所示，将开发工具放在主机上，将操作系统的核心模块放在目标机上，操作系统提供对跟踪调试进行支持的手段。VxWorks提供的Tornado Ⅱ集成开发环境十分友好，并提供了多种开发工具和手段，集设计。开发。分析等特性于一体，同时对目标机系统的影响做到最小。\n系统整体方案 # 依据某型飞机总线标准开发的仿真系统，可以实时截获和分析多种飞机内部的数据流，提供电子系统的检测与故障诊断，为教学、科研以及新机部队提供分析、研究和开发的技术支持。\n该仿真系统由带有配套软件系统的RT和服务器以及远程传输设备组成。基本工作原理如图2所示：\nRT通过SBI/MBI接口卡经过网络与仿真计算机相连，构成实总线系统，用来对飞机内部数据进行实时截获、分析DRT之间还可通过网卡直接相连，构成虚总线系统，用来模拟真实总线上数据的传输并驱动各种仿真设备。仿真计算机与安装有Tornado Ⅱ集成开发环境的标准PC机（主机）相连。同时系统可以进行远程通讯，为部队与院校联合分析、诊断机载设备故障形成了一个有效的数据管理中心。\n仿真计算机采用Motorola超级小型机，PowerPC处理器，VxWorks实时操作系统，在主机目标机体系结构中它是作为目标机（Target）该机型是一个松耦合多处理机系统，仿真计算机作为整个飞行仿真系统的核心，主要负责完成输入输出及各节点任务之间的协调、实时数据存储和大量的科学计算，包括飞行方程解算、控制率解算、模型解算等。主机（Host）采用WINDOWS NT4.0操作系统。主机作为管理系统控制台（人机界面），主要负责人机交互，数据监测、数据管理等，目的是为用户提供一个图形化的人机接口。\n仿真系统软件主要实现以下功能：\n驱动SBI/MBI接口板工作 以数字量或模拟量的形式编辑数据 在实/虚总线间传输数据 数据的数字量和真实值之间的转换 驱动仿真设备 远程数据传输 VxWorks的实际应用 # 在开发过程中主机一方是一台安装有Tornado Ⅱ集成开发环境的标准PC机，它通过网络与目标机（仿真计算机）相连。其开发过程主要可以对照图3加以说明：\n在Tornado Ⅱ集成环境的Editor中用C++语言编写应用程序，并利用Diab C++ Compliler嵌入式编译器编译。 制作引导盘，并配置TargetServer为调试程序做准备TargetServer管理主机一方的，Tornado工具与目标机上，TargetAgent之间的通信，在主机工具能够调试目标机上的应用程序之前必须配置并启动TargetServer。 用引导盘启动目标机，同时在主机一方启动TargetServer建立主机与目标机的连接，下载源代码编译生成的“，out”文件，这样就可以在主机上通过网络对目标机进行各种调试。从图2可以看到Shell、Debugger、WindView 均可以参与调试，它们完成不同的功能。目前采用的是Debugger，这个高性能的调试器具有最新的提高生产率的图形化特征，可以成组地观察表达式的观察窗口，迅速改变变量、寄存器和局部变量的值，并通过信息归整和分类的方法有效地提供信息。 程序调试无误后就可以与操作系统合二为一，形成一个VxWorks文件。 问题的解决 # 在系统设计过程中涉及几个典型的问题，其解决方法如下:\n多控件的访问 # 仿真软件的界面由42个按钮和，34个文本框组成，用VC++的MFC Class Wizard时，不仅需要对每一个控件生成对象和相应的消息响应函数，还要依次对每一个控件进行消息映射，代码量巨大而且难于管理。\n在本系统中，为了方便地访问到每个控件对象，采用了控件数组，对于控件数组的消息映射以及消息响应函数，使用宏ON_COMMAND_SCOPE添加消息映射，对于同一类控件用一个消息响应函数，并给每个控件分配一个ID号，利用消息响应函数OnClickCommand（UNIT id）捕捉用户的按键动作，根据ID触发相应的事件进行处理。\n多线程的同步 # 为了协调多个并发线程的同步，采用了VC++6.0的互斥机制，即同步对象CMutex用于访问接收缓冲区。在使用缓冲区时，线程ReceiveThread需要调用CMutex类的lock（）函数，获得对缓冲区的访问权，然后才可以读写缓冲区。如果有其他线程正在访问，线程ReceiveThread只能等待。使用结束后，再调用CMutex类的unlock（）函数，释放缓冲区的访问权。下面是互斥访问缓冲区的框架代码：\nCDatadeal*pDlg pDlg-\u0026gt;m_BufferMutex.lock（）；//申请 ...//访问缓冲区 pDlg-\u0026gt;m_BufferMutex.unlock（）；//退出 多客户请求的处理 # 虚总线设计时，为了同时处理多个RT请求，建立了Socket队列，并把每个客户端的请求加到该对列中：\nCPtrList m_pConnectionList；//建立队列 CSocket*PSocket=new CSocket（）//建立对象 if (m_pListeningSocket-\u0026gt;Accept(*pSocket)) { m_pConnectionList.Addtail(pSocket);//把对象添加到队列中} ...... } 结论与展望 # 本文介绍了一种基于实时嵌入式操作系统VxWorks的某型飞机记载总线仿真系统。在实践中，成功开发出基于VxWorks的飞行仿真系统，仿真周期小于8ms。\nVxWorks运用到机载计算机上使得飞机的稳定性、可靠性、安全性得到巨大提高，相信VxWorks必将在机载计算机中得到很好的应用。\n（文章选自《火力与指挥控制》作者：闫莉，王勇，作者单位：空军工程大学工程学院，转载此文章仅以传播知识为目的，如有任何版权问题请及时联系我们！）\n","date":"2024-12-23","externalUrl":null,"permalink":"/app/certain-aircraft-airborne-data-bus-simulation-system-based-on-vxworks/","section":"Apps","summary":"\u003cblockquote\u003e\n\u003cp\u003e摘要: 结合某新型飞机，介绍了一种基于嵌入式实时操作系统VxWorks的总线仿真系统设计方法。使用航空机载总线技术，计算机局域网技术，重点是VxWorks技术，论证并设计了虚实结合的机载数据总线的通信仿真系统，构造了具有远程通信能力的飞机内部设备连接、分析、研究、实验、测试的通用平台。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关键字: VxWorks、实时系统、航空电子、总线、仿真系统\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e引言 \n    \u003cdiv id=\"%E5%BC%95%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%BC%95%E8%A8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e现代航空工业中，机载航空电子总线系统是连接机载设备的神经中枢，它关系到机载设备之间能否进行正常的通信和共同完成对飞机的控制、操纵、信息综合和通信、导航的任务。因此，对于高可靠性的机载总线系统，要保证飞机机载设备通信的正确性，就必须首先研制总线仿真系统，通过仿真系统的研制和仿真软件的运行，在地面上全面仿真航空电子设备之间的通信，可以缩短航空电子总线研制周期，提高飞机性能。\u003c/p\u003e","title":"基于VxWorks的某型飞机机载总线仿真系统","type":"app"},{"content":"","date":"2024-12-07","externalUrl":null,"permalink":"/tags/mpc860/","section":"Tags","summary":"","title":"MPC860","type":"tags"},{"content":" 引 言 # 当前普遍使用的DSP语音处理技术只能对语音进行简单处理，不能适应语音业务的多样化趋势。本文介绍利用MPC860和VxWorks实现综合语音通信平台，支持多板卡、多路语音实时传输，可扩展多路语音共听功能。利用MPC860的通信和信号处理功能，且VxWorks具有占用空间小、执行效率高、方便进行个性化定制和较好的兼容性等特点，所以该综合语音通信平台在功能、硬件结构、体积、功耗以及灵活性上具有较大优势。\n在设计中尽量采用嵌入式开发中的常用器件，以便稍加改动即可应用于其他设计。可以根据实际需要更改系统中语音通道的数目和扩展多路语音共听功能等。\n系统结构及工作原理 # 系统组成及特点 # 整个通信平台由语音通信处理主板和语音采集回放子板组成。语音通信处理主板包括CPU MPC860、FLASH存储器、SDRAM存储器、10/100Mb/s网络接口、RS232串口、BDM调试接口、console接口、供电和复位电路及120pin连接器。通信处理主板的核心MPC860是Motorola公司的一款由MC68360演变而来的通用单片集成嵌入式微处理器，适用于通信和网络系统。该微处理器内部有两个处理器：PowerPC和32位RISC处理器。PowerPC核同内存管理单元(MMU)、指令和数据Cache一同处理高层次应用，CPM则负责完成低层数据通信。两个处理器主要通过共享内存交互。通信处理模块利用SCC，SMC，SPI和I2C串行通道与外部设备通信，其中SCC和SMC支持时分复用。设计中，SCC工作在QMC协议Trans-parent Mode。通信处理模块(CPM)新增了数字信号处理(DSP)功能。语音采集回放子板由语音采集电路、语音回放电路、基于FPGA实现的通信控制器和与语音通信处理主板连接的120pin连接器组成。\n由于MPC860的数据传输速度相比ADC和DAC要快很多，设计相应的逻辑电路控制语音的采集和回放、协调MPC860和数据采集、回放电路之间的通信是保证系统正常工作的关键。文中设计了基于Altera公司的CycloneⅡEP2C8芯片实现的通信控制器来解决这一问题。\n将通信平台分为语音通信处理主板和语音采集回放子板分别设计实现，是为了降低系统开发难度和便于系统维护、升级和扩展。例如语音通信处理主板无需改动即可利用已有的连接器、FEC网络接口和SDRAM存储器等资源与视频编解码芯片、视频压缩/解压缩芯片组成网络视频服务器。\n功能结构和工作原理 # 语音通信处理主板的功能结构如图1所示。\n系统上电后，语音通信处理主板复位电路产生复位信号，MPC860接收到复位信号后，跳转到0X100处开始执行启动代码。按照BSP配置逐步执行CPU初始化、板上其他硬件电路的初始化、操作系统运行所需数据结构的初始化、启动VxWorks WIND内核、创建UserRoot任务、初始化系统中用到的可选扩展模块(如I/O系统、文件系统、网络协议等)、创建任务usrAppInit()，此时语音通信平台准备就绪，可以执行语音通信任务。采集板的功能结构如图2所示，语音通信处理主板启动完毕后，语音采集回放子板可在通信控制器控制下采集和回放语音，并对语音数据进行压缩编解码和IP封装、解封装处理。\n数据处理流程 # MPC860T和ADC AD7825，DAC AD7305之间的通信由通信控制器控制。通信控制器由数据缓冲区(Rx FIFO，Tx FIFO)，基于FSM(有限状态机)实现的控制逻辑(Rx control，Tx control)和8位串并、并串转换器，时钟电路组成。其数据接收过程为：接收控制逻辑(Rx control)控制ADC AD7825将各个通道的语音数字化，并把转换结果存入接收缓冲区(Rx FIFO)，直至Rx FIFO满时Rx control开始向MPC860T提供周期性帧同步信号，频率为32 kHz。MPC860在帧同步信号和时钟信号的驱动下读取Rx FIFO中的数据到SCC数据接收缓冲区。Rx FIFO读空(即读指针追上了写指针)后，Rx control停止向MPC860发送帧同步信号终止数据传输，同时向MPC860发送中断信号IRQ3，MPC860响应中断把数据从接收缓冲区读到接收ring buffer中等待应用程序处理。其数据发送过程为：MPC860完成IP解封装、解压缩后的语音数据将会在检测到发送缓冲区可用时，输出到SCC发送缓冲区，通信控制器提供发送帧同步信号驱动数据传输到Tx FIFO(发送缓冲区)，待到Tx FIFO满时停止发送帧同步信号。数据发送完后，CPM会清零，TxBD中的R位表示MPC860可向SCC发送缓冲区中装入新的数据，为下次传输做准备。\nQMC通信协议 # 多通道控制器(QUICC Multichannel Controler，QMC)是为了实现时分复用数据传输而设计的，它可以把时分复用帧的数据分发到多达64个逻辑通道。该模式下把每一帧的数据划分成若干个时隙(Timeslots)，每时隙8 b。在时隙分配表中规定每时隙数据从属于某个通道，每个通道都有一组特定的缓冲区描述符和相应的缓冲区。一个时隙的数据在收发时被放置在特定的缓冲区里，MPC860T就可把分散的数据聚集在一起发送，或把聚集在一起的数据分发到各自专用的缓冲区，而不需要额外的处理来区分各种各样的数据流。\nBSP 设计实现 # 设计中软件开发主要包括启动代码的编写、操作系统的移植、硬件驱动程序和语音编、解码和IP封装、解封装应用程序。篇幅有限，本文仅介绍BSP移植。BSP即板级支持包，其功能为硬件、软件初始化、工程影像的下载和设备驱动等。\nBSP的定制 # 无论是Bootrom还是VxWorks都要使用BSP代码，BSP定制需要根据硬板配置、系统设计需求、软件功能等实际情况。实际开发过程中，为了缩短产品开发周期，通常以WINDRIVER公司的BSP模板或者第三方公司提供的可供参考的BSP为基础，根据软硬件具体配置进行修改，添加新的程序驱动新增硬件和功能。本课题中先把APC860开发板的BSPMPC860TEVB拷贝到installdir:\\Tornado\\target\\collfig\\ppcs860目录下，主要做下列修改。\nconfig．h文件 # 根据实际情况，需要修改启动行，内存地址、容量等配置，修改部分代码如下:\nmakefile文件的修改 # makefile文件的修改，部分程序如下：\nromInit文件修改 # romlnit.s模块包含了VxWorks在ROM中的入口点romlnit()，它是单板上电以后最先执行的汇编程序代码。该函数功能包括处理器的复位、内存的初始化以及其他的最基本和必要的初始化工作。需要修改的内容如下：\n内部存储器映射寄存器IMMR。该寄存器用来标识内部地址空间的基址，将该寄存器设置为“FF000000”。\nSIU模式配置寄存器SIUMCR。包括有外部总线仲裁器配置，外部master的支持，DEBUG调试端口配置，系统接口引脚配置以及奇偶校验支持，将该寄存器设置为“00E10000”。\nBSP中讨论SDRAM的初始化过程，首先对MAMR寄存器的初始化，再得到UPM的RAM阵列表的地址，然后将RAM阵列表地址中的值写入MPC860 RAM WORDS ARRAY中，最后初始化OR以及BR寄存器。\nppcs860．h # ppcs860．h是参数配置头文件，该文件包含大量宏定义，为使MPC860T正常运行且SCC串口工作在QMC协议透明模式，根据实际需要做了如下配置：\n修改系统常量对应的宏定义：SCCx参数在双端口RAM中存储的起始地址、缓冲区描述符(BD)的基地址、缓冲区和BD的数目等；\n串口和时隙分配表的初始化，主要包括时隙分配、引脚分配等，通过设置SI RAM参数，规定了每个逻辑通道对应的时隙和数据路由，本系统中选择SCC2和TDMB接口实现QMC通信，引脚配置如下：\nPC6 RSYNC，PA2 RXC，PA10 RXD，PA0 TXC。PA11 TXD\nSCC2初始化：设置SCC2工作在QMC模式；\nQMC全局参数初始化：MCBASE(多通道基地址指针)，初始化为SCC2对应外部BD表的基地址，MRBLR(最大接收缓冲区长度)，接收、发送时隙分配表起始地址的指针(Rx S PTR，Tx S PTR)，接收、发送时隙分配表当前时隙的指针(Rx PTR，TxPTR)，中断循环表基地址(INTBASE)，中断循环表下一可用入口的指针(INTPTR)等；\nQMC特定通道参数初始化：TBASE，RBASE(该逻辑通道的缓冲区描述符的起始地址)，TBPTR，RBPTR(当前发送、接收缓冲区描述符指针)，TMR-BLR(最大接收帧长度)等。\n驱动程序 # 驱动程序直接对硬件操作，实现硬件和操作系统、应用程序之间的交互。需要自行编写MPC860 SCC串口驱动程序ppcs860QmcSio．c，通信平台中SCC工作在QMC Transparent模式。ppcs860QmcSio．c文件中包含SIO_DRV_FUNCS结构体中定义的5个函数和中断处理函数ppc860QmcInt()、Qmc逻辑通道复位函数ppc860QmcChannelReset()。ppc860SccIoctl()提供了一些设备控制选项，包括停止数据传送、察看当前通信状态(空闲还是忙)、轮询或中断模式选择等；ppc860sccInt()处理QMC通道的中断请求，通过中断方式实现数据的收发功能；ppc860SccStartuP()函数启动一个发送周期；ppc860SccCallbackInstall()安装回调函数。中断处理函数的功能有：\n提供接收、发送中断处理函数，调用回调函数完成设备和较高层协议之间的数据传送。\n处理数据接收过程中出现的接收数据过长，数据传送被迫终止等异常。由于不需要QMC的轮询模式，因此ppc860SccPollInput()和ppc860SccPollOutput()以NULL函数的形式实现。同时还要编写sysSccSeri-al．c文件，修改sysLib．c文件和usrConfig．c文件。在sysSccQmc．c中提供SCC设备描述符的初始化例程、SCC中断连接例程等；通过修改sysLib．c和usrCon-fig．c文件以实现VxWorks对QMC驱动程序的调用和QMC驱动程序与TTY系统的挂接。\n通道中断处理过程 # 数据收发的核心是中断处理函数。QMC中的所有逻辑通道共享SCC2的中断，SCC2维持有一个全局中断表，表中每一项里面都含有逻辑通道号和中断源，可以被驱动识别以处理不同情况下出现的事件。中断发生时，驱动从SCCE寄存器里面判断全局中断源，如果中断是由逻辑通道引起，中断服务程序便查找全局中断表以找到该逻辑通道，并从中断条目里面检查中断信息以确定是什么类型，再调用相应的收发和错误处理函数。\n数据接收和发送 # 多通道语音通信系统中MPC860T SCC串口时分复用即工作在QMC模式，逻辑通道的通信协议为Trasparent mode，该协议仅传输二进制数据，不对数据流进行位级操作，不区分数据帧中的格式位、起止位和数据位等，不对接收的数据做检错处理，因而具有较高的数据传输速率。\n接收函数由中断服务例程调用。由于是每接收一帧产生一次中断，故接收函数也每次处理一帧的数据。数据的接收由接收描述符RxBD控制。当要接收数据时，接收函数首先需要确定RxBD有效；确定没有问题后，才将数据从接收缓冲区拷贝到接收Ring buffer，并复位RxBD；否则在进行相应错误处理后复位RxBD。接收函数流程如图3所示。\n数据发送不调用中断处理函数，发送函数检测到发送缓冲区可用(即TxBD中R位为1)后，调用回调函数将数据从发送Ring buffer拷贝到串口发送缓冲区(Txbuffer)。这里为发送功能开辟足够大的环形缓冲区(足以容纳应用程序每一帧的数据)。发送函数流程如图4所示。\nBSP调试方法和遇到的问题 # 调试方法 # 开发调试有两种方法，一种是使用仿真器通过BDM(后端调试模式)一步步地跟踪调试，另一种是通过点灯的方式进行所谓的“黑”调。“黑”调的方法是通过“灯”闪、用示波器测片选等，根据外部现象和所编的测试代码进行比较分析来调试程序。进行“黑”调的目的是调通信串口部分代码，宿主机可以通过串口与目标机的通信，然后再调试其他部分。调试流程分成两部分。首先是预内核启动代码(Pre-Kernel Initializa-tion)，待最小内核启动正常后再添加I／O系统、文件系统、网络系统等组件和调试应用程序。使用仿真器Vi-sion Probe通过BDM方式调试BSP并将BootRom映像烧入FLASH。\n调试中遇到的问题 # 系统无法正常复位 在调试过程中，发现MPC860T的CLKOUT引脚无输出信号，系统上电复位过程没有完成，系统无法正常工作。初步判断是硬件问题。用万用表和示波器逐步检查上电复位、硬件复位、软件复位、时钟输入和BDM调试等模块电路，发现正常。判断是BGA焊接出现问题，将芯片取下，重新焊接，系统复位正常，时钟信号输出稳定正常。\n网络无法与外界通信 100 Mb／s快速以太网驱动加载中，网络层协议无法运行，目标板无法与外界网络建立联系。目标板网络启动时发出的MAC地址信息帧外界无法收到。通过仿真器发现程序单步运行正常。经过反复试验和测试，最终发现因SDRAM初始化程序没有运行导致程序运行(需要SDRAM支持突发模式)出错。更改调试方式，将BootRom开始的所有程序烧入FLASH，上电启动，网络正常，目标板与外界建立良好的网络通信。\n结 语 # 该系统在实际测试中话音质量稳定，测试时声音清晰，没有串扰和杂音，没有较大延迟，说明硬件设计正确完备，QMC驱动程序和语音编解码和IP封装与解封装应用程序性能优良。\n如果板卡上语音通道更多，则每帧的时隙增多、长度增大，因为FPGA内部电路所提供的的帧同步信号周期并不改变，所以只是实际数据传输速率提高，可以保证各路语音的同步和实时性。系统中QMC工作在Transparent Mode限制了它的应用范围，如何改进使系统支持多种通信协议是需要进一步研究的问题。\n原文地址: 嵌入式语音通信系统中VxWorks BSP的设计实现\n","date":"2024-12-07","externalUrl":null,"permalink":"/bsp/design-and-implementation-of-vxworks-bsp-in-embedded-speech-communication-system/","section":"Bsps","summary":"\u003ch2 class=\"relative group\"\u003e引 言 \n    \u003cdiv id=\"%E5%BC%95-%E8%A8%80\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%BC%95-%E8%A8%80\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e当前普遍使用的DSP语音处理技术只能对语音进行简单处理，不能适应语音业务的多样化趋势。本文介绍利用MPC860和VxWorks实现综合语音通信平台，支持多板卡、多路语音实时传输，可扩展多路语音共听功能。利用MPC860的通信和信号处理功能，且\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e具有占用空间小、执行效率高、方便进行个性化定制和较好的兼容性等特点，所以该综合语音通信平台在功能、硬件结构、体积、功耗以及灵活性上具有较大优势。\u003c/p\u003e\n\u003cp\u003e在设计中尽量采用嵌入式开发中的常用器件，以便稍加改动即可应用于其他设计。可以根据实际需要更改系统中语音通道的数目和扩展多路语音共听功能等。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e系统结构及工作原理 \n    \u003cdiv id=\"%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\n\u003ch3 class=\"relative group\"\u003e系统组成及特点 \n    \u003cdiv id=\"%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E5%8F%8A%E7%89%B9%E7%82%B9\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E5%8F%8A%E7%89%B9%E7%82%B9\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e整个通信平台由语音通信处理主板和语音采集回放子板组成。语音通信处理主板包括CPU MPC860、FLASH存储器、SDRAM存储器、10/100Mb/s网络接口、RS232串口、BDM调试接口、console接口、供电和复位电路及120pin连接器。通信处理主板的核心MPC860是Motorola公司的一款由MC68360演变而来的通用单片集成嵌入式微处理器，适用于通信和网络系统。该微处理器内部有两个处理器：PowerPC和32位RISC处理器。PowerPC核同内存管理单元(MMU)、指令和数据Cache一同处理高层次应用，CPM则负责完成低层数据通信。两个处理器主要通过共享内存交互。通信处理模块利用SCC，SMC，SPI和I2C串行通道与外部设备通信，其中SCC和SMC支持时分复用。设计中，SCC工作在QMC协议Trans-parent Mode。通信处理模块(CPM)新增了数字信号处理(DSP)功能。语音采集回放子板由语音采集电路、语音回放电路、基于FPGA实现的通信控制器和与语音通信处理主板连接的120pin连接器组成。\u003c/p\u003e","title":"嵌入式语音通信系统中VxWorks BSP的设计实现","type":"bsp"},{"content":"","date":"2024-11-16","externalUrl":null,"permalink":"/tags/aws/","section":"Tags","summary":"","title":"AWS","type":"tags"},{"content":"","date":"2024-11-16","externalUrl":null,"permalink":"/news/","section":"News","summary":"","title":"News","type":"news"},{"content":"","date":"2024-11-16","externalUrl":null,"permalink":"/tags/wind-river/","section":"Tags","summary":"","title":"Wind River","type":"tags"},{"content":"","date":"2024-11-16","externalUrl":null,"permalink":"/tags/wind-river-studio/","section":"Tags","summary":"","title":"Wind River Studio","type":"tags"},{"content":" 关键任务智能系统软件提供商风河公司近日宣布，旗下之Wind River Studio Developer已经可运行在 亚马逊网络服务（AWS）之上，从而把软件定义汽车的创新水平推上新的高度。这个平台目前正在美国硅谷圣克拉拉AWS原型设计与创新实验室（AWS Prototyping and Innovation Lab）展出。\nStudio Developer是一个灵活且开放的边缘到云DevOps平台，帮助优化开发流程，支持产品快速上市有助于优化生产力。企业客户可以在AWS上安装Studio，为云规模安全关键嵌入式边缘平台的自动化构建与测试提供助益。在AWS之上，Studio把云的可扩展性和协作性与生命周期管理所需的大规模应用软件及接口融为一体。\n在美国硅谷圣克拉拉的AWS原型设计与创新实验室内，风河与亚马逊两家公司目前正在现场演示云原生开发和互联汽车软件的更新与部署。在AWS上运行Studio汽车软件应用，可获得端到端嵌入式软件开发体验，有助于优化生产力。此项演示带领用户亲历软件定义汽车从开发、测试到部署的完整流程。特别值得一提的是，Studio软件利用亚马逊弹性计算云 （Amazon EC2）来演示在车辆上构建、测试和部署软件，同时还展示了测试自动化、远程访问测试设备和空中（OTA）更新的功能。\n为了验证Studio的可扩展性，此处还特别演示了Wind River Studio如何实现与生成式人工智能助手Amazon Q的集成。Amazon Q可以帮助用户快速获得紧迫问题的相关答案，立即解决问题、生成内容并采取行动。此项演示通过Amazon Q连接到Amazon CodeWhisperer，这是一个机器学习驱动的通用代码生成器，为用户提供实时的代码建议，横跨AWS和Studio开发平台，向开发人员提供基于人工智能的代码完成技术。\n汽车业正处于一个转折点，因为越来越多的车辆由软件来定义。在硅谷圣克拉拉AWS原型设计与创新实验室呈现我们的技术将如何推动这种创新，对此我们非常自豪。通过携手合作，我们可以在AWS上提供一个交钥匙的端到端解决方案，服务于汽车系统以及其他关键任务领域同类系统的完整生命周期。- by 风河公司总裁 Avijit Sinha\n风河公司是AWS合作伙伴网络（APN）的成员，并为其在AWS市场中的边缘计算产品提供亚马逊机器镜像（AMI)，从而使开发人员可以快速融入嵌入式设备的云开发环境，而不需要在自己的机器上架构本地开发环境。风河以下产品都将在AWS市场中提供：\nVxWorks，业界广泛应用的实时操作系统（RTOS）可直接运行在AWS Graviton云环境中 Wind River Linux，业界先进的嵌入式Linux开发平台，包含全套产品、工具以及生命周期服务，可用于智能边缘设备的建构与支持 Wind River DevSecOps智能边缘工作坊，面向希望采用风河技术的AWS客户 ","date":"2024-11-16","externalUrl":null,"permalink":"/news/wind-river-and-aws-collaborate-to-advance-software-defined-automotive-innovation/","section":"News","summary":"\u003cblockquote\u003e\n\u003cp\u003e关键任务智能系统软件提供商风河公司近日宣布，旗下之Wind River Studio Developer已经可运行在 亚马逊网络服务（AWS）之上，从而把软件定义汽车的创新水平推上新的高度。这个平台目前正在美国硅谷圣克拉拉AWS原型设计与创新实验室（AWS Prototyping and Innovation Lab）展出。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eStudio Developer是一个灵活且开放的边缘到云DevOps平台，帮助优化开发流程，支持产品快速上市有助于优化生产力。企业客户可以在AWS上安装Studio，为云规模安全关键嵌入式边缘平台的自动化构建与测试提供助益。在AWS之上，Studio把云的可扩展性和协作性与生命周期管理所需的大规模应用软件及接口融为一体。\u003c/p\u003e\n\u003cp\u003e在美国硅谷圣克拉拉的AWS原型设计与创新实验室内，风河与亚马逊两家公司目前正在现场演示云原生开发和互联汽车软件的更新与部署。在AWS上运行Studio汽车软件应用，可获得端到端嵌入式软件开发体验，有助于优化生产力。此项演示带领用户亲历软件定义汽车从开发、测试到部署的完整流程。特别值得一提的是，Studio软件利用亚马逊弹性计算云 （Amazon EC2）来演示在车辆上构建、测试和部署软件，同时还展示了测试自动化、远程访问测试设备和空中（OTA）更新的功能。\u003c/p\u003e\n\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./Wind-River-AWS-Automotive.webp\" alt=\"Wind River and AWS collaborate to Advance SDA Innovation\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e","title":"风河携手AWS推进软件定义汽车创新","type":"news"},{"content":"","date":"2024-11-04","externalUrl":null,"permalink":"/tags/program/","section":"Tags","summary":"","title":"Program","type":"tags"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! VxWorks程序开发实践 内容简介 # 本书介绍了嵌入式实时多任务操作系统VxWorks及其主机环境Tornado，并实践性地描述了其上的程序开发过程。书中详细介绍了VxWoks各个重要的组件，包括多任务环境、内存管理、IO系统（包括字符设备）、文件系统和网络通信等。并在每一章的最后都有常见问题解答（FAQ），帮助读者及时地解决开发过程中遇到的问题。\n本书主要面向有一定VxWorks经验或嵌入式经验的软件开发人员，但是部分章节对初学者也非常有帮助，如一些基本概念和一般开发过程。本书能够帮助VxWorks软件开发人员更好地使用平台，并理解其内部工作机制，扩展平台功能。\n目录 # 第一章 WIND RIVER 第二章 TORNADO 第三章 VXWORKS 第四章 多任务环境 第五章 内存管理 第六章 I/O系统 第七章 文件系统 第八章 网络通信 第九章 建立开发环境 第十章 程序开发实践 ","date":"2024-11-04","externalUrl":null,"permalink":"/book/vxworks-program-development-practice/","section":"Books","summary":"\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./vxworks-program-development.jpg\" alt=\"xWorks程序开发实践\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://app.filemail.com/d/uayawmaywrjlswx\" target=\"_blank\" download\u003eVxWorks程序开发实践\u003c/a\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e内容简介 \n    \u003cdiv id=\"%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e本书介绍了嵌入式实时多任务操作系统\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e及其主机环境Tornado，并实践性地描述了其上的程序开发过程。书中详细介绍了VxWoks各个重要的组件，包括多任务环境、内存管理、IO系统（包括字符设备）、文件系统和网络通信等。并在每一章的最后都有常见问题解答（FAQ），帮助读者及时地解决开发过程中遇到的问题。\u003c/p\u003e","title":"VxWorks程序开发实践","type":"book"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! 基于VxWorks的嵌入式实时系统设计 图书简介 # 本书是一本介绍嵌入式系统原理和应用的教材，从介绍嵌入式概况入手，以VxWorks实时操作系统为例，讲述了VxWorks的原理及其运行机制、Tornado开发工具的使用、嵌入式实时系统BSP结构、嵌入式实时系统网络编程以及以SC4510B ARM为硬件的开发系统。\n本书用作通信工程、电子信息等专业的研究生学习嵌入式系统的教材，同时可以作为电子信息学科和航空控制类本科生高年级的教材，也可作为从事嵌入式开发的工程人员的参考书。\n目录 # 第1章绪论 # 1.1嵌入式系统概述 1 1.2嵌入式系统的发展历史 2 1.3嵌入式系统的体系结构 3 1.3.1嵌入式处理器 3 1.3.2嵌入式外围设备 5 1.3.3嵌入式应用软件 5 1.3.4嵌入式操作系统 6 1.4典型的嵌入式操作系统 7 1.5嵌入式系统的应用领域 11 第2章嵌入式实时操作系统VxWorks # 2.1简介 12 2.2VxWorks任务及任务间通信 13 2.2.1多任务机制 13 2.2.2任务状态转变 14 2.2.3Wind任务调度 15 2.2.4任务控制 17 2.2.5任务扩展函数 20 2.2.6任务异常处理 20 2.2.7共享代码和重入 21 2.2.8共享数据结构 22 2.2.9互斥 22 2.2.10信号量 23 2.2.11消息队列 27 2.2.12管道 28 2.2.13任务间网络通信 29 2.2.14信号（signal） 30 2.3VxWorks事件 31 2.3.1pSOS事件 32 2.3.2VxWorks事件 33 2.3.3API比较 35 2.4文件系统 36 2.4.1文件、设备和驱动程序 36 2.4.2基本I/O接口 37 2.4.3缓冲型I/O设备：stdio 38 2.4.4异步输入/输出操作 38 2.4.5VxWorks操作系统中的设备 39 2.4.6与MS-DOS兼容的文件系统：dosFs文件系统 41 2.4.7使用SCSI设备从本地dosFs文件系统启动 43 2.4.8原始文件系统：rawFs文件系统 43 2.4.9磁带文件系统：tapeFs文件系统 44 2.4.10CD-ROM文件系统：cdromFs 45 2.4.11目标服务器文件系统：TSFS 46 2.5中断处理与定时机制 46 2.5.1看门狗定时机制 46 2.5.2中断服务程序 48 2.5.3POSIX时钟和计时器 51 2.5.4POSIX内存上锁接口 52 2.5.5POSIX与Wind的比较 53 2.6目标机工具 54 2.6.1基于目标机的shell 54 2.6.2基于目标机的加载器 55 2.6.3基于目标机的符号表 56 2.7基于VxWorks的C++语言开发 59 2.7.1VxWorks系统下使用C++语言 59 2.7.2初始化和确定静态目标 60 2.7.3使用GNUC++编程 61 2.7.4使用DiabC++编程 65 2.7.5使用C++库 66 2.7.6运行事例演示 67 第3章基于图形用户界面的集成开发环境Tornado及开发实例 # 3.1Tornado简介 69 3.1.1Tornado交叉开发环境 70 3.1.2VxWorks目标机环境 71 3.1.3Tornado主机集成开发环境 71 3.1.4主机与目标机的接口 73 3.2Tornado的安装和启动 74 3.2.1Tornado初步 74 3.2.2建立主机环境 76 3.2.3建立默认的目标机硬件环境 77 3.2.4主机与目标机的通信配置 78 [3] 3.2.5启动VxWorks 79 3.2.6启动Tornado 82 3.2.7启动目标服务器 84 3.2.8显示目标机信息 85 3.3Tornado环境下的工程开发 86 3.3.1设计用户工程 86 3.3.2创建可下载的应用程序 89 3.3.3创建自定义的VxWorks映像 89 3.3.4创建可启动的应用程序 90 3.3.5配置目标机与主机间通信接口 91 3.3.6配置和构建VxWorks启动程序 92 3.4Tornado目标服务器 93 3.4.1简介 94 3.4.2配置和启动目标服务器 94 3.4.3选择目标服务器 95 3.4.4管理目标服务器 96 3.4.5停止目标服务器 97 3.5Tornado主机工具 97 3.5.1shell 97 3.5.2调试器 101 3.5.3浏览器 103 3.6仿真器VxSim 105 3.6.1简介 105 3.6.2集成仿真器 106 3.6.3构建应用程序 107 3.6.4配置VxSim全功能仿真器 107 第4章板级支持包BSP基础 # 4.1BSP简介 110 4.2BSP组织结构 110 4.2.1BSP源文件及包含文件 111 4.2.2生成文件 121 4.2.3必要函数 122 4.2.4可选函数 123 4.3VxWorks引导顺序 124 4.3.1引导过程概述 124 4.3.2相关文件及函数 124 4.4创建一个BSP 127 4.4.1建立开发环境 128 4.4.2编写BSP文件 129 4.4.3编译和下载VxWorks 132 4.4.4调试初始化代码 133 4.4.5启动WDB服务器 135 4.4.6最小化内核 137 4.4.7其他相关问题 138 4.5组件 141 4.5.1组件描述语言 142 4.5.2创建组件 151 4.6硬件设计指导 158 4.6.1体系结构 158 4.6.2内存 159 4.6.3总线 160 4.6.4设备 163 4.7编写驱动程序 166 4.7.1驱动程序规范及要求 166 4.7.2驱动程序开发步骤 170 4.7.3高速缓存相关问题 172 第5章网络编程 # 5.1引言 176 5.2VxWorks网络协议栈 176 5.2.1支持的协议和工具 176 5.2.2设定与网络任务相关的任务优先级 178 5.3数据链路层组件 179 5.3.1以太网驱动支持 179 5.3.2共享内存的底板网络驱动 180 5.3.3用户接口 190 5.4网络协议栈的配置 190 5.4.1配置设置摘要 190 5.4.2创建时配置网络协议栈 191 5.4.3配置TCP/IP 201 5.4.4网络配置协议 210 5.4.5远程访问应用 216 5.5VxWorks套接字 222 5.5.1BSD套接字 223 5.5.2ZBUF套接字 236 第6章S3C4510微控制器开发平台 # 6.1S3C4510微控制器概述 250 6.1.1S3C4510微控制器特点及总体结构 250 6.1.2S3C4510微控制器内部结构 251 6.2S3C4510B微控制器开发平台 259 6.2.1开发板总体结构 260 6.2.2开发板各模块的功能介绍 260 6.3开发板软/硬件调试 262 6.3.1JTAG调试接口 262 6.3.2集成开发组件ADS 264 6.3.3开发板调试举例 267 6.4VxWorks操作系统移植 271 6.4.1编写BSP软件 272 6.4.2VxWorks操作系统的启动过程 277 6.4.3串行设备驱动程序 280 6.4.4网络设备驱动程序 285 结束语 # 参考文献 296\n","date":"2024-11-03","externalUrl":null,"permalink":"/book/embedded-real-time-system-design-based-on-vxworks/","section":"Books","summary":"\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./embedded-real-time-system.png\" alt=\"基于VxWorks的嵌入式实时系统设计\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://app.filemail.com/d/gfovlyqawvrltiz\" target=\"_blank\" download\u003e基于VxWorks的嵌入式实时系统设计\u003c/a\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e图书简介 \n    \u003cdiv id=\"%E5%9B%BE%E4%B9%A6%E7%AE%80%E4%BB%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%9B%BE%E4%B9%A6%E7%AE%80%E4%BB%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e本书是一本介绍\u003ca href=\"https://www.gaitpu.com\" target=\"_blank\"\u003e嵌入式系统\u003c/a\u003e原理和应用的教材，从介绍嵌入式概况入手，以VxWorks\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003e实时操作系统\u003c/a\u003e为例，讲述了VxWorks的原理及其运行机制、Tornado开发工具的使用、嵌入式实时系统\u003ca href=\"https://www.vxworks.net/bsp\" target=\"_blank\"\u003eBSP\u003c/a\u003e结构、嵌入式实时系统网络编程以及以SC4510B ARM为硬件的开发系统。\u003c/p\u003e","title":"基于VxWorks的嵌入式实时系统设计","type":"book"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/tags/data-communication/","section":"Tags","summary":"","title":"Data Communication","type":"tags"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! 基于VxWorks嵌入式系统的数据通信 内容简介 # VxWorks是由美国Wind River公司设计开发的一种嵌入式实时操作系统，具有高可靠性、实时性、广泛的适应性及灵活性，已经被广泛地应用于嵌入式系统的开发和设计中。本书讲述了基于VxWorks嵌入式操作系统的数据通信的设计和开发，着重于VxWorks的工程实践应用。全书共分9章，主要内容包括数据通信基础、串行通信技术、机载数据总线、嵌入式系统开发基础、嵌入式微处理器、VxWorks实时操作系统与应用、Tornado集成开发环境、VxWorks BSP基础及其开发过程、VxWorks操作系统应用实例等。\n本书内容全面系统，讲解通俗易懂，所给实例有很强的实用性和指导性，可作为电子技术类、通信类、软件工程类专业本科生或研究生学习VxWorks的实用书籍，也可作为从事嵌入式系统开发的软件工程师的参考书。\n前言 # 随着电子信息技术、计算机技术和微电子技术的发展，嵌入式系统已经日益成熟和完善，其应用也越来越广泛，小到手机、电子词典、MP3，大到数控设备、航天航空设备等，嵌入式系统已经在工业和生活领域得到了广泛的开发和应用。嵌入式系统产品的研制和应用也已经成为推动国民经济信息化发展的新动力。\nVxWorks操作系统是美国Wind River公司设计开发的一种嵌入式实时操作系统(RTOS)。由于其具有高可靠性、实时性、广泛的适用性及灵活性，已被广泛地应用到通信、军事、航空航天等高精尖和实时性要求很高的领域中。VxWorks作为一款功能强大、独具特色的嵌入式操作系统，已经成为软件工程师采用最多的用于开发嵌入式实时系统的商用实时操作系统之一，并为程序员提供了高效的实时多任务调度、中断管理、实时的系统资源管理以及实时的任务间通信。\n数据通信作为通信技术与计算机技术相结合的一种新兴技术，在信息化高速发展的今天，随着第三代移动通信的推广和普及，在生活中的应用要求越来越高，而在工业控制领域，基于通信总线的数据通信也获得了广泛的应用。因此，基于VxWorks嵌入式系统的数据通信有着广阔的应用空间，已经成功地应用在军事、航天、工业、消费类电子产品等领域中。\n本书共分为9章，内容安排如下：\n第1章主要介绍了几种典型总线的相关背景知识、串行通信基础和ISO/OSI参考模型及相关技术。 第2章介绍了RS-232、RS-422/RS-485接口的特点和应用开发方法，并提供了串口应用实例。 第3章对机载数据总线ARINC-429和MIL-STD-1553B的总线特征、通信控制和接口逻辑等方面做了概述。 第4章对嵌入式系统的基础理论和体系结构做了简要的叙述，并指出了嵌入式系统一般的开发流程。 第5章主要介绍了嵌入式微处理器的体系结构和特点，其中包括PowerPC微处理器和ARM微处理器。 第6章概述了VxWorks操作系统的特点、组成及功能，详细介绍了VxWorks操作系统的应用机制和开发方法。 第7章介绍了Tornado集成开发环境的安装和使用方法。 第8章概述了VxWorks中BSP的基本理论和配置及其开发过程。 第9章通过实例使读者系统地了解基于VxWorks嵌入式系统的开发和设计方法。 本书的特点在于结合了数据通信的理论知识和工程实例，内容丰富翔实，可作为嵌入式系统开发设计人员有效的学习工具和参考资料。\n在策划和编写本书的过程中，本人得到了多位同学的关心和帮助，包括康郁爽、上官瑞春、李亚鹏、李飞翔、单晓明、刘思迪、唐莎、吴宜杰等，在此深表感谢。\n由于编者水平有限，加之时间仓促，书中难免有疏漏和不妥之处，敬请读者予以批评指正。\n相　征(本书作者)\n2010年12月\n目录 # 第1章 数据通信基础 1 # 1.1 概述 1 1.1.1 通信总线的概念 1 1.1.2 通信总线的特点 1 1.1.3 通信总线的技术指标和标准 4 1.2 串行通信基础 5 1.2.1 数据传输理论基础 5 1.2.2 数据编码 7 1.2.3 数据传输方式 9 1.2.4 网络拓扑结构 13 1.2.5 数据交换技术 16 1.3 ISO/OSI参考模型及相关技术 18 1.3.1 OSI协议的体系结构 18 1.3.2 物理层传输介质 25 1.3.3 差错控制 29 1.3.4 信道共享技术 35 1.3.5 网络设备 43 1.4 本章小结 45 第2章 串行通信技术 46 # 2.1 RS-232接口 46 2.1.1 RS-232的基本特性 46 2.1.2 RS-232的连接器 51 2.1.3 RS-232的连接 52 2.1.4 RS-232的电路设计 56 2.2 RS-422/RS-485接口 69 2.2.1 RS-422/RS-485标准 69 2.2.2 RS-232接口到RS-422/RS-485接口的转换 77 2.2.3 基于RS-485接口的通信 80 2.2.4 RS-422/RS-485接口应用电路举例 83 2.3 串口应用实例 84 2.3.1 基于FPGA的传感器数据采集及传输系统简述 84 2.3.2 RS-422接口的功能设计与实现 85 2.4 本章小结 90 第3章 机载数据总线 91 # 3.1 ARINC-429数据总线 91 3.1.1 ARINC-429总线特征 91 3.1.2 ARINC-429数据 94 3.1.3 通信控制 98 3.1.4 接口逻辑 101 3.2 MIL-STD-1553B数据总线 118 3.2.1 MIL-STD-1553B总线特征 118 3.2.2 MIL-STD-1553B数据 121 3.2.3 通信控制 126 3.2.4 接口逻辑 128 3.2.5 总线控制原则 135 3.3 本章小结 136 第4章 嵌入式系统开发基础 137 # 4.1 嵌入式系统的基本理论 137 4.1.1 嵌入式系统的定义 137 4.1.2 嵌入式系统的发展 138 4.1.3 嵌入式系统的特点 139 4.1.4 嵌入式系统的分类 140 4.1.5 嵌入式系统的应用范围 141 4.1.6 嵌入式系统的发展趋势 142 4.2 嵌入式系统的体系结构 143 4.3 嵌入式系统的硬件系统 145 4.3.1 嵌入式处理器 145 4.3.2 嵌入式处理器的发展趋势 148 4.3.3 嵌入式外围接口电路和设备接口 149 4.4 嵌入式系统的软件系统 150 4.4.1 嵌入式系统的软件分类 151 4.4.2 嵌入式操作系统 151 4.4.3 嵌入式操作系统的选择标准 156 4.4.4 嵌入式操作系统的发展趋势 157 4.4.5 板级支持包BSP 158 4.5 嵌入式系统的开发 159 4.5.1 嵌入式系统的开发流程 159 4.5.2 嵌入式应用软件开发 163 4.5.3 嵌入式系统硬件设计 170 4.6 本章小结 171 第5章 嵌入式微处理器 172 # 5.1 嵌入式硬件系统基本架构 172 5.2 嵌入式微处理器概述 173 5.2.1 嵌入式微处理器的体系结构 173 5.2.2 嵌入式处理器的种类 175 5.3 ARM嵌入式微处理器 177 5.3.1 ARM简介 177 5.3.2 ARM内核体系结构 177 5.3.3 基于ARM9的S3C2410X微处理器 184 5.4 PowerPC架构及寄存器概述 202 5.4.1 处理器简述 202 5.4.2 指令的组合和分类 203 5.4.3 已定义类指令的形式 209 5.4.4 异常 209 5.4.5 存储单元的寻址 209 5.4.6 寄存器集 211 5.5 本章小结 227 第6章 VxWorks实时操作系统与应用 228 # 6.1 VxWorks概述 228 6.1.1 VxWorks的特点 228 6.1.2 VxWorks系统的组成及功能 229 6.2 VxWorks系统的应用机制 231 6.2.1 任务管理机制 231 6.2.2 中断处理 233 6.2.3 内存管理 234 6.2.4 I/O与文件系统 236 6.3 VxWorks系统开发方法 237 6.3.1 通信机制的选择 237 6.3.2 正确划分任务 238 6.3.3 合理分配动态内存 238 6.3.4 防止任务异常 239 6.5 本章小结 240 第7章 Tornado集成开发环境 241 # 7.1 Tornado概述 241 7.2 Tornado安装 243 7.2.1 目录与文件 243 7.2.2 安装步骤 244 7.2.3 Tornado注册 248 7.3 Tornado的使用方法 249 7.3.1 创建工程 250 7.3.2 添加文件到工程 252 7.3.3 编译和运行程序 254 7.3.4 监视和调试 258 7.4 本章小结 261 第8章 VxWorks BSP基础及其开发过程 263 # 8.1 BSP基础理论知识 263 8.1.1 BSP概述 263 8.1.2 BSP所要实现的功能 266 8.1.3 BSP的文件结构 268 8.1.4 BSP开发工具 275 8.2 BSP的基本配置和VxWorks的初始化 275 8.2.1 BSP的基本配置 275 8.2.2 VxWorks的初始化 279 8.3 BSP的开发要求及开发过程 285 8.3.1 开发要求 285 8.3.2 获得参考BSP和相关代码模板 288 8.3.3 安装和设置BSP开发环境 289 8.3.4 编辑修改BSP文件 293 8.3.5 构造和下载VxWorks映像 297 8.3.6 调试初始化代码 299 8.3.7 整理、测试BSP和编写文档 299 8.4 BSP中设备驱动程序的开发 301 8.5 本章小结 302 第9章 VxWorks操作系统应用实例 303 # 9.1 系统整体构架 303 9.1.1 系统的工作原理 304 9.1.2 系统的方案设计 305 9.2 系统关键技术的实现 306 9.2.1 通信协议的设计 306 9.2.2 系统健壮性设计 311 9.3 数据通信与控制系统的软件设计方案 312 9.3.1 软件设计需注意的问题 312 9.3.2 软件总体设计 313 9.3.3 任务模块设计 317 9.3.4 任务调度设计 321 9.4 本章小结 323 参考文献 324 ","date":"2024-11-02","externalUrl":null,"permalink":"/book/data-communication-based-on-vxworks-embedded-system/","section":"Books","summary":"\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./data-communication-based-on-vxworks.jpeg\" alt=\"基于VxWorks嵌入式系统的数据通信\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://app.filemail.com/d/imprynhhcksnshb\" target=\"_blank\" download\u003e基于VxWorks嵌入式系统的数据通信\u003c/a\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e内容简介 \n    \u003cdiv id=\"%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e是由美国Wind River公司设计开发的一种嵌入式实时操作系统，具有高可靠性、实时性、广泛的适应性及灵活性，已经被广泛地应用于嵌入式系统的开发和设计中。本书讲述了基于VxWorks嵌入式操作系统的数据通信的设计和开发，着重于VxWorks的工程实践应用。全书共分9章，主要内容包括数据通信基础、串行通信技术、机载数据总线、嵌入式系统开发基础、嵌入式微处理器、VxWorks实时操作系统与应用、Tornado集成开发环境、\u003ca href=\"https://www.vxworks.net/bsp\" target=\"_blank\"\u003eVxWorks BSP\u003c/a\u003e基础及其开发过程、VxWorks操作系统应用实例等。\u003c/p\u003e","title":"基于VxWorks嵌入式系统的数据通信","type":"book"},{"content":" 免费下载说明： 网络资源，整理仅供学习参考! 嵌入式VxWorks系统开发与应用 本书详细介绍了当今流行的嵌入式操作系统VxWorks，首先概括 VxWorks 操作系统的基本知识，如任务管理、任务间通信机制、内存管理以及定时管理等内容，说明了嵌入式操作系统的实现关键。然后，结合作者多年的嵌入式系统的开发应用经验，详细阐述了 VxWorks 系统中 BSP 和应用程序的开发技巧，并提供了多个应用实例及分析设计。\n本书适用于嵌入式系统开发人员作为参考手册使用\n第 1 章 概述 # 1.1 嵌入式实时操作系统 VxWorks 1.1.1 VxWorks 的应用领域 1.1.2 VxWorks 系统的特点 1.1.3 VxWorks 的可用主机/目标机 1.2 Tornado 开发环境 1.2.1 Tornado 核心工具 1.2.2 WindPower 工具 1.3 Tornado 嵌入式开发系统可选组件 1.3.1 板级支持包 BSP Developer\u0026#39;s Kit 1.3.2 虚拟内存接口 VxVMI 1.3.3 支持紧耦合共享内存多处理器结构的 VxMP 1.3.4 支持紧耦合分布式多处理器结构的 VxDCOM 1.3.5 支持松耦合分布式多处理器结构的 VxFUSION 1.3.6 闪存文件系统 TrueFFS for Tornado 第 2 章 VxWorks 系统基本理论 # 2.1 VxWorks 系统概述 2.2 VxWorks 系统内核及组件 2.2.1 任务管理 2.2.2 任务间通信和同步机制 2.2.3 中断机制 2.2.4 定时管理机制 2.2.5 内存管理 2.2.6 I/O 与文件系统 2.3 VxWorks 系统开发经验 2.3.1 正确划分任务 2.3.2 防止任务异常 2.3.3 正确运用函数的可重入性 2.3.4 使用名称访问资源 2.3.5 用户任务优先级确定 2.4 VxWorks 系统开发模型概述 2.4.1 系统启动 2.4.2 应用系统配置 第 3 章 VxWorks 系统 BSP 基本概念 # 3.1 BSP 基础 3.2 BSP 文件结构 3.3 VxWorks 系统的 BSP 开发过程 3.3.1 建立 BSP 开发环境 3.3.2 编辑修改 BSP 文件 3.3.3 生成目标文件 bootrom 和 VxWorks 映像 3.3.4 基于 ROM 映像的初始化 3.4 BSP 中设备驱动程序的开发 第 4 章 VxWorks 系统 BSP 开发实例 # 4.1 MPC8260 处理器的组成与结构 4.1.1 基本功能模块 4.1.2 内核 603e 的组成 4.1.3 SIU 的结构 4.1.4 CPM 的模块结构 4.2 MPC8260 通信处理模块 4.2.1 内部存储空间 4.2.2 缓冲描述符 BD 4.2.3 参数 RAM 4.2.4 快速以太网控制器的功能 4.2.5 快速以太网控制器的接收过程 4.2.6 快速以太网控制器的发送过程 4.3 MPC8260 编程特点 4.3.1 数据格式和指令格式 4.3.2 指令分类 4.3.3 特殊功能寄存器 4.3.4 高速缓存控制 4.4 BSP 最小系统设计 4.4.1 BOOT ROM 配置编程 4.4.2 程序存储区 Flash 配置 4.4.3 SDRAM 初始化 4.4.4 CPU 初始化 4.4.5 系统软复位 4.5 接口驱动设计 4.5.1 MPC8260 SCC1-Ethernet 接口的设计 4.5.2 MPC8260 SMC1-RS232 接口的设计 4.6 BSP 的调试和测试 4.6.1 测试内容 4.6.2 测试项目及结果 第 5 章 VxWorks 系统开发环境 Tornado # 5.1 Tornado 开发环境概述 5.2 Tornado 开发环境的安装 5.2.1 安装 Tornado 开发环境 5.2.2 注册 Tornado 开发环境 5.3 初步使用 Tornado 环境 5.3.1 Tornado 工程的类型 5.3.2 启动 Tornado 环境 5.3.3 创建工作区和工程 5.3.4 添加文件到工作区和工程 5.3.5 编译工程 5.3.6 下载工程到 VxWorks 目标模拟器 5.3.7 在 Tornado Shell 下运行应用程序 5.4 监视与调试 5.4.1 检查内存消耗 5.4.2 软件逻辑分析 5.4.3 应用程序调试 第 6 章 VxWorks 系统编译器 # 6.1 Make 管理项目概述 6.2 编写 Makefile 的规则 6.2.1 虚拟目标 6.2.2 Makefile 的变量 6.2.3 make 的变量 6.2.4 隐式规则 6.2.5 模式规则 6.3 Make 命令 6.4 Makefile 实例分析 6.5 Gcc 的基本概念 6.6 Gcc 命令 6.7 Gcc 扩展 第 7 章 VxWorks 系统应用实例 # 7.1 VxWorks 系统中的任务划分 7.2 任务间通信机制 7.3 Wind 内核功能 7.4 中断处理 7.5 Sockets 通信 7.6 任务多实例应用 7.7 C++应用 7.8 数据报应用 7.9 虚拟内存设备驱动 7.10 RamDisk 驱动 7.11 WDB 应用 7.12 任务软调度实例一 7.13 任务软调度实例二 ","date":"2024-11-02","externalUrl":null,"permalink":"/book/embedded-vxworks-system-design-and-application/","section":"Books","summary":"\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./embedded-vxworks-system-design-and-application.webp\" alt=\"嵌入式VxWorks系统开发与应用\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n免费下载说明：\u003c/br\u003e\n网络资源，整理仅供学习参考!\n\u003c/blockquote\u003e\n\n\n  \u003cspan class=\"relative inline-block align-text-bottom icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\n\u003cpath fill=\"currentColor\" d=\"M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32V274.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V416c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zM432 456c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z\"/\u003e\u003c/svg\u003e\n  \u003c/span\u003e\n\n\u003ca href=\"https://app.filemail.com/d/blvnxpxpguyennn\" target=\"_blank\" download\u003e嵌入式VxWorks系统开发与应用\u003c/a\u003e\n\u003cp\u003e本书详细介绍了当今流行的嵌入式操作系统\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e，首先概括 VxWorks 操作系统的基本知识，如任务管理、任务间通信机制、内存管理以及定时管理等内容，说明了嵌入式操作系统的实现关键。然后，结合作者多年的嵌入式系统的开发应用经验，详细阐述了 VxWorks 系统中 \u003ca href=\"https://www.vxworks7.com/bsp/\" target=\"_blank\"\u003eBSP\u003c/a\u003e 和\u003ca href=\"https://www.vxworks7.com/app/\" target=\"_blank\"\u003e应用程序\u003c/a\u003e的开发技巧，并提供了多个应用实例及分析设计。\u003c/p\u003e","title":"嵌入式VxWorks系统开发与应用","type":"book"},{"content":"","date":"2024-11-02","externalUrl":null,"permalink":"/tags/uart/","section":"Tags","summary":"","title":"UART","type":"tags"},{"content":" 摘要：结合嵌入式实时操作系统VxWorks实现风洞测控系统的实际应用,以其中的串口通信为例，讨论了在VxWorks下实现串口通信的关键技术，给出了基本原理、环境配置和程序示例。 关键词：VxWorks； 实时操作系统； 嵌入式操作系统；串行通信\n[Abstract] Combining with the application of wind tunnel measure and control system with embedded real-time operating system VxWorks , with the serial communication in it as an example ,the key techniques about realization of the serial communication in VxWorks are discussed. Communication mechanism， environment configure and corresponding program examples are provided. [Key words] VxWorks；RTOS；embedded operating system； Serial Communication\n前言 # 目前市场上比较著名的实时操作系统有：VxWorks、PSOS、Nucleus、QNX、VRTX、Windows CE、Palm 0S、Lynx0S等。 其中，VxWorks是一个具有微内核、可裁剪的高性能强实时操作系统，在实时操作系统市场上处于领先地位。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、弹道制导、飞机导航等。在美国的 F-16战斗机、B-2 隐形轰炸机和爱国者导弹上，甚至火星探测器上都使用了VxWorks实时操作系统。在嵌入式实时操作系统中使用串口通信，不仅可扩展嵌入式设备通信能力，而且可扩大其应用范围。\nVxWorks简介 # VxWorks是由wRS(wind River Systems，Inc．)公司开发的一套具有微内核、高性能、可伸缩的实时操作系统，支持广泛的网络通信协议，并能够根据用户的需求进行组合，其开放式的结构和对工业标准的支持使开发者只需做最少的工作即可设计出有效的适合于不同用户要求的系统。除了性能出众的操作系统之外，wRS公司还提供了优秀的实时操作系统开发工具Tornado。Tornado由三个高度集成的部分组成：Tornado工具，一整套强有力的交叉开发工具；VxWorks运行系统，是运行在目标机上的高性能、可裁剪的实时操作系统；连接目标机和宿主机的通信选项，加以太网、串行线路、在线仿真等。Tornado能够支持Windows、Unix等流行的工作平台和PowerPC、X86、ARM等几乎所有的目标处理器，所提供的工具可用于所有目标机，并具有两种调试模式(系统模式和任务模式)。除了基本的功能和开发工具外，Tornado还具有先进的系列网络产品，极大地扩展了Tornado的网络特性，并增强了嵌人式微处理器的网络特性。[1]\n串口通信基本原理 # 串口在嵌入式系统当中是一类重要的数据通信接口，其本质功能是作为CPU和串行设备间的编码转换器。当数据从CPU经过串行端口发送出去时，字节数据转换为串行的位；在接收数据时，串行的位被转换为字节数据。应用程序要使用串口进行通信，必须在使用之前向操作系统提出资源申请要求(打开串口)，通信完成后必须释放资源(关闭串口)。\n串口通信的优点是开发简单，在传输数据量不大、要求速度不高而传输距离较大的通信场合得到广泛应用。\n在VxWorks中，将I/O系统设计成为任何类型的设备提供一个简单、统一、独立于设备的接口，任何对于串口的操作都可以视为对一个文件的操作，而不必了解串口设备或程序驱动实现的细节。在串口通信软件的设计中，当串口初始化完成后，在使用之前利用open()打开相应串口，然后进行配置。\nVxWorks提供终端和伪终端设备驱动。Tty驱动针对实终端；pty针对仿真终端的程序。Tty设备有两种操作模式：raw模式和line模式。在raw模式下，每个刚从设备输入的字符对读者都是有效的；在line模式下所有输入字符被存储，直到NEWLINE字符输入。设备选项字使用带FIOSETOPTIONS 功能的ioctl()程序来设置。[2]\n配置完成后，依据串口打开时的读写标志，调用函数write()、read()对串口进行只读操作、只写操作或同时进行读写操作。\n为提高数据接收的实时性，可采用中断方式，利用VxWorks提供的select函数的事件触发机制，将读串口的任务阻塞使其一直等待数据，当有数据来到的时候该任务会立刻自动响应，提高系统的实时性。\n环境配置 # 在本实时应用系统中采用486机作为目标机，串口通信时目标机VxWorks系统启动盘的制作步骤：\n修改通用配置文件Tornado\\target\\config\\pc486\\config.h。在config.h文件中加入以下宏定义：\n在Tornado集成环境中执行菜单命令Project \u0026gt; Make PC486 \u0026gt; Common Targets \u0026gt; clean删除以前生成的文件，执行菜单命令Project \u0026gt; Make PC486 \u0026gt; Boot Rom Targets \u0026gt; bootrom_uncmp编译链接生成bootrom_uncmp ；再选择VxWorks Target,编译生成vxworks；\n拷贝Tornado\\target\\config\\pc486\\bootrom_uncmp至Tornado\\host\\bin下\n重命名文件bootrom_uncmp为bootrom；\n准备一张已格式化的空盘插入软驱；\n在目录Tornado\\host\\bin下执行命令 mkboot a: bootrom；\n拷贝Tornado\\target\\config\\pc486\\VxWorks至软盘；\n将系统制作盘插入目标机软驱，加电启动目标机即载入VxWork.st系统。[3]\n程序示例 # 在程序中加入下列头文件 # #include \u0026#34;vxWorks.h\u0026#34; #include \u0026#34;strLib.h\u0026#34; #include \u0026#34;string.h\u0026#34; #include \u0026#34;sioLib.h\u0026#34; #include \u0026#34;ioLib.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;ioctl.h\u0026#34; #include \u0026#34;selectLib.h\u0026#34; #include \u0026#34;types/vxTypesOld.h\u0026#34; 打开串口 # int open_com1(void) //打开串口1函数 { int sfd；//串口设备文件描述符 sfd =open(”／tyCo／0”，0_RDWR，0)；//打开串口并返回串口设备文件描述符 if(sfd ==ERROR) //如果不能打开串口1则打印出错信息 printf(\u0026#34;You can’t open port com1 !\u0026#34;); } 配置串口 # int config_com1(void) //串口1配置函数 { ioctl(sfd,FIOSETOPTIONS,OPT_LINE); //设置串口工作模式为行模式：LINE_MODE ioctl(sfd,FIOBAUDRATE,9600); //设置串口波特率为9600bps ioctl(sfd,FIOFLUSH,0); //清空输入输出缓冲 ioctl(sfd,SIO_HW_OPTS_SET,CS8|STOPB|PARENB|PARODD); //设置 8 位数据位，2位停止位，带校验位，奇校验 } 串口接收数据 # int accept _com1(void) //从串口1接收数据函数 { while(1) { char * accept _buf; FD_ZERO(\u0026amp;fds_data);//位码置零 FD_SET(sfd,\u0026amp;fds_data);//初始化位码 width＝sfd +1; //任务阻塞等待读串口准备完毕； if(select(width，\u0026amp;fds_data，NULL，NULL，NULL)==ERROR) return(ERROR); read(sfd, accept _buf,sizeof(accept _buf)); //从串口读字符 printf(\u0026#34;accept message is : %s \u0026#34;n\u0026#34;n\u0026#34;, accept _buf); //输出接收到的信息 } } 串口发送数据 # int send_com1(void) //向串口1发送数据函数 { char *send_buf =\u0026#34; Data had accept!\u0026#34;; //待发送数据 //任务阻塞等待写串口准备完毕 if(select(width，NULL，＆data_fds，NULL,NULL==ERROR) return(ERROR) ; if(FD_ISSET(sfd，\u0026amp;fds_data)) //检查串口准备好就向串口写数据 write(sfd，send_buf，sizeof(send_buf)) ; } 关闭串口 # close(sfd)； 结束语 # RS-232串口通信虽速率不高，但RS-422标准串行口通信则采用了双线传输，大大增加了抗共模干扰的能力，最大数据传输速度可以达到10Mb/s，这对于远程数据交换具有极大的优势。\n本文描述了在实时操作系统VxWorks中利用串口实现数据通信的方法，并给出了示例程序，目前已经在我们开发的风洞测控系统中获得了应用。该方法可将其串口通信可适用于工业控制等多方面，具有广泛的适应性。在嵌入式实时操作系统中使用串口通信，不仅可扩展嵌入式设备通信能力，而且可扩大其的应用范围。\n参考文献： # 孔祥营，柏桂枝．嵌入式实时操作系统vxworks及其开发环境Tornodo[M]．北京:中国电力出版社，2002.01 陈智育，温彦军，陈琪编著VxWorks程序开发实践. 北京:人民邮电出版社，2004.05 李方敏编著VxWorks高级程序设计. 北京:清华大学出版社，2004.05 原文地址: 基于VxWorks实时操作系统的串口通信程序设计与实现\nDownload the file\n","date":"2024-11-02","externalUrl":null,"permalink":"/app/design-and-implementation-of-uart-communication-application-based-on-vxworks/","section":"Apps","summary":"\u003cblockquote\u003e\n摘要：结合嵌入式实时操作系统VxWorks实现风洞测控系统的实际应用,以其中的串口通信为例，讨论了在VxWorks下实现串口通信的关键技术，给出了基本原理、环境配置和程序示例。\n\u003cp\u003e关键词：VxWorks； 实时操作系统； 嵌入式操作系统；串行通信\u003c/p\u003e\n\u003cp\u003e[Abstract] Combining with the application of wind tunnel measure and control system with embedded real-time operating system VxWorks , with the serial communication in it as an example ,the key techniques about realization of the serial communication in VxWorks are discussed. Communication mechanism， environment configure and corresponding program examples are provided. [Key words] VxWorks；RTOS；embedded operating system； Serial Communication\u003c/p\u003e","title":"基于VxWorks实时操作系统的串口通信程序设计与实现","type":"app"},{"content":"","date":"2024-10-24","externalUrl":null,"permalink":"/tags/timer/","section":"Tags","summary":"","title":"Timer","type":"tags"},{"content":"VxWorks是一种嵌入式实时操作系统(RTOS)，具有内核小、可裁剪、实时性强等特点。VxWorks内核(Wind)提供了共享内存、信号量、消息队列、套接字通信和定时器等多种机制。为了实现基于UDP网络的可靠通信，本文利用VxWorks的多种任务间通信机制和看门狗定时器机制，设计了一种多重定时器模型，该模型可以确保数据包的可靠传递。\nVxWorks的时钟及定时器机制 # VxWorks延时函数 # VxWorks既提供了延时功能，也提供了时限约束功能。VxWorks系统有2种延时方式：一种是Wind内核提供的taskDelay()函数；另一种是POSIX函数nanosleep()。taskDelay()函数以tick作为延时单位，默认情况下1个tick为16．67 ms(1／60 s)，可以通过调用sysClkRateSet()函数对tick进行重新设定。taskDelay()函数使调用该函数的任务在指定时间内主动放弃CPU，用于任务调度或等待某一外部事件。nanosleep()函数指定一个以s和ns为单位的睡眠或延时时间。其实，两个延时函数的精度是相同的，都是以tick为时间基准。不同之处在于，taskDelay(0)有自身意义，用于相同优先级任务间的任务调度，而nanosleep(0)是没有意义的。\nVxWorks定时器机制 # VxWorks提供一种看门狗定时器机制(watchdogtimer)，可以用来处理任务的时限约束。看门狗定时器作为系统时钟中断服务程序的一部分来维护，因此，看门狗定时器的回调函数以系统时钟中断级作为中断服务程序执行。看门狗定时器回调函数受到中断服务程序的限制，不能调用可能引起阻塞的函数，比如试图获取信号量，调用malloc()和free()等创建和释放内存函数或执行I／O操作。\nPOSIX定时器也可以处理任务时限。此外，VxWorks中一些函数具有时限控制的功能，semTake()、msgQSend()、msgQReceive()函数中都有设定时限控制的参数。超时参数NO_WAIT意味着立即返回，而WAIT_FOREVER意味着程序永不超时。\n多重定时器实现要求 # 在VxWorks系统下，利用网络套接字建立基于UDP协议的客户端／服务器通信模式。由于UDP是无连接的协议，发送方并不清楚发出的数据包是否已经正确到达接收方，于是提出一种支持重传和定时等待确认的协议。\n这个协议要求发送方发送的数据包与接收方回复的确认包具有对应的序列号，发送方和接收方都可以通过序列号来判断是不是想要得到的数据包。序列号是循环的，考虑到如果序列号太小会出现折返情况产生混淆，所以序列号至少大于2。如果用1个字节来表示序列号，则可以设定序列号为256。\n发送方送出一个数据包后启动一个定时器。这时可能会有4种情况发生：\n发送方接收到正确序号的确认包，则发送下一序列号的数据包。 发送方接收到已经接收过的重复确认包，则丢弃该确认包继续等待。如果在超时前收到了正确确认包，则发送下一序列号的数据包。 定时器超时，没有收到想要的确认包，则重新发送数据包，启动下一定时器。 设定的多重定时器超时后，没有收到想要确认包，则通知网络管理设备。 接收方在收到所需序列号的数据包后，回复一个确认包给发送方。如果接收方回复的确认包后没有正确到达发送方，则会引起发送方超时，重新发送原序列号数据包。接收方收到数据包后，需要检查数据包序列号。如果是重复序列号数据包，则丢弃，但是依旧回复确认包给发送方，以免已发送确认包在发送过程中丢失。这里基于支持重传和定时等待确认协议。具体要求是，在客户端通过UDP协议发送数据包后启动一个定时器，等待接收服务器端回复的ACK(acknowl-edgement)确认包。如果成功接收，则继续发送下一序列号的数据包；如果超时后还没有收到需要的确认包，则重新传输原序列号的数据包。图1所示为数据包均按时、正确地接收的情况。\n一般情况下，假定启动定时器30 ms内可以完成从发送数据包到接收ACK确认包的全过程，但是由于某些原因使得30 ms内无法收到确认包，则会重传原数据包，并启动一个稍长的40 ms定时器。如果40 ms还无法收到确认，则再次重传原数据包，并启动一个考虑到最差情况的60 ms定时器。如果依旧无法收到确认则不再发送，通知网络管理设备。\n出现定时器超时情况有3种可能：发送方发送数据包过程中丢包；接收方发送确认包过程中丢包；从发送数据包到确认包到达发送方过程中，延时时间超过定时时间。造成超时有两方面原因：一是，双方终端在接收数据包时由于缓冲问题不能及时处理，使得终端出现延时接收数据包或丢包；二是，通信链路发生断链情况，导致双方无法进行通信。从图2中可以看到，如果链路没有断开，则包含3种情况的三重定时器超时情况。\n多重定时器设计 # 设计方案 # 选用看门狗定时器机制来设计。看门狗定时器操作较为简单，只有4个函数，即wdCreate()、wdDelete()、wdStart()、wdCancel()。看门狗定时器与调用任务异步执行，并不阻塞调用任务，所以看门狗定时器很适合多任务的非阻塞计时。\n当看门狗定时器启动后，如果在规定的30 ms内收到了正确的确认包，就会将定时器取消掉，继续发送下面的数据包。如果30 ms规定时间内没有收到确认数据包ACK，则需要重新发送数据包，并启动第2个40 ms的定时器。VxWorks中单CPU的任务间常用通信机制是消息队列。当定时器到时后利用消息队列向发送任务发送消息，通知发送任务重新发送数据包，启动下一定时器。看门狗定时器的回调函数可以执行msgQSend()这种向消息队列发送消息的函数，我们通过msgQSend()函数向主任务发送时限已达消息。但是，将msgQSend()的延时参数设为wAIT_FOREVER时，消息队列中一旦没有了可用缓冲，则进入等待状态。由于中断服务程序优先级高，而从消息队列中接收消息的优先级低，当有任务准备从消息队列中取消息时，要等待中断服务程序执行完毕，则消息队列始终处于已满状态，造成系统死锁。如果将msgQSend()函数中的延时参数改为NO_WAIT，则可避免一直等待向消息队列发消息的情况，一旦消息队列已满就将该消息丢弃。但这样一来，向接收端发送数据包任务接收不到定时器超时消息，不会重发原序列号数据包和启动下一定时器，所以使用参数NO_WAIT也不可行。\n这里提出一种避免上述情况造成系统死锁的方法，即使用信号量机制来使msgQSend()不在中断服务程序中执行。通过使用信号量的任务间同步机制来实现这个功能。释放信号量函数semGive()不像msgQSend()那样需要在消息队列中等待，一旦执行就可以马上释放信号量，从而避免了冲突。\n由于任务中事件发生有一定间隔，不必选用计数器信号量，所以选用最常用的二进制信号量。首先建立3个先进先出的二进制信号量，设定可调用信号量为空。然后在看门狗定时器的回调函数中使用semGive()函数来释放信号量，重建一个任务在任务起始使用semTake()函数来获取信号量。当获得信号量后，通过msgQSend(，，，WAIT_FOREVER，)函数向消息队列中发送超时消息，而且保证只要消息队列有可用缓冲，就一定可以将消息送出。本文给出一个多重定时器的任务框架，如图3所示。\n主要实现代码 # 一个三重定时器的主要实现代码如下：\n以上程序中通过sysClkRateSet(100)将最小延时单位tick修改成10 ms，它是几个定时时间(30 ms、40 ms、60ms)的最大公约数。通过抓包软件Ethereal抓包，查看发送时间。以30 ms为例，抓包100次的平均定时时间在25 ms左右。出现这种情况的原因是，延时N个tick实际是延时(N-1)tick~N·tick。由于是等可能概率，则它的数学期望是(N+1／2)。对于tick为10 ms，30 ms即N=3，数学期望为25 ms。示意图如图4所示。\n延时精度为1／N秒，N越大越精确。于是调用函数synClkRateSet(500)，可以使定时的最大误差不超过2 ms。但是如果时钟频率太高，会造成系统在时钟中断处理方面开销太大，影响系统的任务调度，最好通过实验选用较为合适的时钟频率。这里选用sysClkRate-Set(200)。\n结 语 # 本文针对VxWorks下UDP网络通信中的可靠传输问题，提出了一个支持重传和定时等待确认的协议，并利用VxWorks系统提供的信号量同步、消息队列和看门狗定时器等多种机制，综合设计了一种可扩展的三重定时器。针对遇到的具体问题，笔者还进行了一定的优化处理。这种多重定时器模型已在笔者所研究的项目中得到利用，验证了其可行性和相对稳定性。这种多重定时器模型并不完全适合所有环境，需要根据具体情况改进和优化。\n","date":"2024-10-24","externalUrl":null,"permalink":"/app/design-of-multiple-timers-in-vxworks/","section":"Apps","summary":"\u003cp\u003e\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e是一种嵌入式实时操作系统(\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eRTOS\u003c/a\u003e)，具有内核小、可裁剪、实时性强等特点。VxWorks内核(Wind)提供了共享内存、信号量、消息队列、套接字通信和定时器等多种机制。为了实现基于UDP网络的可靠通信，本文利用VxWorks的多种任务间通信机制和看门狗定时器机制，设计了一种多重定时器模型，该模型可以确保数据包的可靠传递。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eVxWorks的时钟及定时器机制 \n    \u003cdiv id=\"vxworks%E7%9A%84%E6%97%B6%E9%92%9F%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%9C%BA%E5%88%B6\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#vxworks%E7%9A%84%E6%97%B6%E9%92%9F%E5%8F%8A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%9C%BA%E5%88%B6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\n\n\u003ch3 class=\"relative group\"\u003eVxWorks延时函数 \n    \u003cdiv id=\"vxworks%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#vxworks%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003eVxWorks既提供了延时功能，也提供了时限约束功能。VxWorks系统有2种延时方式：一种是Wind内核提供的taskDelay()函数；另一种是POSIX函数nanosleep()。taskDelay()函数以tick作为延时单位，默认情况下1个tick为16．67 ms(1／60 s)，可以通过调用sysClkRateSet()函数对tick进行重新设定。taskDelay()函数使调用该函数的任务在指定时间内主动放弃CPU，用于任务调度或等待某一外部事件。nanosleep()函数指定一个以s和ns为单位的睡眠或延时时间。其实，两个延时函数的精度是相同的，都是以tick为时间基准。不同之处在于，taskDelay(0)有自身意义，用于相同优先级任务间的任务调度，而nanosleep(0)是没有意义的。\u003c/p\u003e","title":"VxWorks下的多重定时器设计","type":"app"},{"content":"","date":"2024-10-22","externalUrl":null,"permalink":"/tags/u-boot/","section":"Tags","summary":"","title":"U-Boot","type":"tags"},{"content":"VxWorks是美国风河公司制作的一个实时操作系统，U-Boot是一个广为人知的通用启动加载器，它是嵌入式系统加电后运行的最早的代码。U-Boot通常被用于嵌入式系统，比如PowerPC或者ARM设备，这些设备上没有X86的BIOS。\n介绍 # 尽管VxWorks可以有它自己的bootloader(VxWorks Bootrom或者Bootapp)，U-Boot具有更多的功能，如果硬件板子已经提供了U-Boot的支持，那我们更有道理去直接使用它。\nU-boot : http://www.denx.de/wiki/U-Boot/WebHome VxWorks : https://www.windriver.com/products/vxworks/ 现在最新的VxWorks版本(VxWorks 7)已经比过去的VxWorks版本(我在VxWorks 6.9上遇到了好多问题)更加简单地和U-Boot集成了。\n这篇文章讲述了我们为最近的VxWorks 7 BSP进行设置的细节，我们选择使用一个独立于VxWorks镜像文件的DTB文件，而不是将DTB文件嵌入到VxWorks镜像里面。这将给我们带来更好的灵活性，让启动行能够从U-Boot上进行修改，而不需要重新编译DTB。\n具体地，VxWorks镜像需要将U-Boot头编译进去，然后U-Boot需要配置传递命令行参数以及MAC地址给VxWorks。\n编译VxWorks镜像文件 # 一个支持U-Boot的VxWorks镜像文件需要编译(将把U-Boot的头加入到VxWorks二进制中)\n从Workbench或者命令行来编译uVxWorks的目标文件。\n打开一个DOS命令行，配置编译环境，然后编译工程项目。\ncd \u0026lt;WIND_HOME\u0026gt; // your installation directory wrenv -p vxworks-7 cd \u0026lt;YOUR_VIP\u0026gt; // your VxWorks Image Project vxprj vip build uVxWorks 这将创建两个文件，用tftp被U-Boot加载到内存：\n文件名 描述 uVxWorks VxWorks image with U-Boot header [yourboard].dtb the device tree binary 为VxWorks配置U-Boot # U-Boot需要设置一些环境变量来加载VxWorks，针对VxWorks的启动参数(bootline)：\n=\u0026gt; setenv bootargs memac(2,0)host:vxWorks h=192.168.1.101 e=192.168.1.50:ffffff00 g=192.168.1.254 u=vxworks pw=gaitpu f=0x0 =\u0026gt; saveenv =\u0026gt; printenv bootargs bootargs=memac(2,0)host:vxWorks h=192.168.1.101 e=192.168.1.50:ffffff00 g=192.168.1.254 u=vxworks pw=gaitpu f=0x0 还有你可以随意给网络设备改变MAC地址：\nsetenv ethaddr 00:00:13:3a:ad:00 setenv eth1add 00:00:13:3a:ad:01 setenv eth1add 00:00:13:3a:ad:02 setenv eth1add 00:00:13:3a:ad:03 saveenv 加载和执行VxWorks镜像文件 # 配置一个tftp服务器来加载VxWorks镜像文件和DTB文件。\n你可以从下面下载一个非常好的Windows TFTP服务器：\nhttp://tftpd32.jounin.net/ 加载VxWorks镜像文件 # =\u0026gt; tftp 0x100000 uVxWorks Using FM1@DTSEC3 device TFTP from server 192.168.1.101; our IP address is 192.168.1.50 Filename \u0026#39;uVxWorks\u0026#39;. Load address: 0x100000 Loading: ################################################################# ################################################################# ################################################################# 1.5 MiB/s done Bytes transferred = 2861632 (2baa40 hex) 加载dtb blob # =\u0026gt; tftp 0xe00000 t4240qds.dtb Using FM1@DTSEC3 device TFTP from server 192.168.1.101; our IP address is 192.168.1.50 Filename \u0026#39;t4240qds.dtb\u0026#39;. Load address: 0xe00000 Loading: ## 1.4 MiB/s 启动VxWorks镜像文件 # =\u0026gt; bootm 0x100000 - 0xe00000 WARNING: adjusting available memory to 30000000 ## Booting kernel from Legacy Image at 00100000 ... Image Name: vxWorks Image Type: PowerPC VxWorks Kernel Image (uncompressed) Data Size: 2861568 Bytes = 2.7 MiB 创建U-boot命令 # 用下面的步骤创建一个新的U-Boot命令\nsetenv vxboot \u0026#39;tftp 0x100000 uVxWorks; tftp 0xe00000 t4240qds.dtb; bootm 0x100000 - 0xe00000\u0026#39; saveenv 运行这个命令：\nrun vxboot 配置U-Boot来传递MAC地址 # 这对于硬件开发者来说是至关重要的，MAC地址通常是在工厂里面分配的，会被VxWorks镜像文件使用。否则每一块板子出厂前都需要编译和加载一个独立的VxWorks，这绝对是一个梦魇般的情况。\n幸运地我们找到了一个方法，因为我们使用一个独立的dtb文件，而不是将dtb文件编译到VxWorks里面，U-Boot会用网络环境变量中的MAC地址覆盖dts文件中的MAC地址。\n不仅仅U-Boot可以覆盖本地的MAC地址，如果你在U-Boot环境变量中存储额外的网络地址变量并在你的设备树中为网络接口添加别名的话，U-Boot可以通过设备树将这些MAC地址传递给VxWorks。所以理论上所有网络设备的MAC地址都可以被覆盖。\n比如针对一块T4240的PowerPC板子：\n/* * U-boot only fixes up MAC Adrress (ethernet0 - n) if * environment variable is set. * aliases simplyfies the path to the property i.e by using a * label \u0026lt;\u0026amp;enet0\u0026gt; to assign a path to a particular node */ aliases{ ethernet0 = \u0026amp;enet0; ethernet1 = \u0026amp;enet1; ethernet2 = \u0026amp;enet2; ethernet3 = \u0026amp;enet3; }; .... fman0: fman@400000 { #address-cells = ; #size-cells = ; cell-index = ; compatible = \u0026#34;fsl,fman\u0026#34;; ranges = ; reg = ; interrupts = \u0026lt; 96 2 0 0 16 2 1 1\u0026gt;; clocks = \u0026lt;\u0026amp;hwac1\u0026gt;; clock-names = \u0026#34;fman0-clk\u0026#34;; /* FDT dummyMdio driver : memac0*/ enet0: ethernet@e0000 { compatible = \u0026#34;fsl,fman-memac\u0026#34;; reg = ; phy-handle = \u0026lt;\u0026amp;dummy_phy0\u0026gt;; phy-connection-type = \u0026#34;sgmii\u0026#34;; cell-index = ; local-mac-address = [ 00 04 9F 03 0A 5C ]; }; /* FDT dummyMdio driver : memac1*/ enet1: ethernet@e2000 { .... }; .... }; ","date":"2024-10-22","externalUrl":null,"permalink":"/bsp/how-to-integrate-u-boot-and-vxworks-7/","section":"Bsps","summary":"\u003cp\u003e\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e是美国风河公司制作的一个实时操作系统，\u003ca href=\"https://www.vxworks.net/bsp/834-u-boot-and-vxworks-7-integration\" target=\"_blank\"\u003eU-Boot\u003c/a\u003e是一个广为人知的通用启动加载器，它是嵌入式系统加电后运行的最早的代码。U-Boot通常被用于嵌入式系统，比如PowerPC或者ARM设备，这些设备上没有X86的BIOS。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e介绍 \n    \u003cdiv id=\"%E4%BB%8B%E7%BB%8D\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E4%BB%8B%E7%BB%8D\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e尽管VxWorks可以有它自己的bootloader(VxWorks Bootrom或者Bootapp)，U-Boot具有更多的功能，如果硬件板子已经提供了U-Boot的支持，那我们更有道理去直接使用它。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mark\" data-lang=\"mark\"\u003eU-boot : http://www.denx.de/wiki/U-Boot/WebHome \n\nVxWorks : https://www.windriver.com/products/vxworks/ \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在最新的VxWorks版本(\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003eVxWorks 7\u003c/a\u003e)已经比过去的VxWorks版本(我在VxWorks 6.9上遇到了好多问题)更加简单地和U-Boot集成了。\u003c/p\u003e","title":"U-Boot和VxWorks 7的集成","type":"bsp"},{"content":"","date":"2024-10-22","externalUrl":null,"permalink":"/tags/rtos/","section":"Tags","summary":"","title":"RTOS","type":"tags"},{"content":"VxWorks操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），是嵌入式开发环境的关键组成部分。\n嵌入式操作系统VxWorks简介 # 良好的持续能力、高性能的内核以及友好的用户开发环境，在嵌入式实时操作系统领域占据一席之地。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的F-16、FA-18战斗机、B-2隐形轰炸机和爱国者导弹上，甚至连1997年在火星表面登陆的火星探测器上也使用到了VxWorks。\n实时操作系统和分时操作系统的区别 # 从操作系统能否满足实时性要求来区分，可把操作系统分成分时操作系统和实时操作系统。\n分时操作系统按照相等的时间片调度进程轮流运行，分时操作系统由调度程序自动计算进程的优先级，而不是由用户控制进程的优先级。这样的系统无法实时响应外部异步事件。\n实时操作系统能够在限定的时间内执行完所规定的功能，并能在限定的时间内对外部的异步事件作出响应。分时系统主要应用于科学计算和一般实时性要求不高的场合。实时性系统主要应用于过程控制、数据采集、通信、多媒体信息处理等对时间敏感的场合。\n实时操作系统的结构 # 在计算的早期开发的操作系统的最原始的结构形式是一个统一的实体(monolithic)。在这样的系统中，提供的不同功能的模块，如处理器管理、内存管理、输入输出等，通常是独立的。然而他们在执行过程中并不考虑其他正在使用中的模块，各个模块都以相同的时间粒度运行。\n由于现代实时环境需要许多不同的功能，以及在这样的环境中存在的并发活动所引起的异步性和非确定性，操作系统变得更加复杂。所以早期操作系统的统一结构的组织已经被更加精确的内部结构所淘汰。层次结构的起点————内核\n操作系统的最好的内部结构模型是一个层次性的结构，最低层是内核。这些层次可以看成为一个倒置的金字塔，每一层都建立在较低层的功能之上。 内核仅包含一个操作系统执行的最重要的低层功能。正象一个统一结构的操作系统，内核提供了在高层软件与下层硬件之间的抽象层。然而，内核仅提供了构造操作系统其他部分所需的最小操作集。\n拥有其它名字的内核 # 许多商用化的内核支持的功能远强于上面所列的要求。在这方面，他们不是真正的内核，而更象一个小的统一结构的操作系统。因为他们包含简单的内存分配、时钟管理、甚至一些输入输出系统调用的功能。\n这种分类不仅仅是在语义上的争论，在这篇文章的后面章节将说明限制内核功能和油画这些功能的重要性。\nVxWorks的特点 # 可靠性 # 操作系统的用户希望在一个工作稳定，可以信赖的环境中工作，所以操作系统的可靠性是用户首先要考虑的问题。而稳定、可靠一直是VxWorks的一个突出优点。自从对中国的销售解禁以来，VxWorks以其良好的可靠性在中国赢得了越来越多的用户。\n实时性 # 实时性是指能够在限定时间内执行完规定的功能并对外部的异步事件作出响应的能力。实时性的强弱是以完成规定功能和作出响应时间的长短来衡量的。\nVxWorks的实时性做得非常好，其系统本身的开销很小，进程调度、进程间通信、中断处理等系统公用程序精练而有效，它们造成的延迟很短。VxWorks提供的多任务机制中对任务的控制采用了优先级抢占（Preemptive Priority Scheduling）和轮转调度（Round-Robin Scheduling）机制，也充分保证了可靠的实时性，使同样的硬件配置能满足更强的实时性要求，为应用的开发留下更大的余地。\n可裁减性 # 用户在使用操作系统时，并不是操作系统中的每一个部件都要用到。例如图形显示、文件系统以及一些设备驱动在某些嵌入系统中往往并不使用。\nVxWorks由一个体积很小的内核及一些可以根据需要进行定制的系统模块组成。VxWorks内核最小为8kB，即便加上其它必要模块，所占用的空间也很小，且不失其实时、多任务的系统特征。由于它的高度灵活性，用户可以很容易地对这一操作系统进行定制或作适当开发，来满足自己的实际应用需要。\n对一个实时内核的要求 # 一个实时操作系统内核需满足许多特定的实时环境所提出的基本要求，这些包括：\n多任务：由于真实世界的事件的异步性，能够运行许多并发进程或任务是很重要的。多任务提供了一个较好的对真实世界的匹配，因为它允许对应于许多外部事件的多线程执行。系统内核分配CPU给这些任务来获得并发性。 抢占调度：真实世界的事件具有继承的优先级，在分配CPU的时候要注意到这些优先级。基于优先级的抢占调度，任务都被指定了优先级， 在能够执行的任务（没有被挂起或正在等待资源）中，优先级最高的任务被分配CPU资源。换句话说，当一个高优先级的任务变为可执行态，它会立即抢占当前正在运行的较低优先级的任务。 快速灵活的任务间的通信与同步：在一个实时系统中，可能有许多任务作为一个应用的一部分执行。系统必须提供这些任务间的快速且功能强大的通信机制。内核也要提供为了有效地共享不可抢占的资源或临界区所需的同步机制。 方便的任务与中断之间的通信：尽管真实世界的事件通常作为中断方式到来，但为了提供有效的排队、优先化和减少中断延时，我们通常希望在任务级处理相应的工作。所以需要杂任务级和中断级之间存在通信。 性能边界：一个实时内核必须提供最坏情况的性能优化，而非针对吞吐量的性能优化。我们更期望一个系统能够始终以50微妙执行一个函数，而不期望系统平均以10微妙执行该函数，但偶尔会以75微妙执行它。 特殊考虑：由于对实时内核的要求的增加，必须考虑对内核支持不断增加的复杂功能的要求。这包括多进程处理，Ada和对更新的、功能更强的处理器结构如RISC的支持。 VxWorks内核：Wind # VxWorks操作系统是一种功能最全的现在可以获得的独立于处理器的实时系统。然而，VxWorks是带有一个相当小的真正微内核的层次结构。内核仅提供多任务环境、进程间通信和同步功能。这些功能模块足够支持VxWorks在较高层次所提供的丰富的性能的要求。 通常内核操作对于用户是不可见的。应用程序为了实现需要内核参与的任务管理和同步使用一些系统调用，但这些调用的处理对于调用任务是不可见的。应用程序仅链接恰当的VxWorks例程（通常使用VxWorks的动态链接功能），就象调用子程序一样发出系统调用。这种接口不象有些系统需要一个笨拙的跳转表接口，用户需要通过一个整数来指定一个内核功能调用。\n多任务 # 内核的基本功能是提供一个多任务环境。多任务使得许多程序在表面上表现为并发执行，而事实上内核是根据基本的调度算法使他们分段执行。每个明显独立的程序被成为一个任务。每个任务拥有自己的上下文，其中包含在内核调度使该任务执行的时候它所看到的CPU环境和系统资源。\n任务状态和状态迁移 # 内核维护系统中的每个任务的当前状态。状态迁移发生在应用程序调用内核功能服务的时候。下面定义了wind内核状态：\n就绪态\u0026mdash;-一个任务当前除了CPU不等待任何资源 阻塞态\u0026mdash;-一个任务由于某些资源不可获得而被阻塞 延迟态\u0026mdash;-一个任务睡眠一段时间 挂起态\u0026mdash;-主要用于调试的一个辅助状态，挂起禁止任务的执行 任务被创建以后进入挂起态，需要通过特定的操作使被创建的任务进入就绪态，这一操作执行速度很快，使应用程序能够提前创建任务，并以一种快捷的方式激活该任务。\n实时系统的一个任务可有多种状态，其中最基本的状态有四种：\n就绪态：任务只等待系统分配CPU资源； 悬置态：任务需等待某些不可利用的资源而被阻塞； 休眠态：如果系统不需要某一个任务工作，则这个任务处于休眠状态； 延迟态：任务被延迟时所处状态； 当系统函数对某一任务进行操作时，任务从一种状态迁移到另一状态。处于任一状态的任务都可被删除。\n状态迁移调用\n就绪态 ----\u0026gt; 悬置态semTake()/msgQReceive() 就绪态 ----\u0026gt; 延迟态taskDelay() 就绪态 ----\u0026gt; 休眠态taskSuspend() 悬置态 ----\u0026gt; 就绪态semGive()/msgQSend() 悬置态 ----\u0026gt; 休眠态taskSuspend() 延迟态 ----\u0026gt; 就绪态expireddelay 延迟态 ----\u0026gt; 休眠态taskSuspend() 休眠态 ----\u0026gt; 就绪态taskResume()/taskActivate() 休眠态 ----\u0026gt; 悬置态taskResume() 休眠态 ----\u0026gt; 延迟态taskResume() 调度控制 # 多任务需要一个调度算法分配CPU给就绪的任务。在VxWorks中默认的调度算法是基于优先级的抢占调度，但应用程序也可以选择使用时间片轮转调度。\n基于优先级抢占调度：基于优先级的抢占调度，每个任务被指定一个优先级，内核分配CPU给处于就绪态的优先级最高的任务。调度采用抢占的方式，是因为当一个优先级高于当前任务的任务变为就绪态时，内核将立即保存当前任务的上文，并切换到高优先级任务的上文。VxWorks有从0到255共256个优先级。在创建的时候任务被指定一个优先级，在任务运行的过程中可以动态地修改优先级以便跟踪真实世界的事件优先级。外部中断被指定优先于任何任务的优先级，这样能够在任何时候抢占一个任务。\n时间片轮转：基于优先级抢占调度可以扩充时间片轮转调度。时间片轮转调度允许在相同优先级的处于就绪态的任务公平地共享CPU。没有时间片轮转调度，当有多个任务在同一优先级共享处理器时，一个任务可能独占CPU，不会被阻塞直到被一个更高优先级的任务抢占，而不给同一优先级的其他任务运行的机会。如果时间片轮转被使能，执行任务的时间计数器在每个时钟滴答递增。当指定的时间片耗尽，计数器会被清零，该任务被放在同一优先级任务队列的队尾。加入特定优先级组的新任务被放在该组任务的队尾，并将运行计数器初始化为零。\n基本的任务函数 # 用于状态控制的基本任务函数包括一个任务的创建、删除、挂起和唤醒。一个任务也可以使自己睡眠一个特定的时间间隔不去运行。许多其他任务例程提供由任务上下文获得的状态信息。这些例程包括访问一个任务当前处理器寄存器控制。\n高效的任务管理：\n多任务，具有256个优先级。 具有优先级排队和循环调度。 快速的、确定性的上下文切换。 任务删除问题 # wind内核提供防止任务被意外删除的机制。通常，一个执行在临界区或访问临界资源的任务要被特别保护。我们设想下面的情况：一个任务获得一些数据结构的互斥访问权，当它正在临界区内执行时被另一个任务删除。由于任务无法完成对临界区的操作，该数据结构可能还处于被破坏或不一致的状态。而且，假想任务没有机会释放该资源，那麽现在其他任何任务现在就不能获得该资源，资源被冻结了。\n任何要删除或终止一个设定了删除保护的任务的任务将被阻塞。当被保护的任务完成临界区操作以后，它将取消删除保护以使自己可以被删除，从而解阻塞删除任务。\n正如上面所展示的，任务删除保护通常伴有互斥操作。\n这样，为了方便性和效率，互斥信号量包含了删除保护选项。（参见\u0026quot;互斥信号量\u0026quot;）\n任务间通信 # 为了提供完整的多任务系统的功能，wind内核提供了一套丰富的任务间通信与同步的机制。这些通信功能使一个应用中各个独立的任务协调他们的活动。\n灵活的任务间通讯：\n三种信号灯：二进制、计数、有优先级继承特性的互斥信号灯。 消息队列。 套接字（Socket）。 共享内存。 信号（Signals） 微秒级的中断处理。 支持POSIX 1003.1b实时扩展标准。 支持多种物理介质及标准的、完整的TCP/IP网络协议。 灵活的引导方式。支持从ROM、flash、本地盘（软盘或硬盘）或网络引导。 支持多处理器并行处理。 快速灵活的I/O系统。 支持MS-DOS和RT－11文件系统。 支持本地盘，flash，CD-ROM的使用。 完全符合ANSI C标准。 多个系统调用。 共享地址空间 # wind内核的任务间通信机制的基础是所有任务所在的共享地址空间。通过共享地址空间，任务能够使用共享数据结构的指针自由地通信。管道不需要映射一块内存区到两个互相通信任务的寻址空间。\n不幸的是，共享地址空间具有上述优点的同时，带来了未被保护内存的重入访问的危险。UNIX操作系统通过隔离进程提供这样的保护，但同时带来了对于实时操作系统来说巨大的性能损失。\n互斥操作 # 当一个共享地址空间简化了数据交换，通过互斥访问避免资源竞争就变为必要的了。用来获得一个资源的互斥访问的许多机制仅在这些互斥所作用的范围上存在差别。实现互斥的方法包括禁止中断、禁止任务抢占和通过信号量进行资源锁定。\n中断禁止：最强的互斥方法是屏蔽中断。这样的锁定保证了对CPU的互斥访问。这种方法当然能够解决互斥的问题，但它对于实时是不恰当的，因为它在锁定期间阻止系统响应外部事件。长的中断延时对于要求有确定的响应时间的应用来说是不可接受的。\n抢占禁止：禁止抢占提供了强制性较弱的互斥方式。 当前任务运行的过程中不允许其他任务抢占，而中断服务程序可以执行。这也可能引起较差的实时响应，就象被禁止中断一样，被阻塞的任务会有相当长时间的抢占延时，就绪态的高优先级的任务可能会在能够执行前被强制等待一段不可接受的时间。为避免这种情况，在可能的情况下尽量使用信号量实现互斥。\n互斥信号量：信号量是用于锁定共享资源访问的基本方式。不象禁止中断或抢占，信号量限制了互斥操作仅作用于相关的资源。一个信号量被创建来保护资源。VxWorks的信号量遵循Dijkstra的P()和V()操作模式。\n当一个任务请求信号量，P()， 根据在发出调用时信号量的置位或清零的状态， 会发生两种情况。如果信号量处于置位态， 信号量会被清零，并且任务立即继续执行。如果信号量处于清零态，任务会被阻塞来等待信号量。\n当一个任务释放信号量，V()，会发生几种情况。如果信号量已经处于置位态，释放信号量不会产生任何影响。如果信号量处于清零态且没有任务等待该信号量，信号量只是被简单地置位。如果信号量处于清零态且有一个或多个任务等待该信号量，最高优先级的任务被解阻塞，信号量仍为清零态。\n通过将一些资源与信号量关联，能够实现互斥操作。当一个任务要操作资源，它必须首先获得信号量。只要任务拥有信号量，所有其他的任务由于请求该信号量而被阻塞。当一个任务使用完该资源，它释放信号量，允许等待该信号量的另一个任务访问该资源。\nWind内核提供了二值信号量来解决互斥操作所引起的问题。 这些问题包括资源拥有者的删除保护，由资源竞争引起的优先级逆转。\n删除保护：互斥引起的一个问题会涉及到任务删除。在由信号量保护的临界区中，需要防止执行任务被意外地删除。删除一个在临界区执行的任务是灾难性的。资源会被破坏，保护资源的信号量会变为不可获得，从而该资源不可被访问。通常删除保护是与互斥操作共同提供的。由于这个原因，互斥信号量通常提供选项来隐含地提供前面提到的任务删除保护的机制。\n优先级逆转/优先级继承： 优先级逆转发生在一个高优先级的任务被强制等待一段不确定的时间以便一个较低优先级的任务完成执行。考虑下面的假设：\nT1，T2和T3分别是高、中、低优先级的任务。T3通过拥有信号量而获得相关的资源。当T1抢占T3，为竞争使用该资源而请求相同的信号量的时候，它被阻塞。如果我们假设T1仅被阻塞到T3使用完该资源为止，情况并不是很糟。毕竟资源是不可被抢占的。然而，低优先级的任务并不能避免被中优先级的任务抢占，一个抢占的任务如T2将阻止T3完成对资源的操作。这种情况可能会持续阻塞T1等待一段不可确定的时间。这种情况成为优先级逆转，因为尽管系统是基于优先级的调度，但却使一个高优先级的任务等待一个低优先级的任务完成执行。\n互斥信号量有一个选项允许实现优先级继承的算法。优先级继承通过在T1被阻塞期间提升T3的优先级到T1解决了优先级逆转引起的问题。这防止了T3，间接地防止T1，被T2抢占。通俗地说，优先级继承协议使一个拥有资源的任务以等待该资源的任务中优先级最高的任务的优先级执行。当执行完成，任务释放该资源并返回到它正常的或标准的优先级。因此，继承优先级的任务避免了被任何中间优先级的任务抢占。\n同步 # 信号量另一种通常的用法是用于任务间的同步机制。在这种情况下，信号量代表一个任务所等待的条件或事件。最初，信号量是在清零态。一个任务或中断通过置位该信号量来指示一个事件的发生。等待该信号量的任务将被阻塞直到事件发生、该信号量被置位。一旦被解阻塞，任务就执行恰当的事件处理程序。信号量在任务同步中的应用对于将中断服务程序从冗长的事件处理中解放出来以缩短中断响应时间是很有用的。\n消息队列 # 消息队列提供了在任务与中断服务程序或其他任务间交换变长消息的一种较低层的机制。这种机制在功能上类似于管道，但有较少的开销。\n管道、套接字、远程过程调用和更多高层的VxWorks机制提供任务间通信的更高层的抽象，包括管道、TCP/IP套接字、远程过程调用和更多。为了保持裁减内核为仅包含足够支持高层功能的一个最小函数集的设计目标，这些特性都是基于上面描述的内核同步方式的。\n内核设计的优点 # wind内核的一个重要的设计特性是最小的抢占延时。其他的主要设计的优点包括史无前例的可配置性，对不可预见的应用需求的可扩展性，在各种微处理器应用开发中的移植性。\n最小的抢占延时 # 正如前面所讨论的，禁止抢占是获得代码临界资源互斥操作的通常手段。这种技巧的不期望的负面影响是高的抢占延时，这可以通过尽量使用信号量实现互斥和保持临界区尽量紧凑被减小。但即使广泛地使用信号量也不能解决所有的可能导致抢占延时的根源。内核本身就是一个导致抢占延时的根源。为了理解其原因，我们必须更好地理解内核所需的互斥操作。\n内核级和任务级 # 在任何多任务系统中，大量的应用是发生在一个或多个任务的上下文。然而，有些CPU时间片不在任何任务的上下文。这些时间片发生在内核改变内部队列或决定任务调度。在这些时间片中，CPU在内核级执行，而非任务级。\n为了内核安全地操作它的内部的数据结构，必须有互斥操作。内核级没有相关的任务上下文，内核不能使用信号量保护内部链表。内核使用工作延期作为实现互斥的方式。当有内核参与时，中断服务程序调用的函数不是被直接激活，而是被放在内核的工作 队列中。内核完成这些请求的执行而清空内核工作队列。\n当内核正在执行已经被请求服务时系统将不响应到达内核的函数调用。可以简单地认为内核状态类似于禁止抢占。如前面所讨论的，抢占延时在实时系统中是不期望有的，因为它增加了对于会引起应用任务重新调度的事件的响应时间.\n管操作系统在内核级（此时禁止抢占）完全避免消耗时间是不可能的，但减少这些时间是很重要的。这是减少由内核执行的函数的数量的主要原因， 也是不采用统一结构的系统设计方式的原因。例如，有一种流行的实时操作系统的每个函数都是在内核级执行。这意味着当一个低优先级的任务在执行分配内存、获得任务信息的函数时所有高优先级的任务被禁止抢占。\n一个最小的内核 # 已经说明了一个最小内核的优点和构造高层操作系统功能的必要功能，我们使用这些操作原语来执行一个传统的内核级功能，而在VxWorks中作为任务级功能执行，内存管理。 在这个例子中，考虑用户可调用的子例程malloc， 用于分配所请求大小的内存区并返回一个指向该内存区的指针。假定空闲内存区是通过搜索一个空闲内存块的队列找到的，一个信号量必须被用来保护这个非抢占多用户资源。分配内存的操作如下：\n获得互斥信号量 搜索空闲内存块链表 释放互斥信号量 值得注意的是搜索一个足够大的空闲内存块的可能的冗长的时间是发生在调用任务的上下文中。这是可以被高优先级的任务抢占的（除了信号量调用的这段执行时间）。\n在一个标准的统一结构的实时内核中，内存分配例程操作如下：\n进入内核 搜索空闲内存块链表 退出内核 整个内存分配发生在内核级，任务抢占被禁止如果高优先级的任务在此时变为就绪态，它必须等待直到内核为低优先级的任务完成内存分配。有些操作系统甚至在这段市时间禁止中断。\n任务级操作系统服务 # Wind River System的实时操作系统，VxWorks，显示了这样设计的一个最小内核是能够满足需求的。VxWorks是现在能够获得的独立于任何处理器的、拥有相当小内核的、功能完全的层次结构的实时操作系统。\nVxWorks在内核之上提供了大量的功能。它包括内存管理，一个完整的BSD4.3网络包，TCP/IP，网络文件系统（NFS），远程过程调用（RPC），UNIX兼容的链接加载模块，C语言的解释界面，各种类型的定时器，性能监测组件，调试工具，额外的通信工具如管道、信号和套接字，I/O和文件系统，和许多功能例程。这些都不是运行在内核级，所以不会禁止中断或任务抢占。\n可配置性 # 实时应用有多种内核需求。没有哪个内核有一个用来满足每种需求的很好的设计折衷。然而，一个内核可以通过配置来调整特定的性能特性，裁减实时系统来最好地适应一个应用的要求。不可预见的内核配置性以用户可选择的内核排队算法的形式提供给应用。\n排队策略 # VxWorks中的排队库是独立于使用他们的内核队列功能而执行的，这样提供了将来增加新的排队方式的灵活性。\n在VxWorks中有各种内核队列。就绪队列是一个按优先级索引的所有等待调度的任务队列。滴答队列用于定时功能。信号量是一个等待信号量的被阻塞任务的链表。活动队列是一个系统中所有任务的一个先进先出（FIFO）的链表。这些队列中的每个队列都需要一个不同的排队算法。这些算法不是被内嵌在内核中，而是被抽取到一个自治的、可转换的排队库中。这种灵活的组织形式是满足特殊的配置需求的基础。\n可扩展性 # 支持不可预见的内核扩展的能力与以有功能的可配置性是同样重要的。简单的内核接口和互斥方法使内核级功能扩展相当容易； 在某些情况下，应用可以仅利用内核钩子函数来实现特定的扩展。\n内部钩子函数 # 为了不修改内核而能够向系统增加额外的任务相关的功能，VxWorks提供了任务创建、切换和删除的钩子函数。这些允许在任务被创建、 上下文切换和任务被删除的时候额外的例程被调用执行。这些钩子函数可以利用任务上下文中的空闲区创建wind内核的任务特性。\n未来考虑 # 有许多系统函数现在变得越来越重要，而且会影响到内核设计时的抢占延时。尽管涉及这些问题一个完整的讨论超出了本文的范围，但值得简单地提一下。 RISC/CISC设计一个独立于CPU的操作系统一直是一个挑战。随着新的RSIC（精简指令集）处理器变得很流行，这些难度也加大了。为了在RISC环境下有效地执行，内核和操作系统需要有执行不同策略的灵活性。\n例如，考虑在任务切换时内核执行的例程。在CISC（复杂指令集，如680x0或80x86）CPU，内核为每个任务存储一套完整的寄存器，在运行任务的时候将这些寄存器换入换出。在一个RISC机器上，这样是不合理的，因为涉及到太多的寄存器。所以内核需要一个更精密复杂的策略，如为任务缓存寄存器，允许应用指定一些寄存器给特殊的任务。\n移植性 # 为了使wind内核在他们出现的结构上能够运行，需要有一个可移植的内核版本。这使移植是可行的，但不是最优化的。\n多处理 # 支持紧耦合的多处理需求要求实时内核的内部功能包含，在理想情况下，在远端请求内核调用，如从一个处理器到另一个处理器。这就要涉及到信号量调用（为处理器间同步）和任务调用（为了控制另一个CPU上的任务）。这种复杂性无疑会增加内核级功能调用的开销，但是许多服务如对象标识可以在任务级执行。在多处理系统中保持一个最小内核的优点是处理器之间的互锁可以有较好的时间粒度。大的内核将在内核级消耗额外的时间，仅能获得粗糙的互锁时间粒度。\nAda # Ada语言为实时系统设计者提供了象聚会机制这样的任务原语。异常处理、任务终止、终止替换和聚会都将潜在地影响内核设计。这些操作可以由前面讨论的任务和同步机制构造，为了保持减小抢占延时的设计目标，许多工作能够在任务级执行。\n实时内核的重要尺度 # 许多性能特性被用来比较以有的实时内核，这些包括：\n快速的任务上下文切换\u0026mdash;-由于实时系统的多任务的特性，系统能够快速地从一个任务切换到另一个任务是很重要的。在分时系统中，如UNIX，上下文切换是在ms级。Wind内核执行原始上下文切换只用17us。 最小的同步开销\u0026mdash;-因为同步是实现资源互斥访问的基本方法，这些操作所引起的开销最小化是很重要的。在VxWorks中，请求和释放二值信号量仅用8us。 最小的中断延时\u0026mdash;-因为外部世界来的事件通常以中断的形式到来，操作系统快速的处理这些中断是很重要的。内核在操作一些临界数据结构的时候必须禁止中断。为了减小中断延时，必须使这些时间最小化。Wind内核的中断延时小于10us。 抢占延时对性能指标的影响 # 当许多的实时解决方案被提交给应用工程师时， 性能指标对于评估供应商的产品变得越来越重要。不象上下文切换和中断延时，抢占延时很难测量。所以它很少在说明中被提及。但是考虑到当内核通常禁止上下文切换会长达数百微妙，而声称一个50us的固定长度（与任务个数无关）的上下文切换时间是毫无意义的。除了很难测量外，抢占延时可能会削弱许多性能指标的有效性。\nWind内核通过减小内核的大小来尽量减小抢占延时。 包含繁多功能的内核必将引起长的抢占延时。\n任务管理 # 任务是代码运行的一个映象，从系统的角度看，任务是竞争系统资源的最小运行单元。任务可以使用或等待CPU、I/O设备及内存空间等系统资源，并独立于其它任务，与它们一起并发运行（宏观上如此）。VxWorks内核使任务能快速共享系统的绝大部分资源，同时有独立的上下文来控制个别线程的执行。\n任务结构 # 多任务设计能随时打断正在执行着的任务，对内部和外部发生的事件在确定的时间里作出响应。VxWorks实时内核Wind提供了基本的多任务环境。从表面上来看，多个任务正在同时执行，实际上，系统内核根据某一调度策略让它们交替运行。系统调度器使用任务控制块的数据结构（简记为TCB)来管理任务调度功能。任务控制块用来描述一个任务，每一任务都与一个TCB关联。TCB包括了任务的当前状态、优先级、要等待的事件或资源、任务程序码的起始地址、初始堆栈指针等信息。调度器在任务最初被激活时以及从休眠态重新被激活时，要用到这些信息。\n此外，TCB还被用来存放任务的\u0026quot;上下文\u0026quot;（context)。任务的上下文就是当一个执行中的任务被停止时，fPW\u0026quot;教T供\\aI管h;`所要保存的所有信息。在任务被重新执行时，必须要恢复上下文。通常，上下文就是计算机当前的状态，也即各个寄存器的内容。如同在发生中断所要保存的内容一样。当发生任务切换时，当前运行的任务的上下文被存入TCB，将要被执行的任务的上下文从它的TCB中取出，放入各个寄存器中。于是转而执行这个任务，执行的起点是前次它在运行时被中止的位置。\nVxWorks中，内存地址空间不是任务上下文的一部分。所有的代码运行在同一地址空间。如每一任务需各自的内存空间，需可选产品VxVMI的支持。\n任务调度策略 # 多任务调度须采用一种调度算法来分配CPU给就绪态任务。Wind内核采用基于优先级的抢占式调度法作为它的缺省策略，同时它也提供了轮转调度法。\n基于优先级的抢占式调度，它具有很多优点。这种调度方法为每个任务指定不同的优先级。没有处于悬置或休眠态的最高优先级任务将一直运行下去。当更高优先级的任务由就绪态进入运行时，系统内核立即保存当前任务的上下文，切换到更高优先级的任务。\n多任务调度须采用一种调度算法来分配CPU给就绪态任务。Wind内核采用基于优先级的抢占式调度法作为它的缺省策略，同时它也提供了轮转调度法。\n基于优先级的抢占式调度，它具有很多优点。这种调度方法为每个任务指定不同的优先级。没有处于悬置或休眠态的最高优先级任务将一直运行下去。当更高优先级的任务由就绪态进入运行时，系统内核立即保存当前任务的上下文，切换到更高优先级的任务。\nWind内核划分优先级为256 级（0~255）。优先级0为最高优先级，优先级255为最低。当任务被创建时，系统根据给定值分配任务优先级。然而，优先级也可以是动态的，它们能在系统运行时被用户使用系统调用taskPrioritySet()来加以改变，但不能在运行时被操作系统所改变。\n轮转调度法分配给处于就绪态的每个同优先级的任务一个相同的执行时间片。时间片的长度可由系统调用KernelTimeSlice()通过输入参数值来指定。很明显，每个任务都有一运行时间计数器，任务运行时每一时间滴答加1。一个任务用完时间片之后，就进行任务切换，停止执行当前运行的任务，将它放入队列尾部，对运行时间计数器置零，并开始执行就绪队列中的下一个任务。当运行任务被更高优先级的任务抢占时，此任务的运行时间计数器被保存，直到该任务下次运行时。\n抢占禁止 # Wind内核可通过调用taskLock()和taskUnlock（）来使调度器起作用和失效。当一个任务调用taskLock()使调度器失效，任务运行时没有基于优先级的抢占发生。然而，如果任务被阻塞或是悬置时，调度器从就绪队列中取出最高优先级的任务运行。当设置抢占禁止的任务解除阻塞，再次开始运行时，抢占又被禁止。这种抢占禁止防止任务的切换，但对中断处理不起作用。\n异常处理 # 程序代码和数据的出错，如非法命令、总线或地址错误、被零除等。VxWorks异常处理包，一般是将引起异常的任务休眠，保存任务在异常出错处的状态值。内核和其它任务继续执行。用户可借助Tornado开发工具，查看当前任务状态，从而确定被休眠的任务。\n任务管理 # VxWorks内核的任务管理提供了动态创建、删除和控制任务的功能，具体实现通过如下一些系统调用：\ntaskSpawn()创建（产生并激活）新任务 taskInit() 初始化一个新任务 taskActivate() 激活一个已初始化的任务 taskName() 由任务ID号得到任务名 taskNameToId（）由任务名得到任务ID号 taskPriorityGet()获得任务的优先级 taskIsSuspended()检查任务是否被悬置 taskIsReady()检查任务是否准备运行 taskTcb()得到一个任务控制块的指针 taskDelete() 中止指定任务并自由内存（仅任务堆栈和控制块） taskSafe() 保护被调用任务 taskSuspend()悬置一个任务 taskResume() 恢复一个任务 taskRestart()重启一个任务 taskDelay()延迟一个任务 VxWorks中的多任务通讯机制 # 通常，在一个实时系统中，存在着多个并发的任务来协同实现系统的功能，操作系统必须为这些任务提供快速且功能强大的通信机制。在VxWorks系统中，有信号量（semaphore）、消息队列（message queue）、管道（pipe）、事件（event）等通信机制，对一个系统开发人员来说，如何合理地使用这些通信机制，是系统能够长期高效、可靠、安全运行的关键。\n信号量（semaphore） # 在VxWorks种，信号量是提供任务间同步和互斥的最快速、开销最小的机制，VxWorks有三种不同类型的信号量：\n二进制信号量：可用于2个任务之间的同步工作。如任务A必须在任务B完成特定的动作以后才能进行，在这种情况下，任务A可以获取信号量而处于阻塞（pend）状态，任务B在完成特定的动作后释放该信号量。一般来说二进制信号量适用于一对一的任务之间的同步。 互斥信号量：主要用于任务之间共享数据区的互斥保护，具有优先级反转、安全删除、递归等特性。在有2个或2个以上的任务共享一个数据区的时候，必须使用互斥机制进行保护。 计数器信号量：类似于二进制信号量，但是对信号量的释放、获取有计数功能，而二进制信号量则只有0和1两种状态。 VxWorks提供了一组管理信号量的函数接口供开发者使用，包括创建、删除、获取、释放等。 虽然信号量具有快速、开销小的优点，但也有它的局限性，首先它无法提供额外的信息，其次对于一个任务必须与多个任务进行同步的情况，信号量也无能为力。因此在许多场合，信号量必须与其它通信机制配合使用来完成任务之间的通信。\n消息队列（message queue） # 消息队列是VxWorks提供的单个CPU中的任务之间通信的主要机制之一。消息队列允许基于FIFO或基于任务优先级方式排队消息，一个消息队列的消息数目和消息长度可以由开发者在创建消息队列时指定。在理论上，VxWorks允许多个任务向同一个消息队列发送消息，或者从同一个消息队列接收消息；而在实际应用中，一般来说只有一个任务从消息队列接收消息，有一个或多个任务发送消息，即这个消息队列有多个生产者，而只有一个消费者。消息队列时单向的，对于需要进行双向通信的两个任务，必须使用两个消息队列。消息队列非常适合于Client-Server结构的任务之间的通信，如图一，任务Client1和Client2都需要任务Server的服务，它们通过消息队列“Request Queue”向任务Server发送请求和参数，任务Server处理请求后分别通过“Reqpy Queue 1”和“Reqpy Queue 2”向这两个任务返回结果。\n在VxWorks中，消息队列是一种代价比较高的一种通信机制，因此在使用时应该使消息的长度尽量短，而且应避免在需要十分频繁通信的场合使用消息队列。另外消息队列中的消息是排队的，即使是完全相同的消息，后面的消息也不会覆盖前面的消息。\n管道（pipe） # 在VxWorks中，管道是一种通过虚拟的I/O设备来实现的消息队列通信机制。使用函数pipeDevCreate()和pipeDevDelete()来生成和删除管道，管道一经生成后，任务之间就可以使用标准I/O操作主要是read()和write()进行通信。管道的优点在于它是一个I/O设备，与标准的VxWorks I/O一样，可以使用select机制，而有了select机制，一个任务很方便地使用多个异步I/O设备，如任务要处理同时从串口、管道、socket接收到的数据，就可以使用select。\n事件（event） # 在5.5版本之前，VxWorks并没有事件这一通信机制。事件(event) 最早出现在pSOS实时操作系统中，在风河公司收购了pSOS之后，从VxWorks 5.5之后，加入了事件机制，并在pSOS事件的基础上做了增强和改进。事件可用于任务和中断服务程序ISR之间、任务和任务之间、任务和VxWorks资源之间进行通信。任务用函数eventReceive()来接收它关心的事件，用eventSend()来向另一个任务发送事件。\nVxWorks资源主要是指信号量和消息队列，一个任务要想从VxWorks资源接收到事件，必须先进行注册(register)，那么当资源处于FREE状态时，会向注册过的任务发送一个事件。对于每一个VxWorks资源，最多只允许有一个任务注册。如对于消息队列，任务可以使用函数msgQEvStart()来进行注册，那么当有消息到达这个消息队列而又没有任务等待这个消息队列时，会向这个任务发送一个事件，表明消息队列可用。而对于信号量，可以用函数semEvStart()来进行注册。但必须注意的是，一个任务接收到资源发送的事件后，并不能保证这个任务能获取该资源，如获取信号量、从消息队列接收到消息。\n在VxWorks中，每一个任务都有一个32位事件寄存器，其中高8位由VxWorks系统保留，开发者可以使用低24位，其每一位表示一种事件，而事件的意义则完全有任务来定义，因此对于不同的任务，相同的位可能有不同的意义。而VxWorks并不对事件进行计数，而只表示该事件发生过，这与消息队列不同，因此接收事件的任务并不能知道接受到的事件发生的次数。\n事件非常适合于一个任务必须与多个任务进行通信的场合，如任务A必须同时与任务B、任务C、任务D进行通信，其中任务B通过消息队列向任务A发送数据，其发送频率较低，它要求任务A必须及时进行处理；而任务C则只是向任务A指示一种状态，但频率很高；而任务D用来通知任务A释放动态申请的资源，并停止运行。在这种场合，事件机制能很好地解决问题。\n总结 # 在VxWorks中，任务之间高效、经济地通信对整个系统的性能有很大的影响。一般来说并不能使用一种单一的通信机制就能解决问题，而是需要同时使用多种通信机制。另外，对任务的合理划分，又能简化任务之间的通信。总之，开发者必须通过足够的实践，才能充分利用VxWorks的各种通信机制，设计出高效、可靠的实时系统\n","date":"2024-10-22","externalUrl":null,"permalink":"/bsp/embedded-os-vxworks-introduction/","section":"Bsps","summary":"\u003cp\u003e\u003ca href=\"https://www.vxworks7.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eRTOS\u003c/a\u003e），是嵌入式开发环境的关键组成部分。\u003c/p\u003e\n\n\n\u003ch1 class=\"relative group\"\u003e嵌入式操作系统VxWorks简介 \n    \u003cdiv id=\"%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fvxworks%E7%AE%80%E4%BB%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fvxworks%E7%AE%80%E4%BB%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003e良好的持续能力、高性能的内核以及友好的用户开发环境，在嵌入式实时操作系统领域占据一席之地。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等。在美国的F-16、FA-18战斗机、B-2隐形轰炸机和爱国者导弹上，甚至连1997年在火星表面登陆的火星探测器上也使用到了VxWorks。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e实时操作系统和分时操作系统的区别 \n    \u003cdiv id=\"%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BA%E5%88%AB\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BA%E5%88%AB\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e从操作系统能否满足实时性要求来区分，可把操作系统分成分时操作系统和实时操作系统。\u003c/p\u003e","title":"嵌入式实时操作系统VxWorks简介","type":"bsp"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/vip/","section":"Tags","summary":"","title":"VIP","type":"tags"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/vsb/","section":"Tags","summary":"","title":"VSB","type":"tags"},{"content":"本文介绍了VxWorks 7系统下自启动应用程序的四种方法。\n在开始之前我们先来了解一下一些vxworks的一些基础知识。\nVxWorks工程 # VxWorks 7 可以创建以下几种典型的工程：\nProject Type Output VSB (VxWorks Source Build) .a VIP (VxWorks Image Project) DKM (Downloadable Kernel Module) .out RTP(Real-Time Process) .vxe VSB: 基于某个特定的bsp，根据支持的cpu架构，把vxworks内核源码编译成静态库。 注意这里这是只是把内核源码编译成库，供后续创建的VIP工程使用，并不会产生任何的映像文件。 内核公共代码预先编译成库，也可以加速用户VIP工程的编译速度。另外也说明，如果你修改了内核代码，你需要重新编译VSB工程才会生效。 VIP: VxWorks 用户自定义的VxWorks映像工程。 把用户选择的各种内核组件(使用CDF文件描述)，根据vxworks的启动顺序编译链接起来，得到常用的VxWorks映像。 各种内核组件在VSB工程中已经预先编译好，供VIP工程挑选使用。 DKM: VxWorks内核态应用程序。可加载的内核模块，类似如linux下的ko文件。 对于跑在内核态的用户代码，即可以添加到VIP工程中，也可以使用DKM工程独立成内核模块。 在VxWorks启动完成后，使用`ld \u003c xxx.out`的命令来动态加载。 RTP: VxWorks用户态应用程序。 跑在用户态的用户代码，使用RTP工程编译成.vxe文件。 在vxworks启动完成后，使用“rtp exec xxx.vxe”命令来执行。 VxWorks shell # VxWorks拥有自己的命令行交互工具kernel shell，比较特殊的是shell有两种模式分别支持两种解析器：C Interpreter和Command Interpreter。\nMode 提示符 模式切换 C Interpreter -\u0026gt; 使用“cmd”命令切换到Command Interpreter模式 Command Interpreter # 使用“C”命令切换到C Interpreter模式 C Interpreter 设计的目的是用来监控、调试内核代码。它最大的特点是可以直接调用函数名来执行，非常方便调试 Command Interpreter 设计的目的是用来启动、监控、调试用户态的RTP应用程序。它提供了很多专门的调试命令，类似于linux shell 详细描述可以参考文档： “installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf” 内核应用程序(DKM)自启动 # 需求来源 # 用户有两个内核应用程序，已经使用DKM工程编译成了.out文件：pruss_eth.out，s24_DriveRotationCiA402.out，在shell的C Interpreter模式下可以动态加载和运行：\nstep 1: 手工加载pruss_eth.out，并调用prussStart()函数进行运行：\n-\u0026gt; ld \u0026lt; /mmc1:1/pruss_eth.out value = 541560848 = 0x20479010 -\u0026gt; prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 step 2: 手工加载s24_DriveRotationCiA402.out，并调用main()函数进行运行：\n-\u0026gt; ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerStop. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerCreate. Warning: module 0x20479874 holds reference to undefined symbol MasterStartPIClientProcessor. Warning: module 0x20479874 holds reference to undefined symbol MasterStopPIClientProcessor. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x20479874 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. value = 0 = 0x0 -\u0026gt; main Initialize Master ... Create Master instance ... Get network adapter name ... Network adapters count: Attach Master to adapter \u0026#39;kpa_pruss0\u0026#39; ... Create Configurator instance to load configuration ... Loading ENI \u0026#39;/master.xml\u0026#39; ... ... 用户希望在做硬件测试或者正式产品时，以上两步骤能够自动运行。\n方案1(失败) # VxWorks支持使用INCLUDE_RTP_APPL_INIT_BOOTLINE组件来配置系统启动时自动运行C Interpreter格式的脚本，我们尝试使用此方法来实现系统启动时自加载DKM并运行。\n首先我们在VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_BOOTLINE选项： VIP工程的SCRIPT_DEFAULT选项设置为我们需要运行的脚本“/mmc1:1/autorun_c.sh”： ** SCRIPT_DEFAULT **主要的作用是设置default bootline中的startup script选项。VxWorks在INCLUDE_RTP_APPL_INIT_BOOTLINE使能的情况下，会在启动阶段执行bootline中startup script选项描述的C脚本：\nusrRoot() -\u0026gt; usrToolsInit() -\u0026gt; usrShellInit(): void usrShellInit (void) { shellLibInit (); /* This component includes the shell core files. */ shellHistLibInit (); /* This component provides the histSave() and histLoad() functions for the C interpreter. */ dbgLibInit (DEBUG_STACK_TRACE_BUF_SIZE);/* This component includes the primary interactive functions for VxWorks. * The following facilities are provided: task breakpoints, task single-stepping, * symbolic disassembly, symbolic task stack tracing. */ vxdbgRtpLibInit (); /* This component includes the process debugging library. */ ledModeRegister (emacsLedLibInit); /* This component provides an editing mode similar to the Emacs editor. */ shellInterpRegister (shellInterpCInit); /* This component provides the C interpreter for the kernel shell. */ shellInterpRegister (shellInterpCmdInit); /* This component provides the command interpreter for the kernel shell. */ usrShellCmdInit (); /* The kernel shell commands initialization sequence */ /* (1) 从bootline参数的startupScript选项中解析出脚本名，并执行 */ usrStartupScript (startupScriptFieldSplit (sysBootParams.startupScript)); /* Including this component results in the execution of a kernel shell script at VxWorks startup. */ usrShell (); /* This component includes the target-resident kernel shell, * which is spawned as a task. Any function that is invoked from the kernel shell, * rather than spawned, runs in the shell\u0026#39;s context. * The task name for a shell on the console is \u0026#34;tShell0\u0026#34;. * The kernel shell is re-entrant, and more than one shell task can run at a time (hence the number suffix). * In addition, if a user logs in remotely (using rlogin or telnet) to a VxWorks target, * the name reflects that fact as well. For example, \u0026#34;tShellRem1\u0026#34;. * The \u0026#34;tShell\u0026#34; basename is configurable, see the VxWorks 7 Kernel Shell User\u0026#39;s Guide. */ } 如果使用VxWorks自带的bootloader，可以在boot cmd命令行中配置bootline的startup script选项:\nstartup script (s) : /mmc1:1/autorun_c.sh 但是我们目前方案的bootloader使用的是uboot，所以我们只需配置好默认bootline中的startup script选项。\nautorun_c.sh脚本中的内容非常简单，就是我们手工执行时需要键入的4条指令： ld \u0026lt; /mmc1:1/pruss_eth.out prussStart ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out main 运行结果： 实际的运行结果，发现VxWorks启动后，卡住几分钟才能执行到autorun_c.sh脚本： Adding 11197 symbols for standalone. // vxworks启动完成 // 卡住了好几分钟 Waiting for device to mount // autorun_c.sh脚本才得到执行 Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541474832 = 0x20464010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 ... 初步分析卡住的原因： 在“usrRoot() -\u0026gt; usrToolsInit() -\u0026gt; usrShellInit()-\u0026gt;usrStartupScript()”这个时间点执行“/mmc1:1/autorun_c.sh”脚本时，“/mmc1:1/”设备并没有mount好，usrStartupScript()函数中重试机制在不停的重新尝试执行，但是这个重试机制又会阻止“/mmc1:1/”的mount进程，所以会卡死很久。\n因为没有深入研究VxWorks的初始化流程，我们先尝试使用别的方法，后续有时间可以研究卡住问题的解决方案。\n方案2(成功) # VxWorks执行自定义内核程序，还有一个公共的入口在usrAppInit()函数当中，函数调用关系如下：\nvoid usrRoot (char *pMemPoolStart, unsigned memPoolSize) { ... usrToolsInit (); // 这里进行usrShellInit()-\u0026gt;usrStartupScript()的调用 usrAppInit (); ... } 可以看到usrAppInit()调用点比方案1的usrShellInit()调用点靠后，我们尝试在usrAppInit()里面实现内核模块DKM的自加载。\n我们在usrAppInit()函数中直接调用usrStartupScript()来运行\u0026quot;/mmc1:1/autorun_c.sh\u0026quot;脚本： void usrAppInit (void) { #ifdef\tUSER_APPL_INIT USER_APPL_INIT;\t/* for backwards compatibility */ #endif /* TODO: add application specific code here */ ioDefPathSet(\u0026#34;/mmc1:1/\u0026#34;); usrStartupScript(\u0026#34;/mmc1:1/autorun_c.sh\u0026#34;); } autorun_c.sh脚本的内容还是和方案1一样： ld\u0026lt;/mmc1:1/pruss_eth.out prussStart ld\u0026lt;/mmc1:1/s24_DriveRotationCiA402.out main 运行结果： VxWorks启动后，没有卡住的现象，autorun_c.sh脚本能迅速得到执行：\nAdding 11197 symbols for standalone. Waiting for device to mount .-\u0026gt; Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541536272 = 0x20473010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStop. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerCreate. Warning: module 0x204735b8 holds reference to undefined symbol MasterStartPIClientProcessor. Warning: module 0x204735b8 holds reference to undefined symbol MasterStopPIClientProcessor. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. value = 0 = 0x0 Done executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;. -\u0026gt; 但细心的同学会发现autorun_c.sh脚本中的4条指令只执行了3条，最后一条\u0026quot;main\u0026quot;指令并没有得到执行，但是在shell下手工键入又可以得到执行，这是为什么呢？\n首先怀疑main这个符号和其他人重名，造成调用失败。但是查找符号表后，发现并没有重名情况：\n-\u0026gt; -\u0026gt; cmd [vxWorks *]# [vxWorks *]# lookup main ipnet_radvd_main 0x001b8988 text main 0x00c9976c text (s24_DriveRotationCiA402.out) ipftpc_cmd_main 0x001325bc text vxbClkDomainInit 0x003d5c00 text tiClkDomainDrv 0x004cf6fc data vxbClkDomainRegister 0x003d4af8 text ipnet_flow_spec_domain 0x0015bc78 text ipftps_main 0x001374a8 text __dataset__driver_tiClkDomainDrv 0x004ddaa4 data [vxWorks *]# 进一步分析运行log发现一个情况：同样是加载.out文件，ld \u0026lt; /mmc1:1/pruss_eth.out的返回值0x20473010其实是pruss_eth.out 加载后的MODULE ID，但是ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out的返回值却为0:\n-\u0026gt; cmd [vxWorks *]# module MODULE NAME MODULE ID GROUP # TEXT START DATA START BSS START --------------- ---------- ---------- ---------- ---------- ---------- pruss_eth.out 0x20473010 1 0x00b59010 0x00b5b0e4 NO SEGMENT s24_DriveRotati 0x20473874 2 0x00b5c010 0x00cade18 0x00cb4064 于是怀疑ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out的加载过程出错，autorun_c.sh脚本执行中断，造成了随后的main命令没有得到运行。 在ld \u0026lt; /mmc1:1/s24_DriveRotationCiA402.out我们可以看到有几个人符号没有得到解析的告警，虽然module还是加载上了还能手工执行，但是这个出错可能会中断脚本的运行：\n... Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerStart. Warning: module 0x204735b8 holds reference to undefined symbol EcatMasterServerDelete. ld(): module contains undefined symbol(s) and may be unusable. 沿着这个分析方向，让用户编译一份没有符号解析错误的.out文件进行测试。\n没有符号解析错误的.out，运行结果： 用户编译了一份没有符号解析错误的newmaster.out，来替换之前出错的s24_DriveRotationCiA402.out，autorun_c.sh脚本中的4条指令能够完美的得到执行：\nAdding 11197 symbols for standalone. Waiting for device to mount .-\u0026gt; Instantiating /sd0:2 as rawFs, device = 0x50001 Executing startup script \u0026#39;/mmc1:1/autorun_c.sh\u0026#39;... ld \u0026lt; /mmc1:1/pruss_eth.out value = 541560848 = 0x20479010 prussStart init PRUSS2: physical memory 4B280000-4B2BFFFF init PRUSS2: interrupts #186 #187 PRUSS2: Download firmware to PRU0 PRUSS2: Download firmware to PRU1 PRUSS2: start PRU0 PRUSS2: start PRU1 value = 0 = 0x0 ld \u0026lt; /mmc1:1/newmaster.out value = 541562996 = 0x20479874 = \u0026#39;t\u0026#39; main Initialize Master ... Create Master instance ... Get network adapter name ... Network adapters count: Attach Master to adapter \u0026#39;kpa_pruss0\u0026#39; ... Create Configurator instance to load configuration ... Loading ENI \u0026#39;/master.xml\u0026#39; ... Starting Master ... Master started. Start EtherCAT frames exchange ... Requesting Operational Master state ... ... 用户应用程序(RTP)自启动 # 在文档\u0026quot;installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf\u0026quot;的\u0026quot;Automatic Execution of RTP Applications\u0026quot;章节，对RTP自启动的几种方法有着详细的描述，感兴趣可以自行学习。\n我们以vxsim架构下的一个RTP程序为例来详细介绍这些方法。\n首先我们创建了基于vxsim架构的VSB、VIP工程，并且创建了一个测试使用的RTP工程。测试代码的内容很简单：\nrtp.c: #include \u0026lt;stdio.h\u0026gt; int main ( int\targc,\t/* number of arguments */ char * argv[]\t/* array of arguments */ ) { int i = 0; printf(\u0026#34;Hello World!\\nFrom your RTP application...\\nBy pwl.\\n\u0026#34;); while(i\u0026lt;3){ i++; taskDelay(100); printf(\u0026#34;%d ticks\\n\u0026#34;, i*100); } return 0; } 我们使用这个RTP工程编译出TestSimRtp.vxe映像文件。\n手工执行TestSimRtp.vxe文件有两种方式：\n在C shell下执行： -\u0026gt; -\u0026gt; rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; value = 941088064 = 0x3817dd40 = \u0026#39;@\u0026#39; -\u0026gt; Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; 在Command shell下执行： -\u0026gt; -\u0026gt; cmd [vxWorks *]# rtp exec host:D:/pwl_workspace/TestSimRtp.vxe Launching process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; ... Process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; (process Id = 0x38cfb358) launched. Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks [vxWorks *]# 自动执行方式1 (RTP_APPL_INIT_STRING) # 首先在vxsim的VIP工程中的配置选项中，使能INCLUDE_RTP_APPL_INIT_STRING选项： 配置其中的RTP_APPL_INIT_STRING参数： RTP_APPL_INIT_STRING参数的具体内容为：\n\u0026#34;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 这个字符串的详细语法可以参考 \"installDir\\docs\\vxworks-7-1.0.8.6\\Core\\vxworks_7_programmers_guide.pdf\"中的\"Application Startup String Syntax\"小节。 启动vxworks simulator，查看运行结果，成功自动运行： Loading symbol table from host:D:/pwl_workspace/TestSimVip/default/vxWorks.sym ...done -\u0026gt; Spawning RTP: host:D:/pwl_workspace/TestSimRtp.vxe Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; 自动执行方式2 (RTP_APPL_INIT_BOOTLINE) # VxWorks支持使用INCLUDE_RTP_APPL_INIT_BOOTLINE组件来配置系统启动时自动运行C Interpreter格式的脚本，我们尝试使用此方法来实现系统启动时自动运行RTP程序。\n首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_BOOTLINE选项： vxsim VIP工程的SCRIPT_DEFAULT选项设置： startup script具体的配置如下：\n\u0026#34;host:D:/pwl_workspace/autorun_c.sh#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 需要注意的是startup script中可以配置两种不同的自启动方式，上述的参数可以分成两部分：\n“host:D:/pwl_workspace/autorun_c.sh”这部分配置的是VxWorks在启动阶段执行一个C Interpreter格式的脚本。autorun_c.sh脚本的具体内容如下： rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; 需要特别注意的是，这里调用的是C Interpreter格式的脚本，后面的`RTP_APPL_INIT_CMD_SHELL_SCRIPT`方式调用的是Command Interpreter格式的脚本。 \u0026ldquo;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026quot;这部分配置的语法和INCLUDE_RTP_APPL_INIT_STRING选项一样。 上述参数分别运行了一次TestSimRtp.vxe，所以TestSimRtp.vxe会被运行两次。\n启动vxworks simulator，查看运行结果，成功自动运行两次： Loading symbol table from host:D:/pwl_workspace/TestSimVip/default/vxWorks.sym ...done // (1) 第一次执行，使用autorun_c.sh脚本的执行 Executing startup script \u0026#39;host:D:/pwl_workspace/autorun_c.sh\u0026#39;... rtpSp \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34; value = 950476976 = 0x38a720b0 Hello World! From your RTP application... By pwl. Done executing startup script \u0026#39;host:D:/pwl_workspace/autorun_c.sh\u0026#39;. // (2) 第二次执行，使用\u0026#34;#host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34;选项配置的执行 -\u0026gt; Spawning RTP: host:D:/pwl_workspace/TestSimRtp.vxe Hello World! From your RTP application... By pwl. 100 ticks 100 ticks 200 ticks 200 ticks 300 ticks 300 ticks -\u0026gt; 自动执行方式3 (RTP_APPL_INIT_CMD_SHELL_SCRIPT) # 首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_INIT_CMD_SHELL_SCRIPT选项，并配置其中的RTP_APPL_CMD_SCRIPT_FILE参数： 参数的具体内容为：\u0026ldquo;host:D:/pwl_workspace/autorun_cmd.sh\u0026rdquo; 系统启动时自动运行配置的Command Interpreter格式的脚本autorun_cmd.sh,autorun_cmd.sh脚本的具体内容为：\nrtp exec host:D:/pwl_workspace/TestSimRtp.vxe 启动vxworks simulator，查看运行结果，成功自动运行： -\u0026gt; Executing startup script \u0026#39;host:D:/pwl_workspace/autorun_cmd.sh\u0026#39;... rtp exec host:D:/pwl_workspace/TestSimRtp.vxe Launching process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; ... Process \u0026#39;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#39; (process Id = 0x38d3a890) launched. Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks Done executing startup script \u0026#39;host:D:/pwl_workspace/autorun_cmd.sh\u0026#39;. -\u0026gt; 自动执行方式4 (RTP_APPL_USER) # 首先我们在vxsim VIP工程的配置选项中，使能INCLUDE_RTP_APPL_USER选项： 在INCLUDE_RTP_APPL_USER选项被使能以后，vxworks启动时会调用usrRtpAppInit.c文件中的usrRtpAppInit()函数。我们可以在此函数中加入自己的rtp启动代码： void usrRtpAppInit (void) { /* TODO - add your own application launch code here */ /* (1) 使用代码调用rtpSpawn()函数来运行TestSimRtp.vxe文件 */ char * vxeName = \u0026#34;host:D:/pwl_workspace/TestSimRtp.vxe\u0026#34;; char * argv[5]; RTP_ID rtpId = NULL; /* set the application\u0026#39;s arguments */ argv[0] = vxeName; argv[1] = NULL; argv[2] = NULL; argv[3] = NULL; argv[4] = NULL; /* Spawn the RTP. No environment variables are passed */ if ((rtpId = rtpSpawn (vxeName, argv, NULL, 220, 0x10000, 0, 0)) == NULL) { printf (\u0026#34;Impossible to start %s application \u0026#34;, vxeName); } } 启动vxworks simulator，查看运行结果，成功自动运行： -\u0026gt; Hello World! From your RTP application... By pwl. 100 ticks 200 ticks 300 ticks -\u0026gt; ","date":"2024-10-20","externalUrl":null,"permalink":"/app/vxworks-7-app-auto-boot-method/","section":"Apps","summary":"\u003cp\u003e本文介绍了VxWorks 7系统下自启动应用程序的四种方法。\u003c/p\u003e\n\u003cp\u003e在开始之前我们先来了解一下一些vxworks的一些基础知识。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003eVxWorks工程 \n    \u003cdiv id=\"vxworks%E5%B7%A5%E7%A8%8B\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#vxworks%E5%B7%A5%E7%A8%8B\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eVxWorks 7 可以创建以下几种典型的工程：\u003c/p\u003e","title":"VxWorks 7自启动应用程序的四种方法","type":"app"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/arinc429/","section":"Tags","summary":"","title":"ARINC429","type":"tags"},{"content":"","date":"2024-10-20","externalUrl":null,"permalink":"/tags/avionics/","section":"Tags","summary":"","title":"Avionics","type":"tags"},{"content":"航电激励器在民用飞机航电系统半物理仿真平台中起着至关重要的作用。在航电系统开发过程中，航电激励器向航电仿真设备提供的激励数据是进行航电系统仿真验证的基础，所以在航电激励数据的获取和处理中，航电激励器的设计与实现是极其重要的一个环节。该文基于VxWorks 系统设计一款航电激励器，对航电激励器进行总体设计，从激励数据获取模块、激励数据转换模块等方面进行研究，完成软件设计以及硬件平台搭建。通过对设计的航电激励器进行仿真验证，实现飞机模拟飞行数据的获取以及航电系统中ARINC429 总线数据和AFDX 总线数据的相互转换，使得激励数据在传输过程中具有良好的实时性。\n航空电子系统是指飞机上所有电子系统的总和，其仿真验证在航电系统的设计与研发过程中起着重要的作用，对航电系统进行仿真验证，可以有效地降低航电系统集成过程中存在的风险和成本，缩短开发周期。在进行各种仿真验证时，需要航电激励器向仿真组件提供激励信号，所以航电激励器提供的激励信号的准确性和稳定性将对仿真验证的结果产生直接影响。\n目前，航电激励器主要是基于Windows 系统开发的，在数据传输的实时性、可靠性等方面略显不足，并且在向仿真组件提供激励信号时，常出现数据的延时、丢包等问题。VxWorks 系统采用优先级抢占和轮转调度的任务调度机制，具有良好的实时性。基于VxWorks系统开发的航电激励器可以很好地解决Windows 系统下开发的航电激励器所存在的不足。因此本文设计一款基于VxWorks 系统的航电激励器，能够为航电系统提供具有实时性、可靠性的激励信号。\n航电激励器总体设计 # 本文设计的航电激励器由软件和硬件两部分构成。软件部分主要包括激励数据获取模块和数据转换模块。其中，激励数据获取模块通过以太网接收飞机模拟飞行过程中的飞行数据，这些数据包括飞机的位置、姿态、通信导航系统的工作频率等参数。航电激励器数据转换模块主要实现AFDX 总线数据、ARINC429 总线数据的编解码，完成ARINC429 总线数据与AFDX 总线数据相互转化，并向各航电仿真组件传输激励数据。AFDX 数据总线协议见文献[4]，ARINC429 总线协议见文献[5]。硬件部分主要完成VxWorks 系统在MPC8270 上的移植，建立硬件开发平台。航电激励器总体设计如图1所示。\n图1 航电激励器总体设计 航电激励器的软件设计 # 激励数据获取模块 # 从实际应用的角度出发，激励数据获取模块所获取的激励数据主要来源于飞行仿真软件中的飞行数据，通过激励数据获取模块实现激励数据获取模块与飞行仿真软件的内存共享，从而实现飞行数据的实时获取。\n通过以太网发送的飞行数据格式是基于UDP 数据包格式，数据获取模块接收到1 帧数据包后，首先对该数据包的帧头进行判断，其次判断数据帧校验位的正确与否，然后对校验位正确的数据包进行确定报文类型并解析出报文所包含的信息。通过设计ARINC429 总线数据字编码的接口函数，调用ARINC429 数据字编码接口，对将UDP 格式的数据包解码后的飞行数据信息进行编码得到激励数据对应的ARINC429 数据字，确定周期和通道后将该ARINC429 数据字输出到航电仿真组件。激励数据获取流程如图2 所示。\n激励数据转换模块 # AFDX 总线凭借着卓越的传输效率以及高可靠性等特点，广泛地应用于B-787、A380 等先进机型中。目前，航电系统主干网络通常采用AFDX 总线将机载各个子系统连接成一个高效可靠的整体，而飞机很多子系统仍采用比较成熟的ARINC429 总线。因此，本文设计航电激励器的数据转换模块，实现AFDX 总线激励信号与ARINC429 总线激励信号之间的相互转换。上述两种数据格式总线信号的相互转换是互为逆过程，本节将通过设计航电激励器收发ARINC429 总线数据字对应的AFDX 总线数据包，从而实现总线数据间的编码转换。\n图2 激励数据获取流程 对AFDX 总线数据进行分析，将AFDX 总线报文设计成可由多个“消息”（Message）拼接而成的通用格式。AFDX 总线中的每条“消息”都分为三个部分，便于将ARINC429 总线的数据字结构填入AFDX 数据帧结构中。MsgType 指的是对消息类型的编码；LengthInBytes是表示PayLoad 字段的长度；PayLoad 是AFDX 总线的承载内容。PayLoad 长度是可变的，其具体承载的信息格式由MsgType 的值决定。AFDX 总线报文中消息的通用格式如图3 所示。\n图3 AFDX 总线报文中消息的通用格式 硬件平台设计 # VxWorks 系统为开发者提供大量板级支持包BSP（Board Support Packet），便于简化BSP 移植工作。在进行BSP 移植之前，需要根据CPU 型号选择相应BSP 包，同时参考硬件数据调整BSP 相关配置信息。在完成BSP 配置后，建立新的VxWorks Image Project 工程，同时创建映像所需的文件。\n图4 ARINC429 总线数据转换为AFDX 数据包 VxWorks 模块是根据目标板卡的性能需求完成VxWorks 系统内核模块的配置。VxWorks 系统映像经编译生成后，对FTP 环境进行调试。通过运行Workbench 3.3 中的FTP Server，完成FTP 环境中的用户信息配置。完成以上配置后，将VxWorks 映像下载至目标板卡MPC8270 运行。至此完成VxWorks 系统平台的搭建。\n航电激励器的仿真与测试 # 在航电激励器的功能实现之后需要对航电激励器进行验证测试，主要针对航电激励器所能提供的航电激励信号进行测试，即ARINC429 总线激励信号、AFDX 总线激励信号以及激励信号实时性测试。\nARINC429 总线激励信号数据测试 # 航电激励器对接收到的ARINC429 总线激励信号进行数据符合性测试。在飞行数据中获取其中5 种激励数据进行测试，如表1 所示。将航电激励器的一条ARINC429 输出通道连接到ARINC429 总线分析仪，将表1 中激励数据统一设置发送周期为200 ms，输出到ARINC429 总线分析仪。总线分析仪所显示的激励数据如图5 所示。\n表1 激励参量取值 图5 ARINC429 总线分析仪显示的数据 将表1 数据信息与图5 显示结果进行对比，结果显示二者所包含的数据信息一致，航电激励器输出的ARINC429 总线激励信号满足数据符合性要求。\nAFDX 总线激励信号数据测试 # 激励数据获取模块选择飞行仿真软件中模拟飞机的VOR1 频率飞行数据进行验证，激励数据VOR1 频率的相关信息如表2 所示。航电激励器将AFDX 总线激励信号通过AFDX 板卡发送至交换机，通过Wireshark 抓取AFDX 数据包，对应抓取数据包为十六进制数：3800DC84，结果如图6 所示。通过对比验证，航电激励器输出的AFDX 总线激励信号中的数据信息与ARINC429 负载数据一致，航电激励器实现了ARINC429 总线激励信号转化为AFDX 信号的预期功能。\n表2 航电激励器输出AFDX 信号配置信息 图6 VOR1 频率数据包 激励信号实时性测试 # 本文依靠VxWorks 系统的独特优势保证数据获取的实时性。“实时”并不意味着是“快”，而是指系统响应的时间确定性。时间确定性具体体现为航电激励器能否完全按照规定周期对激励信号进行收发。首先基于VxWorks 系统下的航电激励器对ARINC429 总线激励信号进行输出，配置输出数据信息如表3 所示。\n表3 输出ARINC429 总线信号配置信息 配置信息完成后，在低速（12.5 Kb/s）模式下，航电激励器输出ARINC429 总线激励信号，通过示波器对ARINC429 的8 号输出通道进行测试。同理，利用Windows 系统下的航电激励器完成表3 配置数据的发送，测试出每对相邻波形起始点间的时间间隔，测试结果如表4 所示。\n经测试验证，基于VxWorks 系统的航电激励器输出的2 组连续信号波形时间间隔与设定发送周期相同，为精确的30.00 ms，没有产生抖动延迟。然而Windows 系统下航电激励器在进行激励信号的周期性发送时，连续的两个信号间的时间间隔容易产生时间抖动，每组波形间的时间延迟在1 ms 以上。综上所述，基于VxWorks系统的航电激励器在时间确定性效果方面更能满足航电系统仿真验证的高实时性需求。\n表4 单通道时间确定性测试结果 ms 结 论 # 本文基于VxWorks 系统，以MPC8270 为目标平台，提出航电激励器的总体设计方案并进行详细设计，最终实现AFDX 总线数据与ARINC429 总线数据的相互转换，为实际的航电仿真系统提供良好的激励数据。通过仿真测试表明所设计的航电激励器达到预期效果。\n（本文来源于《现代电子技术》，作者：孙毅刚，迟文强，作者单位：中国民航大学航空工程学院）\n全文下载地址: 基于VxWorks系统的航电激励器设计与实现\n","date":"2024-10-20","externalUrl":null,"permalink":"/app/design-and-implementation-of-avionics-exciter-based-on-vxworks-system/","section":"Apps","summary":"\u003cp\u003e航电激励器在民用飞机航电系统半物理仿真平台中起着至关重要的作用。在航电系统开发过程中，航电激励器向航电仿真设备提供的激励数据是进行航电系统仿真验证的基础，所以在航电激励数据的获取和处理中，航电激励器的设计与实现是极其重要的一个环节。该文基于\u003ca href=\"https://www.vxworks6.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e 系统设计一款航电激励器，对航电激励器进行总体设计，从激励数据获取模块、激励数据转换模块等方面进行研究，完成软件设计以及硬件平台搭建。通过对设计的航电激励器进行仿真验证，实现飞机模拟飞行数据的获取以及航电系统中\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eARINC429\u003c/a\u003e 总线数据和AFDX 总线数据的相互转换，使得激励数据在传输过程中具有良好的实时性。\u003c/p\u003e\n\u003cp\u003e航空电子系统是指飞机上所有电子系统的总和，其仿真验证在航电系统的设计与研发过程中起着重要的作用，对航电系统进行仿真验证，可以有效地降低航电系统集成过程中存在的风险和成本，缩短开发周期。在进行各种仿真验证时，需要航电激励器向仿真组件提供激励信号，所以航电激励器提供的激励信号的准确性和稳定性将对仿真验证的结果产生直接影响。\u003c/p\u003e\n\u003cp\u003e目前，航电激励器主要是基于Windows 系统开发的，在数据传输的实时性、可靠性等方面略显不足，并且在向仿真组件提供激励信号时，常出现数据的延时、丢包等问题。VxWorks 系统采用优先级抢占和轮转调度的任务调度机制，具有良好的实时性。基于VxWorks系统开发的航电激励器可以很好地解决Windows 系统下开发的航电激励器所存在的不足。因此本文设计一款基于VxWorks 系统的航电激励器，能够为航电系统提供具有实时性、可靠性的激励信号。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e航电激励器总体设计 \n    \u003cdiv id=\"%E8%88%AA%E7%94%B5%E6%BF%80%E5%8A%B1%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E8%88%AA%E7%94%B5%E6%BF%80%E5%8A%B1%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e本文设计的航电激励器由软件和硬件两部分构成。软件部分主要包括激励数据获取模块和数据转换模块。其中，激励数据获取模块通过以太网接收飞机模拟飞行过程中的飞行数据，这些数据包括飞机的位置、姿态、通信导航系统的工作频率等参数。航电激励器数据转换模块主要实现AFDX 总线数据、ARINC429 总线数据的编解码，完成ARINC429 总线数据与AFDX 总线数据相互转化，并向各航电仿真组件传输激励数据。AFDX 数据总线协议见文献[4]，ARINC429 总线协议见文献[5]。硬件部分主要完成VxWorks 系统在MPC8270 上的移植，建立硬件开发平台。航电激励器总体设计如图1所示。\u003c/p\u003e","title":"基于VxWorks 系统的航电激励器设计与实现","type":"app"},{"content":" VxWorks The Leading RTOS The industry's most widely deployed RTOS. VxWorks has been used to ensure the security, safety, and reliability you need to design and build mission-critical embedded systems that simply must work.\n支持OCI容器，一键升级 # VxWorks是全球首个且唯一一个利用容器部署应用程序的实时操作系统。\n最新版的VxWorks 7支持OCI容器，利用类似IT的传统技术，即可更高效更优质地开发和部署智能边缘软件，且不会影响确定性和性能。了解为何研究机构VDC再次将VxWorks评为最佳边缘部署实时操作系统。\nVxWorks：现代设计，面向未来，始终实时 # VxWorks是一款确定性、基于优先级的抢占式实时操作系统，具有超低延迟和最小抖动。为应对未来挑战，VxWorks采用可升级架构，助力企业快速响应不断变化的市场需求，确保技术永不过时。\nVxWorks是唯一支持C ++ 17、Boost、Rust、Python、pandas等开发语言的实时操作系统，搭载边缘优化和OCI兼容的容器引擎，便于企业灵活选择开发语言、工具和技术，创新机要事务。\n超高信息安全 # 智能边缘中各设备、系统和行业的需求各不相同，信息安全威胁也在不断演进。VxWorks可提供超高信息安全，助力企业构建安全设备，应对当前威胁；此外，其灵活的模块化设计可积极应对未来挑战。同时，风河的检索数据库包括MITRE公共漏洞和暴露（CVEs）信息，可为客户提供最新的信息安全补丁。\nVxWorks 653和VxWorks 认证版 # VxWorks满足EN 50128、IEC 61508、ISO 26262、DO-178C和ED-12C等严苛的功能安全认证要求，可用于最具挑战性的安全关键型应用程序，且更便捷、更具成本效益。\n板级支持包 # 风河与芯片供应商和硬件制造商保持有密切联系，可提供开箱即用的板卡支持包，支持Arm、Power、英特尔和RISC-V等各类架构，降低企业开发成本，减少兼容组件的采购时间，可为客户预留更多时间用于产品研发。\n","date":"2024-10-04","externalUrl":null,"permalink":"/","section":"VxWorks Overview","summary":"\u003cblockquote\u003e\nVxWorks The Leading RTOS\u003c/br\u003e\nThe industry's most widely deployed RTOS.\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.vxworks6.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e has been used to ensure the security, safety, and reliability you need to design and build mission-critical embedded systems that simply must work.\u003c/p\u003e","title":"VxWorks Overview","type":"page"},{"content":"","date":"2019-08-01","externalUrl":null,"permalink":"/tags/vulnerability/","section":"Tags","summary":"","title":"Vulnerability","type":"tags"},{"content":" 背景 # Armis研究人员在VxWorks中发现了11个零日漏洞，VxWorks是最受欢迎的实时操作系统（RTOS），被超过20亿台设备使用，包括工业，医疗和企业设备等关键任务设备。这些漏洞被称为\u0026rsquo;URGENT/11\u0026rsquo;，存在于IPnet，VxWorks的TCP/IP堆栈中，影响了过去13年的版本，并且是影响操作系统的漏洞的罕见示例。在其32年的历史中，MITER仅列出了13个影响VxWorks的CVE，其中没有一个像URGENT/11那样严重。\n近年来，广泛使用的TCP/IP栈实现中的漏洞变得极其罕见，尤其是那些能够在目标设备上实现远程代码执行的漏洞。这种类型的漏洞是攻击者的圣杯，因为它们不依赖于特定应用程序，只要求攻击者能够通过网络访问目标设备。当在TCP实现中发现这样的漏洞时，它们甚至可以被用来绕过防火墙和NAT解决方案，因为它们隐藏在看起来无害的TCP流量中。\n漏洞列表 # 发现的11个漏洞由6个关键漏洞组成，可能导致远程代码执行：\nCVE-2019-12256：在解析IPv4数据包IP选项时的栈溢出 CVE-2019-12255：TCP紧急指针 为 0时导致整数下溢 CVE-2019-12260：由格式错误的TCP AO选项导致的TCP紧急指针状态混乱 CVE-2019-12261：连接到远程主机时TCP紧急指针状态混乱 CVE-2019-12263：由竞争条件导致的TCP紧急指针状态混乱 CVE-2019-12257：在ipdhcpc中的DHCP Offer / ACK解析导致的堆溢出 以及5个可能导致拒绝服务、逻辑错误或信息泄漏的漏洞：\nCVE-2019-12258：通过格式错误的TCP选项进行TCP连接时DoS攻击 CVE-2019-12262：处理未经请求的反向ARP回复（逻辑漏洞） CVE-2019-12264：ipdhcpc DHCP客户端分配IPv4的逻辑缺陷 CVE-2019-12259：IGMP解析中的NULL dereference导致的拒绝服务 CVE-2019-12265：IGMP通过IGMPv3特定成员报告造成信息泄漏 漏洞利用场景 # 第一个攻击情形影响驻留在网络边界的VxWorks设备，例如防火墙。这些设备直接受到来自Internet的攻击，因为它们保护的内部网络的完整性依赖于它们。使用URGENT/11漏洞，攻击者可以对这些设备发起直接攻击，对其进行完全控制，随后控制它们所保护的网络。\n第二种攻击情形会影响任何受影响的具有外部网络连接的VxWorks设备。URGENT/11漏洞使攻击者能够接管此类设备，无论在网络外围实施任何防火墙或NAT解决方案以抵御攻击。漏洞的低级性质使得攻击对安全措施保持不可见，因为它们将被视为良性网络通信。\n第三种攻击情形攻击者与VxWorks设备处于同一个局域网，可以广播他的恶意数据包来同时攻击所有易受攻击的设备。\n降低被攻击的可能性 # 降低所述漏洞的风险并非易事。与PC和移动电话等消费类设备使用的操作系统不同，大多数嵌入式设备使用的底层操作系统不会定期做更新。为了降低这些漏洞的风险，首先需要确定哪些设备运行VxWorks。\n除了难以识别哪些设备运行VxWorks之外，设备制造商还面临着在合理时间内提供固件升级的挑战。许多VxWorks设备，如医疗和工业设备，需要经过广泛的测试和认证过程，才能向最终用户提供固件更新。在提供此类更新之前，用户如何保护自己？\n幸运的是，对于发现的漏洞有一些惟一的标识符，防火墙和IDS解决方案可以使用它们来检测和阻止对这些漏洞的任何利用尝试。\n例如，发现的四个最关键的漏洞 (CVE-2019-1255，CVE-2019-1260，CVE-2019-1261，CVE-2019-1263) 使用TCP的紧急标记来滥用TCP的紧急指针机制。这种机制对于普通用户来说很少使用，创建规则来检测和阻止它的任何使用，可以有效防止被攻击。\n要检测并阻止尝试利用IP选项漏洞（CVE-2019-12256），可以搜索包含LSRR或SSRR选项的任何IP数据包并丢弃。\n影响版本 # URGENT/11漏洞影响自6.5版以上的所有VxWorks版本。\nVxWorks已提供补丁更新:\nhttps://www.windriver.com/security/announcements/tcp-ip-network-stack-ipnet-urgent11/ 时间线 # 2019-07-29 Armis发布报告\n2019-07-31 360CERT发布预警\n参考链接 # 攻击演示视频一 攻击演示视频二 攻击演示视频三 ","date":"2019-08-01","externalUrl":null,"permalink":"/news/multiple-high-risk-vulnerability-alerts-for-vxworks/","section":"News","summary":"\u003ch2 class=\"relative group\"\u003e背景 \n    \u003cdiv id=\"%E8%83%8C%E6%99%AF\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E8%83%8C%E6%99%AF\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eArmis研究人员在\u003ca href=\"https://www.vxworks6.com\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e中发现了11个零日漏洞，VxWorks是最受欢迎的实时操作系统（RTOS），被超过20亿台设备使用，包括工业，\u003ca href=\"https://www.vxworks6.com/industries/vxworks-for-medical/\" target=\"_blank\"\u003e医疗\u003c/a\u003e和企业设备等关键任务设备。这些漏洞被称为\u0026rsquo;URGENT/11\u0026rsquo;，存在于IPnet，VxWorks的TCP/IP堆栈中，影响了过去13年的版本，并且是影响操作系统的漏洞的罕见示例。在其32年的历史中，MITER仅列出了13个影响VxWorks的CVE，其中没有一个像URGENT/11那样严重。\u003c/p\u003e\n\u003cp\u003e近年来，广泛使用的TCP/IP栈实现中的漏洞变得极其罕见，尤其是那些能够在目标设备上实现远程代码执行的漏洞。这种类型的漏洞是攻击者的圣杯，因为它们不依赖于特定应用程序，只要求攻击者能够通过网络访问目标设备。当在TCP实现中发现这样的漏洞时，它们甚至可以被用来绕过防火墙和NAT解决方案，因为它们隐藏在看起来无害的TCP流量中。\u003c/p\u003e\n\n\n\u003ch2 class=\"relative group\"\u003e漏洞列表 \n    \u003cdiv id=\"%E6%BC%8F%E6%B4%9E%E5%88%97%E8%A1%A8\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%E6%BC%8F%E6%B4%9E%E5%88%97%E8%A1%A8\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e发现的11个漏洞由6个关键漏洞组成，可能导致远程代码执行：\u003c/p\u003e","title":"VxWorks的多个高危漏洞预警","type":"news"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]